#!/usr/bin/perl -w

# $Id: configure-gx-map,v 1.25 2005-01-28 18:00:52-08 kst Exp $
# $Source: /home/kst/gx-map-redacted/configure-gx-map,v $

# This script should be executed from the base source directory of the
# gx-map package.  If you don't have a Perl executable in /usr/bin/perl,
# just run it as "perl ./configure-gx-map config-file".

########################################################################
# @Copyright@
#
# Copyright (c) 2005 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use Getopt::Long ();

sub Home_Dir($);
sub Command_Exists($$);
sub Perl_Error($);
sub Globus_Admins_Error($);
sub Same_File($$);
sub Usage(@);

#
# Make warnings fatal.
#
$SIG{__WARN__} = sub { die @_ };

my $Program_Name = File::Basename::basename $0;

my $User_Opt = {};
my @Opts = ( $User_Opt,
             qw( help
                 version
                 perl=s
                 path=s
                 namespace=s
                 install-dir|prefix=s
                 data-dir=s
                 requests-log-permissions=s
                 globus-admins=s
                 admin-email=s
                 valid-mappings-file=s
                 debugging ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
if ($User_Opt->{version}) {
    die "\"-version\" option not implemented in configure-gx-map\n",
        "See \$VERSION in Gridmap_Utils.pm.in\n";
}

my %Config = ();

my @Commands = qw( wget ncftpget rcs ci openssl hostname );
my %Missing_Command = ();
my @Errors = ();

if (defined $User_Opt->{perl}) {
    my $err = Perl_Error $User_Opt->{perl};
    if (defined $err) {
        push @Errors, $err;
    }
    else {
        $Config{PERL} = $User_Opt->{perl};
    }
}
else {
    if (not defined Perl_Error '/usr/bin/perl') {
        $Config{PERL} = '/usr/bin/perl';
    }
    elsif (not defined Perl_Error '/usr/local/bin/perl') {
        $Config{PERL} = '/usr/local/bin/perl';
    }
    else {
        push @Errors, "Can't find Perl 5.006 or better in " .
                      "/usr/bin or /usr/local/bin\n" .
                      "Specify -perl option\n";
    }
}

if (defined $User_Opt->{path}) {
    my @bad = ();
    foreach my $dir (split /:/, $User_Opt->{path}) {
        push @bad, $dir if not -d $dir;
    }
    if (@bad) {
        my $directories = scalar @bad == 1 ? 'directory' : 'directories';
        push @Errors, "Invalid $directories in path: @bad\n";
    }
    $Config{PATH} = $User_Opt->{path};
}
else {
    my $path = '/usr/bin';
    $path .= ':/bin' if not Same_File '/usr/bin', '/bin';
    foreach my $command (@Commands) {
        if (not Command_Exists $command, $path and
            -x "/usr/local/bin/$command")
        {
            $path .= ':/usr/local/bin';
            last;
        }
    }
    foreach my $command (@Commands) {
        if (not Command_Exists $command, $path) {
            $Missing_Command{$command} = 1;
        }
    }
    $Config{PATH} = $path;
}

if (defined $User_Opt->{namespace}) {
    $Config{NAMESPACE} = $User_Opt->{namespace};
}
else {
    $Config{NAMESPACE} = 'UNDEF';
}

if (defined $User_Opt->{'install-dir'}) {
    if ($User_Opt->{'install-dir'} !~ /^\//) {
        push @Errors, "Bad value for -install-dir\n";
    }
    else {
        $Config{INSTALL_DIR} = $User_Opt->{'install-dir'};
    }
}
else {
    push @Errors, "-install-dir not specified\n";
}

if (defined $User_Opt->{'data-dir'}) {
    if ($User_Opt->{'data-dir'} !~ /^\//) {
        push @Errors, "Bad value for -data-dir\n";
    }
    else {
        $Config{DATA_DIR} = $User_Opt->{'data-dir'};
    }
}
else {
    push @Errors, "-data-dir not specified\n";
}

if (defined $User_Opt->{'requests-log-permissions'}) {
    my $perms = $User_Opt->{'requests-log-permissions'};
    if ($perms eq '444' or $perms eq '440' or $perms eq '400') {
        $Config{REQUESTS_LOG_PERMISSIONS} = $perms;
    }
    else {
        push @Errors, "Argument to -requests-log-permissions " .
                      "must be 444, 440, or 400\n";
    }
}
else {
    $Config{REQUESTS_LOG_PERMISSIONS} = '444';
}

if (defined $User_Opt->{'globus-admins'}) {
    my $err = Globus_Admins_Error $User_Opt->{'globus-admins'};
    if (defined $err) {
        push @Errors, $err;
    }
    else {
        $Config{GLOBUS_ADMINS} = $User_Opt->{'globus-admins'};
    }
}
else {
    my @pw = getpwnam 'globus';
    if (@pw) {
        $Config{GLOBUS_ADMINS} = 'globus';
    }
    else {
        $Config{GLOBUS_ADMINS} = 'UNDEF';
    }
}

if (defined $User_Opt->{'admin-email'}) {
    $Config{ADMIN_EMAIL} = $User_Opt->{'admin-email'};
}
else {
    $Config{ADMIN_EMAIL} = 'UNDEF';
}

if (defined $User_Opt->{'valid-mappings-file'}) {
    $Config{VALID_MAPPINGS_FILE} = $User_Opt->{'valid-mappings-file'};
}
else {
    $Config{VALID_MAPPINGS_FILE} = 'UNDEF';
}

foreach my $key (sort keys %Config) {
    printf "%-24s => %s\n",
           $key,
           ( defined $Config{$key} ? $Config{$key} : 'undef' );
}

if (@Errors) {
    die "Error(s):\n", @Errors;
}

open TEMPLATE, 'gx-map.conf.in' or die "gx-map.conf.in: $!\n";
open CONFIG,  '>gx-map.conf'    or die "gx-map.conf: $!\n";
while (<TEMPLATE>) {
    chomp;
    my $var_error = undef;
    if (/^([A-Z_]+)/) {
        my ($var, $blanks1, $value, $blanks2, $comment)
            = /^([A-Z_]+)(\s+)(.*?)(\s*)(#.*|)$/;
#       print ">>> var     = \"$var\"\n";
#       print ">>> blanks1 = \"$blanks1\"\n";
#       print ">>> value   = \"$value\"\n";
#       print ">>> blanks2 = \"$blanks2\"\n";
#       if (defined $comment) {
#           print ">>> comment = \"$comment\"\n";
#       }
#       else {
#           print ">>> comment = undef\n";
#       }
#       print "\n";

        if (defined $Config{$var}) {

            $value = $Config{$var};
	    $_ = "$var$blanks1$value$blanks2$comment";

            if ($var eq 'PATH') {
                s/\S+$/$Config{PATH}/;
                if (scalar keys %Missing_Command > 0) {
                    my $s = scalar keys %Missing_Command == 1 ? '' : 's';
                    print CONFIG "# >>> Missing command$s in PATH: ",
                                 join(' ', sort keys %Missing_Command),
                                 "\n";
                    if ($Missing_Command{ncftpget} or $Missing_Command{wget}) {
                        print CONFIG "#     You may not need ",
                                     "ncftpget or wget\n";
                    }
                }
            }

            if ($var ne 'VALID_MAPPINGS_FILE' and
                $Config{$var} eq 'UNDEF')
            {
                $var_error = "# >>> Need to set a valid value for $var\n";
            }
        }
        else {
            $var_error = "# >>> Unrecognized variable $var\n";
        }
    }
    print CONFIG "$_\n";
    print CONFIG $var_error if defined $var_error;
}
close TEMPLATE;
close CONFIG;

print "Created gx-map.conf\n";

## my @Var_Names = qw( PERL PATH
##                     NAMESPACE
##                     INSTALL_DIR DATA_DIR
##                     REQUESTS_LOG_PERMISSIONS
##                     GLOBUS_ADMINS ADMIN_EMAIL );
## my %Valid_Var_Name = map { $_ => 1 } @Var_Names;
## $Valid_Var_Name{VALID_MAPPINGS_FILE} = 1; # optional
## 
## if (scalar @ARGV == 1 and -e $ARGV[0]) {
##     $Config_File = $ARGV[0];
## }
## else {
##     Usage;
## }
## 
## my @errors = ();
## my @warnings = ();
## 
## #
## # Record the name of the config file so it can be installed in etc
## #
## open CONFIG_FILE_NAME, ">.config-file";
## print CONFIG_FILE_NAME "$Config_File\n";
## close CONFIG_FILE_NAME;
## 
## open CONFIG, $Config_File or die "$Config_File: $!\n";
## while (<CONFIG>) {
##     s/#.*$//;
##     s/^\s+//;
##     s/\s+$//;
##     next if /^$/;
## 
##     chomp;
## 
##     if (/^(\w+)\s+(.*)$/) {
##         my($name, $value) = ($1, $2);
##         eval { $value =~ s/~(\w+)/Home_Dir $1/eg; };
##         if ($@) {
##             chomp $@;
##             push @errors, "$@, $Config_File line $.\n";
##         }
##         if ($Valid_Var_Name{$name}) {
##             if (exists $Config{$name}) {
##                 push @errors,
##                      "Duplicate name \"$name\", $Config_File line $.\n";
##             }
##             else {
##                 $Config{$name} = $value;
##             }
##         }
##         else {
##             push @errors, "Invalid name \"$name\", $Config_File line $.\n";
##         }
##     }
## }
## close CONFIG;
## 
## foreach my $name (@Var_Names) {
##     if (not defined $Config{$name}) {
##         push @errors, "Missing definition for \"$name\" in $Config_File\n";
##     }
## }
## 
## #
## # Do some quick sanity checks (especially for GLOBUS_ADMINS, whose syntax
## # has changed in release 0.4).
## #
## if (defined $Config{PERL} and
##     ($Config{PERL} !~ /^\// or not -x $Config{PERL}))
## {
##     push @errors, "$Config_File: Bad value for \"PERL\"\n";
## }
## if (defined $Config{PATH}) {
##     foreach my $dir (split /:/, $Config{PATH}) {
##         if ($dir !~ /^\// or not -d $dir) {
##             push @errors, "$Config_File: Bad directory \"$dir\" in PATH\n";
##         }
##     }
##     #
##     # The wget and ncftpget commands are not required if you don't use
##     # a downloadable requests log.
##     #
##     my %optional = (wget => 1, ncftpget => 1);
##     foreach my $command (qw(wget ncftpget rcs ci cp)) {
##         if (not Command_Exists $command, $Config{PATH}) {
##             if ($optional{$command}) {
##                 push @warnings,
##                      "Command $command not found in configured PATH\n";
##             }
##             else {
##                 push @errors,
##                      "Command $command not found in configured PATH\n";
##             }
##         }
##     }
## }
## foreach my $name (qw(INSTALL_DIR DATA_DIR)) {
##     if (defined $Config{$name} and $Config{$name} !~ /^\//) {
##         push @errors, "$Config_File: Bad value for \"$name\"\n";
##     }
## }
## if (defined $Config{REQUESTS_LOG_PERMISSIONS}) {
##     my %ok = ( '400' => 1, '440' => 1, '444' => 1 );
##     if (not $ok{$Config{REQUESTS_LOG_PERMISSIONS}}) {
##         push @errors, "$Config_File: Bad REQUESTS_LOG_PERMISSIONS " .
##                       "(use 400, 440, or 444)\n";
##     }
## }
## if (defined $Config{GLOBUS_ADMINS}) {
##     foreach my $admin (split /\s+/, $Config{GLOBUS_ADMINS}) {
##         if ($admin =~ /^user:(.*)/) {
##             my $admin_name = $1;
##             push @errors,
##                  "$Config_File: Replace \"$admin\" with \"$admin_name\" " .
##                  "in GLOBUS_ADMINS\n";
##         }
##         elsif ($admin =~ /^group:/) {
##             push @errors, "$Config_File: Groups are no longer supported " .
##                           "in GLOBUS_ADMINS\n";
##         }
##         else {
##             my @pw = getpwnam $admin;
##             if (not @pw) {
##                 push @errors,
##                      "$Config_File: No user \"$admin\" in GLOBUS_ADMINS\n";
##             }
##         }
##     }
## }
## 
## die @errors if @errors;
## 
## opendir DIR, '.' or die ".: $!\n";
## my @in_files = sort grep /\.in$/, readdir DIR;
## closedir DIR;
## 
## die "No *.in files found\n" if not @in_files;
## 
## my $max_len = 0;
## foreach my $in_file (@in_files) {
##     $max_len = length $in_file if length $in_file > $max_len;
## }
## 
## foreach my $in_file (@in_files) {
##     my $out_file = $in_file;
##     $out_file =~ s/\.in$//;
## 
##     if ($in_file eq 'Gridmap_Valid_Mappings.pm.in' and
##         defined $Config{VALID_MAPPINGS_FILE})
##     {
##         #
##         # Special case: The VALID_MAPPINGS_FILE configuration option
##         # overrides the name of the input file (but not the output file)
##         # for Gridmap_Valid_Mappings.pm.
##         #
##         $in_file = $Config{VALID_MAPPINGS_FILE};
##     }
## 
##     printf "%-${max_len}s --> %s\n", $in_file, $out_file;
##     open IN, $in_file or die "$in_file: $!\n";
##     open OUT, ">$out_file" or die "$out_file: $!\n";
##     while (<IN>) {
##         foreach my $var (@Var_Names) {
##             s/%$var%/$Config{$var}/g;
##         }
##         if (/%\w+%/) {
##             warn ">>> Unrecognized variable $&, $in_file line $.\n";
##         }
##         print OUT;
##     }
##     close IN;
##     close OUT;
## 
##     my $mode = (stat $in_file)[2];
##     chmod $mode, $out_file;
## }

########################################################################

my %home_dir = ();

sub Home_Dir($) {
    my($user) = @_;
    if (not exists $home_dir{$user}) {
        my @pw = getpwnam $user;
        if (@pw) {
            $home_dir{$user} = $pw[7];
        }
        else {
            $home_dir{$user} = undef;
        }
    }
    if (defined $home_dir{$user}) {
        return $home_dir{$user};
    }
    else {
        die "No such user \"$user\"\n";
    }
} # Home_Dir

# ----------------------------------------------------------------------

sub Command_Exists($$) {
    my ($command, $path) = @_;
    foreach my $dir (split /:/, $path) {
        if (-x "$dir/$command") {
            return 1;
        }
    }
    return 0;
} # Command_Exists

# ----------------------------------------------------------------------

sub Perl_Error($) {
    my($perl) = @_;
    return 'No such file'   if not -e $perl;
    return 'Not executable' if not -x $perl;
    system "$perl -e 'require 5.006' >/dev/null 2>/dev/null";
    return 'Perl 5.006 or better required' if $? != 0;
    return undef;
} # Perl_Error

# ----------------------------------------------------------------------

sub Globus_Admins_Error($) {
    my $globus_admins = @_;
    my @missing_users = ();
    foreach my $admin (split /\s+/, $globus_admins) {
        my @pw = getpwnam $admin;
        if (not @pw) {
             push @missing_users, $admin;
        }
    }
    if (scalar @missing_users == 0) {
        return undef; # no error
    }
    else {
        my $s = ( scalar @missing_users == 1 ? '' : 's' );
        return "No user$s ", join(', ', @missing_users), "\n";
    }
} # Globus_Admins_Error

# ----------------------------------------------------------------------

sub Same_File($$) {
    my($file1, $file2) = @_;
    my @stat1 = stat $file1;
    return 0 if not @stat1;
    my @stat2 = stat $file2;
    return 0 if not @stat2;
    my ($dev1, $ino1) = ($stat1[0], $stat1[1]);
    my ($dev2, $ino2) = ($stat2[0], $stat2[1]);
    return ($dev1 == $dev2 and $ino1 == $ino2);
} # Same_File;

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name [options]
    -help               Show this message and exit
    -perl command       Full path to Perl command
    -path value         Value to be used for \$PATH
    -namespace value    Namespace (default is UNDEF)
    -install-dir dir    Installation directory (mandatory)
    -prefix dir         Alias for "-install-dir dir"
    -data-dir dir       Data directory (mandatory)
    -requests-log-permissions octal
                        Permissions for requests.log (default 444)
    -globus-admins accounts
                        Administrative account(s) (default globus)
    -admin-email addr   E-mail address for admin contact
    -valid-mappings-file file
                        File containing customized Gridmap_Valid_Mappings
                        Perl module (not normally needed)
    -debugging          Enable debugging
EOF
    exit 1;
} # Usage
