#!/usr/bin/perl -w

# $Id: configure-gx-map,v 1.46 2006-06-07 19:47:46-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/configure-gx-map,v $

# This script should be executed from the base source directory of the
# gx-map package.  If you don't have a Perl executable in /usr/bin/perl,
# just run it as "perl ./configure-gx-map config-file".

########################################################################
# @Copyright@
#
# Copyright (c) 2006 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Advanced Cyberinfrastructure
# Laboratory at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename;

sub Need_File($);
sub Home_Dir($);
sub Command_Exists($$);
sub Get_Version();
sub Check_Admin($$);
sub Pod2Man_Command();
sub Make_Man_Pages();
sub Usage(@);

my $Program_Name = File::Basename::basename $0;
my $Config_File = undef;
my %Config = ();
my @Required_Var_Names
    = qw( PERL PATH
          NAMESPACE
          INSTALL_DIR DATA_DIR
          REQUESTS_LOG_PERMISSIONS
          GX_MAP_OWNER ADDITIONAL_ADMINS ADMIN_EMAIL );
my @Optional_Var_Names = qw( GX_PROPAGATE EXTRAS );
my @Var_Names = ( @Required_Var_Names, @Optional_Var_Names );
my %Required_Var_Name = map { $_ => 1 } @Required_Var_Names;
my %Valid_Var_Name    = map { $_ => 1 } @Var_Names;

if (scalar @ARGV == 1 and -e $ARGV[0]) {
    $Config_File = $ARGV[0];
}
else {
    Usage;
}

my %Is_TGCDB_File     = ( 'gx-check-db-requests.in' => 1,
                          'gx-db-request.in'        => 1 );
my %Is_TGCDB_Test_File = ( %Is_TGCDB_File,
                           'gx-dump-db.in'          => 1 );

my $Prereq_Error = undef;
my $Pod2Man_Error = undef;

my $version = Get_Version;

my @errors = ();
my @warnings = ();

#
# Record the name of the config file so it can be installed in etc/gx-map
#
open CONFIG_FILE_NAME, ">.config-file";
print CONFIG_FILE_NAME "$Config_File\n";
close CONFIG_FILE_NAME;

open CONFIG, $Config_File or die "$Config_File: $!\n";
while (<CONFIG>) {
    s/#.*$//;
    s/^\s+//;
    s/\s+$//;
    next if /^$/;

    chomp;

    if (/^(\w+)\s+(.*)$/) {
        my($name, $value) = ($1, $2);
        eval { $value =~ s/~([\w.-]+)/Home_Dir $1/eg; };
        if ($@) {
            chomp $@;
            push @errors, "$@, $Config_File line $.\n";
        }
        $value =~ s/%VERSION%/$version/g;
        if ($Valid_Var_Name{$name}) {
            if (exists $Config{$name}) {
                push @errors,
                     "Duplicate name \"$name\", $Config_File line $.\n";
            }
            else {
                $Config{$name} = $value;
            }
        }
        else {
            push @errors, "Invalid name \"$name\", $Config_File line $.\n";
        }
    }
    elsif (/^(\w+)$/) {
        #
        # Only ADDITIONAL_ADMINS is allowed to have an empty definition.
        #
        my($name) = $1;
        if ($name eq 'ADDITIONAL_ADMINS') {
            $Config{$name} = '';
        }
        else {
            push @errors, "Invalid value for $name, $Config_File line $.\n";
        }
    }
}
close CONFIG;

foreach my $name (@Var_Names) {
    if (not defined $Config{$name}) {
        if ($Required_Var_Name{$name}) {
            push @errors, "Missing definition for \"$name\" in $Config_File\n";
        }
        else {
            #
            # If GX_PROPAGATE or EXTRAS isn't defined, it's more
            # convenient to set it to the empty string.
            #
            $Config{$name} = '';
        }
    }
}

#
# Do some quick sanity checks.
#
if (defined $Config{PERL} and
    ($Config{PERL} !~ /^\// or not -x $Config{PERL}))
{
    push @errors, "$Config_File: Bad value for \"PERL\"\n";
}
if (defined $Config{PATH}) {
    foreach my $dir (split /:/, $Config{PATH}) {
        if ($dir !~ /^\// or not -d $dir) {
            push @errors, "$Config_File: Bad directory \"$dir\" in PATH\n";
        }
    }
    #
    # Currently, all external commands are mandatory.  (curl is arguably
    # optional, but only if you don't use a downloaded requests.log *and*
    # you don't use gx-ca-update.)
    #
    my %optional = ();
    foreach my $command (qw(curl rcs ci)) {
        if (not Command_Exists $command, $Config{PATH}) {
            if ($optional{$command}) {
                push @warnings,
                     "Command $command not found in configured PATH\n";
            }
            else {
                push @errors,
                     "Command $command not found in configured PATH\n";
            }
        }
    }
}
foreach my $name (qw(INSTALL_DIR DATA_DIR)) {
    if (defined $Config{$name} and $Config{$name} !~ /^\//) {
        push @errors, "$Config_File: Bad value for \"$name\"\n";
    }
}
if (defined $Config{REQUESTS_LOG_PERMISSIONS}) {
    my %ok = ( '400' => 1, '440' => 1, '444' => 1 );
    if (not $ok{$Config{REQUESTS_LOG_PERMISSIONS}}) {
        push @errors, "$Config_File: Bad REQUESTS_LOG_PERMISSIONS " .
                      "(use 400, 440, or 444)\n";
    }
}
if (defined $Config{GX_MAP_OWNER}) {
    Check_Admin $Config{GX_MAP_OWNER}, 'GX_MAP_OWNER';
}
if (defined $Config{ADDITIONAL_ADMINS}) {
    foreach my $acct (split /\s+/, $Config{ADDITIONAL_ADMINS}) {
        Check_Admin $acct, 'ADDITIONAL_ADMINS';
    }
}
if ($Config{EXTRAS} ne '') {
    if ($Config{EXTRAS} ne 'TGCDB' and
        $Config{EXTRAS} ne 'TGCDB_TEST')
    {
        push @errors, "$Config_File: Bad value for EXTRAS\n";
    }
}

die @errors if @errors;

#
# Check prerequisites
#
print "Checking prerequisites... \n";
if (-x 'gx-check-prereqs') {
    my @command = ( $Config{PERL},
                    './gx-check-prereqs',
                    '-path', $Config{PATH} );
    if ($Config{GX_PROPAGATE} =~ /teragrid/i) {
        push @command, '-teragrid';
    }
    print "% @command\n";
    my $result = system @command;
    if ($result != 0) {
        $Prereq_Error = "gx-check-prereqs failed";
    }
}
else {
    $Prereq_Error = "Can't find gx-check-prereqs command";
}

my @in_files = ();
my %out_file = ();

opendir DIR, '.' or die ".: $!\n";
foreach my $in_file (sort grep /\.in$/, readdir DIR) {
    if (Need_File $in_file) {
        push @in_files, $in_file;
        ($out_file{$in_file} = $in_file) =~ s/\.in$//;
    }
}
closedir DIR;

if ($Config{GX_PROPAGATE} ne '') {
    push @in_files, $Config{GX_PROPAGATE};
    $out_file{$Config{GX_PROPAGATE}} = 'gx-propagate';
}

die "No *.in files found\n" if not @in_files;

my $max_len = 0;
foreach my $in_file (@in_files) {
    $max_len = length $in_file if length $in_file > $max_len;
}

foreach my $in_file (@in_files) {
    my $out_file = $out_file{$in_file};
    printf "%-${max_len}s --> %s\n", $in_file, $out_file;
    open IN, $in_file or die "$in_file: $!\n";
    open OUT, ">$out_file" or die "$out_file: $!\n";
    while (<IN>) {
        foreach my $var (@Var_Names) {
            s/%$var%/$Config{$var}/g;
        }
        if (/%\w+%/) {
            warn ">>> Unrecognized variable $&, $in_file line $.\n";
        }
        print OUT;
    }
    close IN;
    close OUT;

    my $mode = (stat $in_file)[2];
    chmod $mode, $out_file;
}

Make_Man_Pages;

if (defined $Prereq_Error) {
    warn ">>> $Prereq_Error, proceed with caution\n";
}

if (defined $Pod2Man_Error) {
    warn ">>> pod2man command not found, man pages will not be installed\n";
}

########################################################################

sub Need_File($) {
    my($file) = @_;
    #
    # Order is significant.  TGCDB is a subset of TGCDB_TEST.
    #
    if ($Is_TGCDB_File{$file}) {
        return (defined $Config{EXTRAS} and $Config{EXTRAS} eq 'TGCDB');
    }
    elsif ($Is_TGCDB_Test_File{$file}) {
        return (defined $Config{EXTRAS} and $Config{EXTRAS} eq 'TGCDB_TEST');
    }
    else {
        return 1;
    }
} # Need_File

# ----------------------------------------------------------------------

my %home_dir = ();

sub Home_Dir($) {
    my($user) = @_;
    if (not exists $home_dir{$user}) {
        my @pw = getpwnam $user;
        if (@pw) {
            $home_dir{$user} = $pw[7];
        }
        else {
            $home_dir{$user} = undef;
        }
    }
    if (defined $home_dir{$user}) {
        return $home_dir{$user};
    }
    else {
        die "No such user \"$user\"\n";
    }
} # Home_Dir

# ----------------------------------------------------------------------

sub Command_Exists($$) {
    my ($command, $path) = @_;
    foreach my $dir (split /:/, $path) {
        if (-x "$dir/$command") {
            return 1;
        }
    }
    return 0;
} # Command_Exists

# ----------------------------------------------------------------------

sub Get_Version() {
    my $result = undef;
    my $module = 'Gridmap_Utils.pm.in';
    open MODULE, $module or die "${module}: $!\n";
    while (<MODULE>) {
        if (/\$VERSION\s*=\s*'(.*)'/) {
            $result = $1;
            last;
        }
    }
    close MODULE;
    die "Can't get version number from $module\n" if not defined $result;
    return $result;
} # Get_Version

# ----------------------------------------------------------------------

sub Check_Admin($$) {
    my($acct, $from) = @_;
    if ($acct eq 'root') {
        push @errors, "$Config_File: root is not allowed in $from\n";
    }
    else {
        my @pw = getpwnam $acct;
        if (not @pw) {
            push @errors,
                 "$Config_File: No user \"$acct\" in $from\n";
        }
        elsif ($pw[2] eq 0) {
            push @errors,
                 "$Config_File: User \"$acct\" has UID 0, " .
                 "not allowed in $from\n";
        }
    }
} # Check_Admin

# ----------------------------------------------------------------------

sub Pod2Man_Command() {
    my %checked = ();

    my $perl_command = $Config{PERL};
    while (defined $perl_command and -l $perl_command) {
        $perl_command = readlink $perl_command;
    }

    my @dirs = ();
    if (defined $perl_command) {
        push @dirs, File::Basename::dirname $perl_command;
    }
    push @dirs, split(/:/, $Config{PATH});
    push @dirs, split(/:/, $ENV{PATH});

    DIR:
    foreach my $dir (@dirs) {
        next DIR if $checked{$dir}++;
        if (-x "$dir/pod2man") {
            return "$dir/pod2man";
        }
    }
    return undef;
} # Pod2Man_Command

# ----------------------------------------------------------------------

sub Make_Man_Pages() {
    my %center = ( 1 => 'User Commands',
                   3 => 'Functions',
                   5 => 'File Formats',
                   7 => 'Miscellaneous Information',
                   8 => 'Administrative Commands' );

    opendir my $Doc, 'doc' or die "doc: $!\n";
    my @pods = grep /\.pod$/, sort readdir $Doc;
    closedir $Doc;

    my $pod2man = Pod2Man_Command();
    if (not defined $pod2man) {
        $Pod2Man_Error = 1;
        return;
    }
    print "Using $pod2man ...\n";
    my $max_len = 0;
    foreach my $pod (@pods) {
        $max_len = length "doc/$pod" if length "doc/$pod" > $max_len;
    }
    foreach my $pod (@pods) {
        if ($pod =~ /^(.*)\.(\d)\.pod$/) {
            my($name, $section) = ($1, $2);
            my $man_page = "$name.$section";
            my @command = ( $pod2man,
                            '--section', $section,
                            '--release', "'gx-map $version'",
                            '--center', "'$center{$section}'",
                            '--name', $name,
                            "doc/$pod" );
            printf "%-${max_len}s --> %s\n", "doc/$pod", "doc/$man_page";
            system "@command > doc/$man_page";
        }
    }
} # Make_Man_Pages

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name config-file
EOF
    exit 1;
} # Usage
