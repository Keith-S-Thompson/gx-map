#!/usr/bin/perl -w

# $Id: configure-gx-map,v 1.26 2005-04-17 02:50:03-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/configure-gx-map,v $

# This script should be executed from the base source directory of the
# gx-map package.  If you don't have a Perl executable in /usr/bin/perl,
# just run it as "perl ./configure-gx-map config-file".

########################################################################
# @Copyright@
#
# Copyright (c) 2005 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename;

sub Home_Dir($);
sub Command_Exists($$);
sub Usage(@);

my $Program_Name = File::Basename::basename $0;
my $Config_File = undef;
my %Config = ();
my @Var_Names = qw( PERL PATH
                    NAMESPACE
                    INSTALL_DIR DATA_DIR
                    REQUESTS_LOG_PERMISSIONS
                    GLOBUS_ADMINS ADMIN_EMAIL );
my %Valid_Var_Name = map { $_ => 1 } @Var_Names;
$Valid_Var_Name{VALID_MAPPINGS_FILE} = 1; # optional

if (scalar @ARGV == 1 and -e $ARGV[0]) {
    $Config_File = $ARGV[0];
}
else {
    Usage;
}

my @errors = ();
my @warnings = ();

#
# Record the name of the config file so it can be installed in etc
#
open CONFIG_FILE_NAME, ">.config-file";
print CONFIG_FILE_NAME "$Config_File\n";
close CONFIG_FILE_NAME;

open CONFIG, $Config_File or die "$Config_File: $!\n";
while (<CONFIG>) {
    s/#.*$//;
    s/^\s+//;
    s/\s+$//;
    next if /^$/;

    chomp;

    if (/^(\w+)\s+(.*)$/) {
        my($name, $value) = ($1, $2);
        eval { $value =~ s/~(\w+)/Home_Dir $1/eg; };
        if ($@) {
            chomp $@;
            push @errors, "$@, $Config_File line $.\n";
        }
        if ($Valid_Var_Name{$name}) {
            if (exists $Config{$name}) {
                push @errors,
                     "Duplicate name \"$name\", $Config_File line $.\n";
            }
            else {
                $Config{$name} = $value;
            }
        }
        else {
            push @errors, "Invalid name \"$name\", $Config_File line $.\n";
        }
    }
}
close CONFIG;

foreach my $name (@Var_Names) {
    if (not defined $Config{$name}) {
        push @errors, "Missing definition for \"$name\" in $Config_File\n";
    }
}

#
# Do some quick sanity checks (especially for GLOBUS_ADMINS, whose syntax
# has changed in release 0.4).
#
if (defined $Config{PERL} and
    ($Config{PERL} !~ /^\// or not -x $Config{PERL}))
{
    push @errors, "$Config_File: Bad value for \"PERL\"\n";
}
if (defined $Config{PATH}) {
    foreach my $dir (split /:/, $Config{PATH}) {
        if ($dir !~ /^\// or not -d $dir) {
            push @errors, "$Config_File: Bad directory \"$dir\" in PATH\n";
        }
    }
    #
    # The wget and ncftpget commands are not required if you don't use
    # a downloadable requests log.
    #
    my %optional = (wget => 1, ncftpget => 1);
    foreach my $command (qw(wget ncftpget rcs ci cp)) {
        if (not Command_Exists $command, $Config{PATH}) {
            if ($optional{$command}) {
                push @warnings,
                     "Command $command not found in configured PATH\n";
            }
            else {
                push @errors,
                     "Command $command not found in configured PATH\n";
            }
        }
    }
}
foreach my $name (qw(INSTALL_DIR DATA_DIR)) {
    if (defined $Config{$name} and $Config{$name} !~ /^\//) {
        push @errors, "$Config_File: Bad value for \"$name\"\n";
    }
}
if (defined $Config{REQUESTS_LOG_PERMISSIONS}) {
    my %ok = ( '400' => 1, '440' => 1, '444' => 1 );
    if (not $ok{$Config{REQUESTS_LOG_PERMISSIONS}}) {
        push @errors, "$Config_File: Bad REQUESTS_LOG_PERMISSIONS " .
                      "(use 400, 440, or 444)\n";
    }
}
if (defined $Config{GLOBUS_ADMINS}) {
    foreach my $admin (split /\s+/, $Config{GLOBUS_ADMINS}) {
        if ($admin =~ /^user:(.*)/) {
            my $admin_name = $1;
            push @errors,
                 "$Config_File: Replace \"$admin\" with \"$admin_name\" " .
                 "in GLOBUS_ADMINS\n";
        }
        elsif ($admin =~ /^group:/) {
            push @errors, "$Config_File: Groups are no longer supported " .
                          "in GLOBUS_ADMINS\n";
        }
        else {
            my @pw = getpwnam $admin;
            if (not @pw) {
                push @errors,
                     "$Config_File: No user \"$admin\" in GLOBUS_ADMINS\n";
            }
        }
    }
}

die @errors if @errors;

opendir DIR, '.' or die ".: $!\n";
my @in_files = sort grep /\.in$/, readdir DIR;
closedir DIR;

die "No *.in files found\n" if not @in_files;

my $max_len = 0;
foreach my $in_file (@in_files) {
    $max_len = length $in_file if length $in_file > $max_len;
}

foreach my $in_file (@in_files) {
    my $out_file = $in_file;
    $out_file =~ s/\.in$//;

    if ($in_file eq 'Gridmap_Valid_Mappings.pm.in' and
        defined $Config{VALID_MAPPINGS_FILE})
    {
        #
        # Special case: The VALID_MAPPINGS_FILE configuration option
        # overrides the name of the input file (but not the output file)
        # for Gridmap_Valid_Mappings.pm.
        #
        $in_file = $Config{VALID_MAPPINGS_FILE};
    }

    printf "%-${max_len}s --> %s\n", $in_file, $out_file;
    open IN, $in_file or die "$in_file: $!\n";
    open OUT, ">$out_file" or die "$out_file: $!\n";
    while (<IN>) {
        foreach my $var (@Var_Names) {
            s/%$var%/$Config{$var}/g;
        }
        if (/%\w+%/) {
            warn ">>> Unrecognized variable $&, $in_file line $.\n";
        }
        print OUT;
    }
    close IN;
    close OUT;

    my $mode = (stat $in_file)[2];
    chmod $mode, $out_file;
}

########################################################################

my %home_dir = ();

sub Home_Dir($) {
    my($user) = @_;
    if (not exists $home_dir{$user}) {
        my @pw = getpwnam $user;
        if (@pw) {
            $home_dir{$user} = $pw[7];
        }
        else {
            $home_dir{$user} = undef;
        }
    }
    if (defined $home_dir{$user}) {
        return $home_dir{$user};
    }
    else {
        die "No such user \"$user\"\n";
    }
} # Home_Dir

# ----------------------------------------------------------------------

sub Command_Exists($$) {
    my ($command, $path) = @_;
    foreach my $dir (split /:/, $path) {
        if (-x "$dir/$command") {
            return 1;
        }
    }
    return 0;
} # Command_Exists

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name config-file
EOF
    exit 1;
} # Usage
