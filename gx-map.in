#!%PERL% -w

# $Id: gx-map.in,v 1.29 2004-09-11 21:59:32-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-map.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2004 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use Getopt::Long ();

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

my $Default_Data_Dir = "$Install_Dir/var";

sub Usage(@);
sub Long_Usage();
sub Strip($);
sub Get_Options_Interactively();
sub Get_Options_From_Command_Line();
sub Is_Valid_DN($);
sub Request_Update();
sub Get_DN_From_File($);
sub Gen_Request_File_Name();
sub Debug(@);
sub Debugf(@);

my $Prog_Name = File::Basename::basename $0;
my $hostname;
my $Now = time;

#
# There are three variables dealing with command-line options.
#
# @Opts is an array that is passed to Getopt::Long::GetOptions;
# it defines what command-line options are recognized.
#
# $User_Opt is a hash reference; the hash is is filled in by
# Getopt::Long::GetOptions, and contains information about any
# command-line arguments that were actually given.  The field names are
# simply the names of the command-line options.  Multi-word field names
# are punctuated with hyphens, matching the command-line syntax.
#
# $Options is also a hash reference; the hash contains the information
# necessary to perform the specified operation.  This can be set either
# from command-line options or interactively.
#
# Fields are:
#    operation (one of add, remove, remove-dn, remove-user, update)
#    username
#    dn-method (one of dn, file, none)
#    certificate-file (set only if dn-method is 'file')
#    dn
#    secondary (optional, value 'yes' or 'no'; applies only to 'add' op)
#    email (optional)
#    comment (optional)
# Plus the following flags:
#    interactive
#    quiet
#    force
#

my $User_Opt = {};
my $Options = {};
my @Opts = ( $User_Opt,
             qw( help long-help version
                 interactive
                 add
                 remove remove-dn remove-user
                 update
                 quiet force no-admin
                 dn=s certificate-file=s username=s
                 secondary
                 directory=s
                 email=s
                 force-dn no-email comment=s
                 debugging ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;
Long_Usage if $User_Opt->{'long-help'};

if ($User_Opt->{version}) {
    print "gx-map version $Gridmap_Utils::VERSION\n";
    exit 0;
}

$Gridmap_Utils::Debugging = 1 if $User_Opt->{debugging};

#
# First, gather and verify some basic information about the user.
#
if ($< != $>) {
    die "Real UID ($<) != effective UID ($>)\n";
}

#
# $PW is a reference to the password information (name, uid, etc)
# of the user running this command.
#
my $PW = Gridmap_Utils::Get_PW $<;

if ($PW->{uid} != $<) {
    die "Internal error, uid from passwd ($PW->{uid}) != real uid ($<)\n";
}

#
# $Globus_Admin is true if the user running the command is an authorized
# Globus administrator and has not specified the "-no-admin" command-line
# option.
#
my $Globus_Admin = (not $User_Opt->{'no-admin'} and
                    Gridmap_Utils::Is_Globus_Admin $PW->{name});

if ($User_Opt->{interactive}) {
    $Options = Get_Options_Interactively();
}
else {
    $Options = Get_Options_From_Command_Line();
}

Debug "Options =>\n";
foreach my $key (sort keys %$Options) {
    Debug "    $key => $Options->{$key}\n";;
}

my $Requests_Dir = "$Options->{directory}/new-requests";

die "No directory $Options->{directory}\n" if not -d $Options->{directory};
die "No directory $Requests_Dir\n" if not -d $Requests_Dir;
die "Directory $Requests_Dir is not writable\n" if not -w $Requests_Dir;

if ($Options->{operation} eq 'update') {
    Request_Update();
    exit 0;
}

if ($Options->{'dn-method'} eq 'dn') {
    # nothing, dn is already set
}
elsif ($Options->{'dn-method'} eq 'file') {
    $Options->{dn} = Get_DN_From_File $Options->{'certificate-file'};
}

if (( $Options->{operation} eq 'add' or
      $Options->{operation} eq 'remove' or
      $Options->{operation} eq 'remove-user' )
    and not defined $Options->{username})
{
    if ($Globus_Admin) {
        Usage "No username specified\n";
    }
    else {
        $Options->{username} = $PW->{name};
    }
}

if (( $Options->{operation} eq 'add' or
      $Options->{operation} eq 'remove' or
      $Options->{operation} eq 'remove-dn' )
    and not defined $Options->{dn})
{
    Usage "No DN specified\n";
}

if (defined $Options->{dn} and
    not defined $Options->{'force-dn'} and
    not Is_Valid_DN $Options->{dn})
{
    Usage "Invalid DN \"$Options->{dn}\"\n";
}

#
# Disallow non-printing characters that may corrupt the request file.
#
if (defined $Options->{email}) {
    $Options->{email} =~ s/[^ -~]/?/g;
}
if (defined $Options->{comment}) {
    $Options->{comment} =~ s/[^\t -~]/?/g;
}

Debug "Options =>\n";
foreach my $key (sort keys %$Options) {
    Debug "    $key => $Options->{$key}\n";;
}

#
# The operation is either 'add', 'remove', 'remove-dn', or 'remove-user'.
#

my $requested_pw;
if ($Options->{operation} ne 'remove-dn') {
    if ($Options->{username} eq $PW->{name}) {
        $requested_pw = $PW;
    }
    else {
        #
        # Note: For an ordinary user, I need to validate the passwd information.
        # If a Globus administrator runs this command, it may be for an
        # account that doesn't exist on this machine; it may not be possible
        # to determine the uid.
        #
        $requested_pw = Gridmap_Utils::Get_PW $Options->{username};
        if (defined $requested_pw and
            $requested_pw->{name} ne $Options->{username})
        {
            die "Internal error, name from passwd ($requested_pw->{name}) != ",
                "specified name ($Options->{username})\n";
        }
    }
}

if (not $Options->{quiet}) {
    $| = 1;
    my $Mapping  = ( $Options->{force} ? 'Mapping'  : 'About to map' );
    my $Removing = ( $Options->{force} ? 'Removing' : 'About to remove' );
    if ($Options->{operation} eq 'add') {
        print "$Mapping distinguished name\n",
              "    \"$Options->{dn}\"\n",
              "to user\n",
              "    $Options->{username}\n";
    }
    elsif ($Options->{operation} eq 'remove') {
        print "$Removing mapping for distinguished name\n",
              "    \"$Options->{dn}\"\n",
              "to user\n",
              "    $Options->{username}\n";
    }
    elsif ($Options->{operation} eq 'remove-dn') {
        print "$Removing all mappings for distinguished name\n",
              "    \"$Options->{dn}\"\n";
    }
    elsif ($Options->{operation} eq 'remove-user') {
        print "$Removing all mappings for ",
              "user \"$Options->{username}\"\n";
    }
}
if (not $Options->{force}) {
    PROMPT:
    while (1) {
        print "Proceed? [yn] ";
        my $response = lc scalar <STDIN>;
        chomp $response;
        if ($response =~ /^y/) {
            last PROMPT;
        }
        elsif ($response =~ /^n/) {
            die "Request cancelled\n";
        }
        else {
            print "Unrecognized input\n";
        }
    }
}

$hostname = Gridmap_Utils::Get_Hostname();

my $Request_File = Gen_Request_File_Name();
my $Timestamp = Gridmap_Utils::Time_Image $Now;
my $requested_uid = undef;
if (defined $requested_pw) {
    $requested_uid = $requested_pw->{uid};
}

if (defined $Options->{username} and $Options->{username} eq 'root'
    or
    defined $requested_uid and $requested_uid == 0)
{
    die "Mapping to root or uid 0 is not allowed\n";
}

my $request = {
    operation         => $Options->{operation},
    timestamp         => $Timestamp,
    requested_by_uid  => $PW->{uid},
    requested_by_name => $PW->{name},
    hostname          => $hostname
};
$request->{dn}          = "\"$Options->{dn}\"" if defined $Options->{dn};
$request->{map_to_name} = $Options->{username} if defined $Options->{username};
$request->{map_to_uid}  = $requested_uid       if defined $requested_uid;
$request->{email}       = $Options->{email}    if defined $Options->{email};
$request->{comment}     = $Options->{comment}  if defined $Options->{comment};
if (defined $Options->{secondary} and $Options->{secondary} eq 'yes') {
    $request->{secondary} = 'yes';
}

#
# If gx-check-requests sees a partial request file, it will reject it
# and move it to the bad-requests directory.  To avoid this, create
# a temporary request file with a name ending in ".tmp" (making it
# invisible to gx-check-requests).  After the temporary file is created
# and has the proper permissions, rename it to the correct name.
#
my $tmp_file = $Request_File . ".tmp";
Gridmap_Utils::Write_Records '-single', $tmp_file, $request;
chmod 0444, $tmp_file;
rename $tmp_file, $Request_File;

unless ($Options->{force} and $Options->{quiet}) {
    print "Mapping request submitted.\n";
    print "The grid-mapfile(s) should be updated in a few minutes\n";
}

########################################################################

#
# Given a filename, invokes openssl to determine the subject name and
# returns the resulting DN.
# 
# The output must be a single line starting with '/'; otherwise,
# returns undef.
#
# Note that we do *not* call Use_Commands 'openssl' here; we depend
# on the "openssl" command being in the user's $PATH.
# 
sub Get_DN_From_File($) {
    my($file) = @_;
    return undef if not -r $file;
    open PIPE, "openssl x509 -in '$file' -noout -subject |";
    my @output = <PIPE>;
    close PIPE;

    return undef if scalar @output != 1;
    my $line = $output[0];
    chomp $line;
    $line =~ s/^subject=\s*//;
    return undef if $line !~ /^\//;
    return $line;
} # Get_DN_From_File

# ----------------------------------------------------------------------

sub Gen_Request_File_Name() {
    my $result = "$Requests_Dir/";
    $result .= sprintf "%010s", $Now;
    $result .= "-$hostname-$PW->{name}";
    if (defined $Options->{username} and
        $Options->{username} ne $PW->{name})
    {
        $result .= "_$Options->{username}";
    }
    $result .= "-$$.request";
    return $result;
} # Gen_Request_File_Name

# ----------------------------------------------------------------------

sub Is_Valid_DN($) {
    my($DN) = @_;
    return $DN =~ m<^(/[^/=]+=[^=]+)+$>;
} # Is_Valid_DN

# ----------------------------------------------------------------------

#
# Request an update of the grid-mapfiles.
# Append a line of information to the requests/.update file.
# gx-gen-mapfile will check the timestamp of this file; if it's
# later than any of its output files, it will re-generate them.
#
sub Request_Update() {
    my $request_file = "$Requests_Dir/.update";
    my $PW = Gridmap_Utils::Get_PW $<;
    my $hostname = Gridmap_Utils::Get_Hostname();
    my $timestamp = Gridmap_Utils::Time_Image $Now;
    my $info = "Update requested by $PW->{name} on $hostname at $timestamp\n";

    open FILE, ">>$request_file" or die "$request_file: $!\n";
    print FILE $info;
    close FILE;
    if (not $Options->{quiet}) {
        print "Request processed.\n";
        print "The grid-mapfiles should be updated within a few minutes.\n";
    }
} # Request_Update

# ----------------------------------------------------------------------

#
# For use with here documents (<<"EOF")
#
sub Strip($) {
    my($s) = @_;

    $s =~ s/^\s*> ?//gm;
    return $s;
} # Strip

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $User_Opt->{debugging};
} # Debugf

# ----------------------------------------------------------------------

sub Get_Options_Interactively() {
    $| = 1;

    my $Options = {};

    my $response;

    $Options->{interactive} = 1;

    print Strip <<"EOF";
    > The $Prog_Name command lets you submit a request to modify the
    > Globus grid-mapfiles on several machines.  Once the request is
    > submitted, the updates should occur within a few minutes.
    > 
    > A grid-mapfile entry maps a DN (Distinguished Name) to a Unix
    > user name.  For example, an entry like
    >     "/O=Grid/O=Big University/OU=Small Department/CN=John Doe" jdoe
    > allows a user holding a Globus certificate with the specified
    > DN to run Globus jobs under the Unix account "jdoe".
    > 
    > $Prog_Name can be run interactively or with command-line arguments.
    > 
    > In this interactive mode, you will be asked a series of questions.
    > Enter your responses followed by <return>.
    > 
    > Single-letter menu responses are case-insensitive; other responses
    > must be entered exactly.
    > 
    > If there is a default response indicated by the prompt, you can
    > enter it by just typing <return>.
EOF

    #
    # Get the operation
    #
    while (not defined $Options->{operation}) {
        print Strip <<"EOF";
        > 
        > (a) Add a grid-mapfile entry
        > (r) Remove a grid-mapfile entry
        > (u) Request an update of the grid-mapfiles
        > (x) Exit
EOF
        print "What do you want to do? [arux] ";
        chomp($response = lc scalar <STDIN>);
        if ($response =~ /^a/) {
            $Options->{operation} = 'add';
        }
        elsif ($response =~ /^r/) {
            $Options->{operation} = 'remove';
        }
        elsif ($response =~ /^u/) {
            $Options->{operation} = 'update';
        }
        elsif ($response =~ /^x/) {
            exit 0;
        }
        else {
            print ">>> Unrecognized response\n";
        }
    }

    my $OP = $Options->{operation}; # just a convenient abbreviation

    if ($Globus_Admin) {
        while (not defined $Options->{directory}) {
            print "Data directory (default is $Default_Data_Dir): ";
            chomp($response = scalar <STDIN>);
            if ($response eq '') {
                $Options->{directory} = $Default_Data_Dir;
            }
            elsif (not -e $response) {
                print ">>> $response does not exist\n";
            }
            elsif (not -d _) {
                print ">>> $response is not a directory\n";
            }
            elsif (not -r $response or not -x _ or not -w _) {
                print ">>> Insufficient access to directory $response\n";
            }
            else {
                $Options->{directory} = $response;
            }
        }
    }
    else {
        $Options->{directory} = $Default_Data_Dir;
    }

    if ($OP eq 'remove') {
        TRY:
        while (1) {
            print "\n";
            if ($Globus_Admin) {
                print Strip <<"EOF";
                > (d) Remove all mappings for a specified DN
                > (u) Remove all mappings for a specified user name
                > (m) Remove mapping for a specified DN and user name
                > (x) Exit
EOF
                print "Remove? [dumx] ";
            }
            else {
                print Strip <<"EOF";
                > (u) Remove all mappings for your user name
                > (m) Remove mapping for a specified DN and your user name
                > (x) Exit
EOF
                print "Remove? [umx] ";
            }
            chomp($response = lc scalar <STDIN>);
            if ($Globus_Admin and $response =~ /^d/) {
                $OP = $Options->{operation} = 'remove-dn';
                last TRY;
            }
            elsif ($response =~ /^u/) {
                $OP = $Options->{operation} = 'remove-user';
                last TRY;
            }
            elsif ($response =~ /^m/) {
                $OP = $Options->{operation} = 'remove';
                last TRY;
            }
            elsif ($response =~ /^x/) {
                exit 0;
            }
            else {
                print ">>> Unrecognized response\n";
            }
        }
    }

    #
    # For update, no further information is needed, but ask the
    # user whether that's really what he wants to do.
    #
    if ($Options->{operation} eq 'update') {
        print Strip <<"EOF";
        > 
        > This will request an immediate update of all grid-mapfiles.
        > Normally updates are handled automatically, so this is not
        > usually necessary.  The only case where this is necessary
        > is when you get a new Unix account when you already have a
        > grid-mapfile entry.
        > 
EOF
        while (1) {
            print "Proceed? [yn] ";
            $response = lc scalar <STDIN>;
            if ($response =~ /^y/) {
                return $Options;
            }
            elsif ($response =~ /^n/) {
                exit 0;
            }
            else {
                print ">>> Unrecognized response\n";
            }
        }
    }

    #
    # For other operations, collect more information.
    #
    else {
        my $what;
        if    ($OP eq 'add')     { $what = 'map' }
        elsif ($OP =~ /^remove/) { $what = 'unmap' }
        else                     { die "Internal error" }

        #
        # Get user name if needed
        #
        my $need_user_name = undef;
        if ($Globus_Admin and $OP ne 'remove-dn') {
            $need_user_name = 1;
        }
        else {
            $Options->{username} = $PW->{name};
        }

        if ($need_user_name) {
            while (not defined $Options->{username}) {
                if ($PW->{name} eq 'root') {
                    print "What user name do you want to $what? ";
                }
                else {
                    print "What user name do you want to $what ",
                          "(default is $PW->{name}) ? ";
                }
                chomp($response = scalar <STDIN>);
                $response =~ s/^ *//;
                $response =~ s/ *$//;
                if ($response eq '') {
                    if ($PW->{name} ne 'root') {
                        $Options->{username} = $PW->{name};
                    }
                }
                else {
                    $Options->{username} = $response;
                }
            }
        }
        else {
            $Options->{username} = $PW->{name};
        }

        #
        # Get DN or certificate file name
        #
        if ($OP =~ /-user$/) {
            $Options->{'dn-method'} = 'none';
        }
        else {
            while (not defined $Options->{'dn-method'}) {
                print Strip <<"EOF";
                > 
                > You can specify the DN in one of three ways:
                > (c) Certificate, extract from
                >         \$HOME/.globus/usercert.pem
                > (f) File, extract from a specified certificate file
                > (i) Input the DN directly
                > (x) Exit
EOF
                print "How do you want to specify the DN? [cfix] ";
                chomp($response = lc scalar <STDIN>);

                if ($response =~ /^c/) {
                    $Options->{'dn-method'} = 'file';
                    $Options->{'certificate-file'}
                        = "$ENV{HOME}/.globus/usercert.pem";
                }
                elsif ($response =~ /^f/) {
                    $Options->{'dn-method'} = 'file';
                }
                elsif ($response =~ /^i/) {
                    $Options->{'dn-method'} = 'dn';
                }
                elsif ($response =~ /^x/) {
                    exit 0;
                }
                else {
                    print ">>> Unrecognized input\n";
                }
            }

            if ($Options->{'dn-method'} eq 'file') {
                if (not defined $Options->{'certificate-file'}) {
                    print "Enter certificate file name: ";
                    chomp($Options->{'certificate-file'} = scalar <STDIN>);
                }
            }
            else {
                print "Enter distinguished name: ";
                chomp($Options->{dn} = scalar <STDIN>);
                $Options->{dn} =~ s/^"//;
                $Options->{dn} =~ s/"$//;
            }
        }

        #
        # Is this a secondary mapping?
        #
        if ($OP eq 'add') {
            while (not defined $Options->{secondary}) {
                print "Is this a secondary mapping ('h' for help)? [nyxh] ";
                chomp($response = lc scalar <STDIN>);

                if ($response =~ /^y/) {
                    $Options->{secondary} = 'yes';
                }
                elsif ($response =~ /^n/ or $response eq '') {
                    $Options->{secondary} = 'no';
                }
                elsif ($response =~ /^h/) {
                    print Strip <<"EOF";
                    >
                    > A DN may be mapped to more than one user name.
                    > Most Globus applications don't make use of this;
                    > they map the DN to the first listed user name.
                    >
                    > A primary mapping (the default) will be listed first,
                    > and will override any previous primary mappings.
                    >
                    > A secondary mapping may or may not not be listed first;
                    > multiple secondary mappings may be requested for a given
                    > DN.
                    >
                    > If you're confused, just type <return>.
                    >
EOF
                }
                elsif ($response =~ /^x/) {
                    exit 0;
                }
                else {
                    print ">>> Unrecognized input\n";
                }
            }
        }


        #
        # Get e-mail address
        #
        print Strip <<"EOF";
        > 
        > You are encouraged to provide your e-mail address.
        > It will be recorded in the request log, and may be used
        > to contact you if there is a problem with your certificate.
        > It will not be added to a mailing list without your consent.
EOF
        print "E-mail address (<return> for none): ";
        chomp($response = scalar <STDIN>);
        $response =~ s/^\s*//;
        $response =~ s/\s*$//;
        if ($response ne '') {
            $Options->{email} = $response;
        }

        #
        # Get comment
        #
        print Strip <<"EOF";
        > 
        > You may provide an optional comment.
        > If you do, it will be recorded in the request log.
        > Press return if you don't wish to provide a comment.
EOF
        print "Comment: ";
        chomp($response = scalar <STDIN>);
        $response =~ s/^\s*//;
        $response =~ s/\s*$//;
        if ($response ne '') {
            $Options->{comment} = $response;
        }
    }
    print "\n";

    return $Options;
} # Get_Options_Interactively

# ----------------------------------------------------------------------

sub Get_Options_From_Command_Line() {
    my $Options = {};

    my @operations = ();
    foreach my $op (qw(add remove remove-dn remove-user update))
    {
        push @operations, $op if $User_Opt->{$op};
    }

    if (scalar @operations == 0) {
        Usage "No operation specified\n";
    }
    elsif (scalar @operations == 1) {
        $Options->{operation} = $operations[0];
    }
    else {
        Usage "Specify only one of:\n",
              "    -add,\n",
              "    -remove, -remove-dn, -remove-user,\n",
              "    -update\n";
    }

    my $OP = $Options->{operation}; # just a convenient abbreviation

    if ($OP =~ /-dn$/ and defined $User_Opt->{username}) {
        Usage "Do not specify a user name with \"-$Options->{operation}\"\n";
    }
    elsif ($OP =~ /-user$/ and
           ( defined $User_Opt->{dn} or
             defined $User_Opt->{'certificate-file'} ))
    {
        Usage "Do not specify a DN or certificate file with \"$OP\"\n";
    }

    $Options->{'force-dn'} = 1 if $User_Opt->{'force-dn'};
    $Options->{quiet}      = 1 if $User_Opt->{quiet};
    $Options->{force}      = 1 if $User_Opt->{quiet} or $User_Opt->{force};

    if (defined $User_Opt->{directory}) {
        if ($Globus_Admin) {
            $Options->{directory} = $User_Opt->{directory};
        }
        else {
            Usage "Only a Globus administrator may specify a data directory\n"
        }
    }
    else {
        $Options->{directory} = $Default_Data_Dir;
    }

    if ($OP eq 'update') {
        return $Options;
    }

    if ($OP eq 'remove-dn' and not $Globus_Admin) {
        Usage "Only a Globus administrator may use the \"-remove-dn\" option\n";
    }

    if (defined $User_Opt->{username}) {
        if ($OP =~ /-dn$/) {
            Usage "Do not specify a user name ",
                  "with \"-$OP\"\n";
        }
        elsif (not $Globus_Admin and $User_Opt->{username} ne $PW->{name}) {
            Usage "You may not specify a user name other than your own\n";
        }
        $Options->{username} = $User_Opt->{username};
    }
    else {
        if ($OP !~ /-dn$/) {
            $Options->{username} = $PW->{name};
        }
    }

    if (defined $User_Opt->{dn}) {
        if (defined $User_Opt->{'certificate-file'}) {
            Usage "Can't specify both DN and certificate file\n"
        }
        else {
            $Options->{'dn-method'} = 'dn';
            $Options->{dn} = $User_Opt->{dn};
        }
    }
    else {
        if (defined $User_Opt->{'certificate-file'}) {
            $Options->{'dn-method'} = 'file';
            $Options->{'certificate-file'} = $User_Opt->{'certificate-file'};
        }
        else {
            if ($OP =~ /-user$/) {
                $Options->{'dn-method'} = 'none';
            }
            else {
                $Options->{'dn-method'} = 'file';
                $Options->{'certificate-file'}
                    = "$ENV{HOME}/.globus/usercert.pem";
            }
        }
    }

    if (defined $User_Opt->{secondary}) {
        if ($OP eq 'add') {
            $Options->{secondary} = 'yes';
        }
        else {
            Usage "The \"-secondary\" option may only be used with " .
                  "an \"add\" request\n";
        }
    }

    if (not defined $User_Opt->{email} and
        not defined $User_Opt->{'no-email'})
    {
        Usage "Please provide an e-mail address or specify \"-no-email\"\n";
    }
    elsif (defined $User_Opt->{email}) {
        $Options->{email} = $User_Opt->{email};
    }

    if (defined $User_Opt->{comment}) {
        $Options->{comment} = $User_Opt->{comment};
    }
    
    return $Options;
} # Get_Options_From_Command_Line

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Prog_Name [options]
Option names may be abbreviated.
    -help         : Show this message and exit.
    -long-help    : Show long usage message (recommended only for
                    Globus administrators and masochists)
    -interactive  : Run interactively (recommended)
                    In interactive mode, other options will be ignored.
EOF
    exit 1;
} # Usage

# ----------------------------------------------------------------------

sub Long_Usage() {
    my $pager = defined $ENV{PAGER} ? $ENV{PAGER} : 'more';
    print <<"EOF";
Usage: $Prog_Name [options]
Option names may be abbreviated.
    -help                   : Show a brief usage message and exit.
    -version                : Show version information and exit.
    -interactive            : Run interactively (recommended).
    -long-help              : Show this long usage message (recommended
                              only for Globus administrators and masochists).
    -add                    : Add the specified mapping.
    -remove                 : Remove the specified mapping.
    -remove-dn              : Remove all mappings for the specified
                              distinguished name.  For use only by Globus
                              administrators.
    -remove-user            : Remove all mappings for the specified user.
    -update                 : Request an update of all grid-mapfiles.
                              This normally isn't necessary, but it can be
                              useful if you already have a certificate and
                              get a new account on a machine.
Note: Exactly one of "-interactive", "-add", "-remove", "-remove-dn",
      "-remove-user", and "-update"
      (or "-help", "-usage", or -long-usage) must be specified.
------------------------------------------------------------------------
    -quiet                  : Work silently.
                              Implies -force.
    -force                  : Apply mapping without prompting.
                              Default is to ask for verification before
                              proceeding.
    -no-admin               : Assume the user is not a Globus administrator.
                              Intended for testing only; has no effect if
                              you're not already a Globus administrator.
    -dn "string"            : Distinguished name.
                              Default is extracted from ~/.globus/usercert.pem
    -certificate-file file  : Name of file from which to extract DN.
                              If neither "-dn" nor "-certificate-file" is
                              specified, extract DN from
                              \$HOME/.globus/usercert.pem
    -force-dn               : Normally, gx-map (minimally) checks the DN for
                              proper syntax; this option overrides that check.
    -username name          : Unix user name to map.
                              This option is for use by Globus
                              administrators only.
    -secondary              : Request a secondary mapping.
                              See the documentation (not yet written) for
                              details.
    -directory dir          : Specify an alternate data directory.
                              This option is for use by Globus administrators
                              only.
                              The default data directory is
                              $Default_Data_Dir .
    -email addr             : Your contact e-mail address.
                              This may be used to contact you if there's
                              a problem with your certificate.  If you
                              prefer not to submit your e-mail address,
                              you can use "-no-email".
    -no-email               : Don't submit an e-mail address.
    -comment "string"       : Comment to be added to request log (optional)
    -debugging              : Enable debugging output.
Note: If this help message has scrolled off the top of your screen, try
    $Prog_Name -long-help | $pager
EOF
    exit 1;
} # Long_Usage
