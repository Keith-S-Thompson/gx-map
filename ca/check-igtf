#!/usr/bin/perl

# $Id: check-igtf,v 1.8 2007-06-12 19:44:02-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/ca/check-igtf,v $

use strict;
use warnings;

sub Set_cadesc_Info($);
sub Set_Cert_Info($);
sub Set_igtf_Info($);
sub Check_Consistency($);
sub All_Equal(@);
sub Status_Image($);

sub Usage(@);

my $hash_pattern = qr([\da-f]{8});

my %hash_requested = ();
my $all_requested = 0;

foreach my $arg (@ARGV) {
    if ($arg =~ /^$hash_pattern$/) {
        $hash_requested{$arg} = 1;
    }
    elsif ($arg eq '-all') {
        $all_requested = 1;
    }
    else {
        Usage "Unrecognized argument $arg\n";
    }
}
if (scalar keys %hash_requested == 0 and not $all_requested) {
    Usage "No hashes requested\n";
}

# print ">>> Hashes requested: ";
# if ($all_requested) {
#     print "ALL\n";
# }
# else {
#     print join(' ', sort keys %hash_requested), "\n";
# }

my $ca_dir = "$ENV{HOME}/cvs-kst/tools/gx-map/ca";
# my $igtf_dir = "$ca_dir/.igtf-1.14-all";
my $igtf_dir = "$ca_dir/.igtf-1.14/igtf-policy-installation-bundle-1.14/src";

die "No file $ca_dir\n"   if not -d $ca_dir;
die "No file $igtf_dir\n" if not -d $igtf_dir;

opendir my $IGTF, $igtf_dir or die "$igtf_dir: $!\n";
my @igtf_subdirs = sort grep !/^\./, readdir $IGTF;
closedir $IGTF;

my $cadesc_info = {};

opendir my $CA_DIR, $ca_dir or die "$ca_dir: $!\n";
my @files = sort grep { /\.cadesc$/ and not /^00000000/ } readdir $CA_DIR;
closedir $CA_DIR;

foreach my $file (@files) {
    my $hash = $file;
    $hash =~ s/\..*$//;
    if ($all_requested or $hash_requested{$hash}) {
        # print ">>> Getting info for $hash\n";
        die "Bad hash $hash, file $file\n" if $hash !~ /^$hash_pattern$/;
        $cadesc_info->{$hash}->{HASH} = $hash;
        $cadesc_info->{$hash}->{CADESC_FILENAME} = "$ca_dir/$file";
        Set_cadesc_Info   $cadesc_info->{$hash};
        Set_Cert_Info     $cadesc_info->{$hash};
        Set_igtf_Info     $cadesc_info->{$hash};
        Check_Consistency $cadesc_info->{$hash};
    }
}

foreach my $hash (sort keys %$cadesc_info) {
    print "$hash {\n";
    my $ref = $cadesc_info->{$hash};
    foreach my $key (sort keys %$ref) {
        if (ref $ref->{$key} eq 'ARRAY') {
            my @arr = @{$ref->{$key}};
            foreach my $elem (@arr) {
                printf "    %-20s => %s\n", $key, $elem;
            }
        }
        elsif (ref $ref->{$key} eq 'HASH') {
            printf "    %-20s => {\n", $key;
            foreach my $subkey (sort keys %{$ref->{$key}}) {
                next if $subkey eq '_status';
                my $status = $ref->{$key}->{_status}->{$subkey};
                $status = '' if not defined $status;
                if (ref $ref->{$key}->{$subkey} eq 'ARRAY') {
#                   printf "%6s  %-20s => [\n",
#                          $status, $subkey;
                    printf "%-8s%-20s => [\n",
                           $status, $subkey;
                    foreach my $elem (@{$ref->{$key}->{$subkey}}) {
                        printf "%12s%s\n", '', $elem;
                    }
                    printf "%8s%s\n", '', ']';
                }
                else {
#                   printf "%6s  %-20s => %s\n",
#                          $status, $subkey, $ref->{$key}->{$subkey};
                    printf "%-8s%-20s => %s\n",
                           $status, $subkey, $ref->{$key}->{$subkey};
                }
            }
            print "    }\n";
        }
        else {
            printf "    %-20s => %s\n", $key, $ref->{$key};
        }
    }
    print "}\n\n";
}

########################################################################

sub Set_cadesc_Info($) {
    my($ref) = @_;

    my $filename = $ref->{CADESC_FILENAME};
    my $CADESC = undef;
    if (not open $CADESC, '<', $filename) {
        push @{$ref->{ERROR}}, "${filename}: $!\n";
        return;
    }
    while (<$CADESC>) {
        s/#.*$//;
        s/^\s+//;
        s/\s+$//;
        next if /^$/;
        if (/^(\w+)\s+(.*)$/) {
            my($key, $value) = ($1, $2);
            if (defined $ref->{cadesc}->{$key}) {
                if (ref $ref->{cadesc}->{$key} ne 'ARRAY') {
                    $ref->{cadesc}->{$key} = [ $ref->{cadesc}->{$key} ];
                }
                push @{$ref->{cadesc}->{$key}}, $value;
            }
            else {
                $ref->{cadesc}->{$key} = $value;
            }
        }
        else {
            die "${filename}:$.: Syntax error\n";
        }
    }
    close $CADESC;
} # Set_cadesc_Info

# ----------------------------------------------------------------------

sub Set_Cert_Info($) {
    my($ref) = @_;
    my $certificate_url = $ref->{cadesc}->{CERTIFICATE_URL};
    my $crl_url = $ref->{cadesc}->{CRL_URL};
    my $command = 'cert-info';
    if (defined $certificate_url) {
        $command .= " '$certificate_url'";
    }
    if (defined $crl_url and $crl_url ne '?') {
        $command .= " '$crl_url'";
    }

    my $section = 'certificate'; # 'certificate' or 'crl'

    my $PIPE = undef;
    if (not open $PIPE, "$command 2>/dev/null |") {
        push @{$ref->{ERROR}}, "${command}: $!";
        return;
    }
    while (<$PIPE>) {
        if (/^$/) {
            $section = 'crl';
        }
        elsif (/^File type\s+(.*)$/) {
            $ref->{$section}->{file_type} = $1;
        }
        elsif (/^hash\s+($hash_pattern)$/) {
            $ref->{$section}->{hash} = $1;
        }
        elsif (/^md5 fingerprint\s+(.*)$/) {
            $ref->{$section}->{md5} = $1;
        }
        elsif (/^sha1 fingerprint\s+(.*)$/) {
            $ref->{$section}->{sha1} = $1;
        }
        elsif (/^issuer\s+(.*)$/) {
            $ref->{$section}->{issuer} = $1;
        }
        elsif (/^subject\s+(.*)$/) {
            $ref->{$section}->{subject} = $1;
        }
        elsif (/^not before\s+(.*)$/) {
            $ref->{$section}->{not_before} = $1;
        }
        elsif (/^not after\s+(.*)$/) {
            $ref->{$section}->{not_after} = $1;
        }
        elsif (/^verification\s+(.*)$/) {
            $ref->{$section}->{verification} = $1;
        }
    }
    close $PIPE;
    if ($?) {
        push @{$ref->{ERROR}}, ("openssl: " . Status_Image $?);
    }
} # Set_Cert_Info

# ----------------------------------------------------------------------

sub Set_igtf_Info($) {
    my($ref) = @_;

    my $filename = undef;

    foreach my $subdir (@igtf_subdirs) {
        if (-e "$igtf_dir/$subdir/$ref->{HASH}.info") {
            $filename = "$igtf_dir/$subdir/$ref->{HASH}.info";
            last;
        }
    }
    if (not defined $filename) {
        push @{$ref->{ERROR}}, "No file $filename";
        return;
    }

    my $INFO = undef;
    if (not open $INFO, '<', $filename) {
        push @{$ref->{ERROR}}, "${filename}: $!";
        return;
    }
    while (<$INFO>) {
        s/#.*$//;
        s/^\s+//;
        s/\s+$//;
        next if /^$/;
        if (/^([\w.]+)\s+=\s+(.*)$/) {
            $ref->{igtf}->{$1} = $2;
        }
        else {
            die "${filename}:$.: Syntax error\n";
        }
    }
    close $INFO;
    $ref->{IGTF_FILENAME} = $filename;
} # Set_igtf_Info

# ----------------------------------------------------------------------

sub Check_Consistency($) {
    my($ref) = @_;

    #
    # Check hash
    #
    {
        my @list = ();
        foreach my $item ( $ref->{cadesc}->{HASH},
                           $ref->{certificate}->{hash},
                           $ref->{crl}->{hash} )
        {
            push @list, $item if defined $item;
        }
        my $status = All_Equal(@list) ? 'ok' : 'ERR';
        $ref->{cadesc}->{_status}->{HASH} =
        $ref->{crl}->{_status}->{hash} =
        $ref->{certificate}->{_status}->{hash} = $status;
        if ($status ne 'ok') {
            push @{$ref->{ERROR}}, "HASH mismatch";
        }
    }

    #
    # Check SHA1 fingerprint
    #
    {
        my @list = ();
        foreach my $item ($ref->{cadesc}->{CERTIFICATE_SHA1},
                          $ref->{igtf}->{'sha1fp.0'},
                          $ref->{certificate}->{sha1})
        {
            push @list, $item if defined $item;
        }
        my $status = All_Equal(@list) ? 'ok' : 'ERR';
        $ref->{cadesc}->{_status}->{CERTIFICATE_SHA1} =
        $ref->{igtf}->{_status}->{'sha1fp.0'} =
        $ref->{certificate}->{_status}->{sha1} = $status;
        if ($status ne 'ok') {
            push @{$ref->{'ERROR'}}, "SHA1 mismatch";
        }
    }

    #
    # Check MD5 fingerprint
    #
    {
        my @list = ();
        foreach my $item ($ref->{cadesc}->{CERTIFICATE_MD5},
                          $ref->{certificate}->{md5})
        {
            push @list, $item if defined $item;
        }
        my $status = All_Equal(@list) ? 'ok' : 'ERR';
        $ref->{cadesc}->{_status}->{CERTIFICATE_MD5} =
        $ref->{certificate}->{_status}->{md5} = $status;
        if ($status ne 'ok') {
            push @{$ref->{'ERROR'}}, "MD5 mismatch";
        }
    }

    #
    # Check CRL URL
    #
    {
        my @list = ();
        foreach my $item ($ref->{cadesc}->{CRL_URL},
                          $ref->{igtf}->{crl_url})
        {
            push @list, $item if defined $item;

        }
        my $status = All_Equal(@list) ? 'ok' : 'ERR';
        $ref->{cadesc}->{_status}->{CRL_URL} =
        $ref->{igtf}->{_status}->{crl_url} = $status;
        if ($status ne 'ok') {
            push @{$ref->{'ERROR'}}, "CRL_URL mismatch";
        }
    }

    #
    # Check HOMEPAGE / url
    #
    {
        my @list = ();
        foreach my $item ($ref->{cadesc}->{HOMEPAGE},
                          $ref->{igtf}->{url})
        {
            push @list, $item if defined $item;
        }
        my $status = All_Equal(@list) ? 'ok' : 'ERR';
        $ref->{cadesc}->{_status}->{HOMEPAGE} =
        $ref->{igtf}->{_status}->{url} = $status;
        if ($status ne 'ok') {
            push @{$ref->{'ERROR'}}, "HOMEPAGE / url mismatch";
        }
    }

    #
    # Check CERT_BEGINS / not_before
    #
    {
        my @list = ();
        foreach my $item ($ref->{cadesc}->{CERT_BEGINS},
                          $ref->{certificate}->{not_before})
        {
            push @list, $item if defined $item;
        }
        my $status = All_Equal(@list) ? 'ok' : 'ERR';
        $ref->{cadesc}->{_status}->{CERT_BEGINS} =
        $ref->{certificate}->{_status}->{not_before} = $status;
        if ($status ne 'ok') {
            push @{$ref->{'ERROR'}}, "CERT_BEGINS / not_before mismatch";
        }
    }

    #
    # Check CERT_EXPIRES / not_after
    #
    {
        my @list = ();
        foreach my $item ($ref->{cadesc}->{CERT_EXPIRES},
                          $ref->{certificate}->{not_after})
        {
            push @list, $item if defined $item;
        }
        my $status = All_Equal(@list) ? 'ok' : 'ERR';
        $ref->{cadesc}->{_status}->{CERT_EXPIRES} =
        $ref->{certificate}->{_status}->{not_after} = $status;
        if ($status ne 'ok') {
            push @{$ref->{'ERROR'}}, "CERT_EXPIRES / not_after mismatch";
        }
    }

} # Check_Consistency

# ----------------------------------------------------------------------

sub All_Equal(@) {
    my(@list) = @_;
    for (my $i = 0; $i < $#list; $i ++) {
        if ($list[$i] ne $list[$i+1]) {
            return 0;
        }
    }
    return 1;
} # All_Equal

# ----------------------------------------------------------------------

#
# Legible image of $?
#
sub Status_Image($) {
    my($status) = @_;
    my @list = ();
    my $signal = $? & 0x7f;
    my $coredumped = $? & 0x80;
    my $exit_status = $? >> 8;
    if ($signal != 0) {
        push @list, "Signal $signal";
    }
    if ($coredumped) {
        push @list, "core dumped";
    }
    if ($exit_status != 0) {
        push @list, "Exit $exit_status";
    }
    if (not @list) {
        push @list, "Exit 0";
    }
    return join(", ", @list);
} # Status_Image

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $0 [arguments]
    -all        Show all 
    xxxxxxxx    An 8-digit hexadecimal hash
EOF
    exit 0;
} # Usage
