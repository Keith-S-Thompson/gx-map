#!%PERL% -wT

# $Id: gx-check-requests.in,v 1.61 2005-11-15 17:43:17-08 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-check-requests.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2005 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use File::Copy ();
use Getopt::Long ();

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

sub Usage(@);
sub Get_Request_Info($);
sub Append_To_Log($@);
sub Debug(@);
sub Debugf(@);

my $Program_Name = File::Basename::basename $0;

my $Now = time;

my $Hostname = Gridmap_Utils::Get_Hostname;
my $Default_Data_Dir = "$Install_Dir/var";

my $User_Opt = { namespace => $Gridmap_Utils::Config{NAMESPACE} };
my @Opts = ( $User_Opt,
             qw( help
                 version
                 namespace=s
                 copy=s
                 dryrun
                 debugging ) );
             # directory=s
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;

if ($User_Opt->{version}) {
    print "$Program_Name (gx-map) $Gridmap_Utils::VERSION\n";
    exit 0;
}

#
# This program may only be executed by the GX_MAP_OWNER.
#
Gridmap_Utils::Require_Owner $Program_Name;

# Usage "No -namespace option given\n" if not defined $User_Opt->{namespace};
$Gridmap_Utils::Debugging = 1 if $User_Opt->{debugging};

Gridmap_Utils::Install_Die_Handler;
Gridmap_Utils::Install_Warn_Handler;

# my $Data_Dir = defined $User_Opt->{directory}
#                      ? $User_Opt->{directory}
#                      : $Default_Data_Dir;
my $Data_Dir = $Default_Data_Dir;
Gridmap_Utils::Untaint $Data_Dir;
if ($Data_Dir !~ /^\//) {
    die "Data directory $Data_Dir is not an absolute pathname\n";
}
my $requests_log     = "$Data_Dir/requests.log";
my $errors_log       = "$Data_Dir/errors.log";
my $new_request_dir  = "$Data_Dir/new-requests";
my $good_request_dir = "$Data_Dir/good-requests";
my $bad_request_dir  = "$Data_Dir/bad-requests";
my $lock_file        = "$Data_Dir/.gx-check-requests.lock";

my $dir_error = Gridmap_Utils::Dir_Error $new_request_dir;
die "$dir_error\n" if defined $dir_error;
die "No directory $new_request_dir\n" if not -d $new_request_dir;
if (not -d $good_request_dir) {
    mkdir $good_request_dir, 0700 or die "mkdir $good_request_dir: $!\n";
}
if (not -d $bad_request_dir) {
    mkdir $bad_request_dir, 0700 or die "mkdir $bad_request_dir: $!\n";
}

if (-e $lock_file) {
    my $lock_time = Gridmap_Utils::Get_mtime $lock_file;
    my $delta = $Now - $lock_time;
    die "Locked since ",
        Gridmap_Utils::Time_Image $lock_time,
        " ($delta second(s))\n";
}
open my $Lock, '>', $lock_file;
close $Lock;

my @required_keys = qw( operation timestamp requested_by_name
                        requested_by_uid hostname );
my @valid_keys = ( @required_keys,
                   qw( dn username email comment
                       user_uid source ) );
my @valid_operations = qw( add remove remove-dn remove-user );
my %is_required_key    = map { $_ => 1 } @required_keys;
my %is_valid_key       = map { $_ => 1 } @valid_keys;
my %is_valid_operation = map { $_ => 1 } @valid_operations;

opendir my $Dir, $new_request_dir or die "$new_request_dir: $!\n";
my @files = grep /\.request$/, sort readdir $Dir;
closedir $Dir;

foreach my $file (@files) {
    Gridmap_Utils::Untaint $file;
}

my @good_requests = ();
my @good_request_files = ();
my @bad_requests = ();
my @bad_request_files = ();

foreach my $file (@files) {
    my $request = Get_Request_Info "$new_request_dir/$file";
    if (defined $request->{ERRORS}) {
        push @bad_requests, $request;
        push @bad_request_files, $file;
    }
    else {
        push @good_requests, $request;
        push @good_request_files, $file;
    }
}

if (not @good_requests and not @bad_requests) {
    #
    # No requests seen.  Bail out.
    #
    unlink $lock_file;
    exit;
}

$ENV{PATH} = $Gridmap_Utils::Config{PATH};

#
# We need to invoke gx-propagate *before* appending the good requests
# to the requests.log file, because gx-propagate sometimes needs to
# see the existing requests.
#
# Annotate any propagated requests with a PROPAGATION attribute,
# set to 'ok' if it appears to have succeeded, 'failed' if it failed,
# or 'dryrun' if the "-dryrun" option was specified).
#
my $propagate = "$Install_Dir/sbin/gx-propagate";
my @propagation_failures = ();
if (-x $propagate) {
    foreach my $request (@good_requests) {
        my $dn = $request->{dn};
        if (defined $dn) {
            $dn =~ s/^"//;
            $dn =~ s/"$//;
        }
        my @args = ();
        push @args, '-debugging' if $User_Opt->{debugging};
        push @args, '-dryrun'    if $User_Opt->{dryrun};
        push @args, '-source', $request->{SOURCE};
        push @args, "-$request->{operation}";
        if ($request->{operation} ne 'remove-dn') {
            push @args, '-username', $request->{username};
        }
        if ($request->{operation} ne 'remove-user') {
            push @args, '-dn', $dn;
        }
        Debug "$propagate @args\n";
        my $result = system $propagate, @args;
        Debug "\$result = $result\n";
        if ($User_Opt->{dryrun}) {
            $request->{PROPAGATION} = 'dryrun';
        }
        elsif ($result == 0) {
            $request->{PROPAGATION} = 'ok';
        }
        else {
            $request->{PROPAGATION} = 'failed';
            push @propagation_failures, $request;
        }
    }
}
if (@propagation_failures) {
    my $count = scalar @propagation_failures;
    my $recipient = $Gridmap_Utils::Config{ADMIN_EMAIL};
    my $subject = ($count == 1 ? "gx-propagate: 1 failure"
                               : "gx-propagate: $count failures");
    my $body = "$propagate\n" .
               "failed on the following " .
               ($count == 1 ? "request" : "requests") .
               ":\n\n";

    foreach my $request (@propagation_failures) {
        foreach my $field (sort keys %$request) {
            $body .= sprintf "    %-20s %s\n",
                             $field,
                             $request->{$field};
        }
        $body .= "\n";
    }

    $body .= "Please check the logs in the directory\n" .
             "$Install_Dir/var\n";
    $body .= "You may need to resubmit " .
             ($count == 1 ? "this request" : "these requests") .
             "\n";

    Gridmap_Utils::Send_Email $recipient, $subject, $body;
}

#
# We have one or more new requests to process.  Append them to the
# requests log and/or the errors log.
#

if (not -d "$Data_Dir/RCS") {
    mkdir "$Data_Dir/RCS", 0700 or die "mkdir $Data_Dir/RCS: $!\n";
}

Append_To_Log $errors_log,   @bad_requests;
Append_To_Log $requests_log, @good_requests;

if (defined $User_Opt->{copy}) {
    Gridmap_Utils::Untaint $User_Opt->{copy};
    Gridmap_Utils::Untaint $requests_log;
    my $target_file = $User_Opt->{copy};
    my $tmp_file = $User_Opt->{copy} . ".new";

    File::Copy::copy $requests_log, $tmp_file;
    rename $tmp_file, $target_file;
    chmod 0444, $target_file;
}

#
# Now that the records have been safely appended to the log and
# checked into RCS, move the individual request files into appropriate
# subdirectories.
#
my @rename_errors = ();
foreach my $file (@good_request_files) {
    rename "$new_request_dir/$file", "$good_request_dir/$file"
        or push @rename_errors, "${file}: $!\n";
}
foreach my $file (@bad_request_files) {
    rename "$new_request_dir/$file", "$bad_request_dir/$file"
        or push @rename_errors, "${file}: $!\n";
}

if (@rename_errors) {
    print STDERR "Error(s) moving request files:\n",
                 @rename_errors;
}

unlink $lock_file;

########################################################################

#
# Given the name of a request file, returns a reference to the information
# from the file.  If any error occurs, the information will include an
# "ERRORS" field, a reference to an array of error messages.
#
# We use an eval block to catch any errors via die().
#
sub Get_Request_Info($) {
    my($filename) = @_;
    my $request_file = File::Basename::basename $filename;
    my $processed = Gridmap_Utils::Long_Time_Image
                        Gridmap_Utils::Get_Time_Of_Day;
    my $result;

    Debug "Get_Request_Info $filename\n";
    eval {
        $result = Gridmap_Utils::Read_Records '-single', $filename;
    };
    if ($@) {
        my $message = $@;
        chomp $message;
        return { REQUEST_FILE => $request_file,
                 PROCESSED    => $processed,
                 ERRORS       => [ $message ] };
    }

    foreach my $key (sort keys %$result) {
        Debug "    $key => $result->{$key}\n";
    }

    my @invalid = ();
    foreach my $key (keys %$result) {
        if (not $is_valid_key{$key}) {
            push @invalid, $key;
        }
    }
    if (@invalid) {
        push @{$result->{ERRORS}}, "Invalid key(s): @invalid";
    }

    my @missing = ();
    foreach my $key (@required_keys) {
        if (not defined $result->{$key}) {
            push @missing, $key;
        }
    }
    if (@missing) {
        push @{$result->{ERRORS}}, "Missing key(s): @missing";
    }

    #
    # Each key may occur only once, except possibly for 'comment'.
    # (We allow multiple 'comment' attributes, but I'm not sure whether
    # this actually occurs.)
    #
    my @multiple = ();
    foreach my $key (keys %$result) {
        if ($key ne 'comment' and ref $result->{$key} eq 'ARRAY') {
            push @multiple, $key;
        }
    }
    if (@multiple) {
        push @{$result->{ERRORS}}, "Multiple occurrences of: @missing";
    }

    $result->{REQUEST_FILE} = $request_file;
    $result->{PROCESSED}    = $processed;

    if (defined $result->{ERRORS}) {
        return $result;
    }

    my $OP = $result->{operation}; # just an abbreviation

    if (not $is_valid_operation{$OP}) {
        push @{$result->{ERRORS}}, "Invalid operation";
        return $result;
    }

    #
    # The username field is forbidden for remove-dn, mandatory for
    # other operations.
    #
    if ($OP eq 'remove-dn' and defined $result->{username}) {
        push @{$result->{ERRORS}}, "Extraneous username field";
    }
    elsif ($OP ne 'remove-dn' and not defined $result->{username}) {
        push @{$result->{ERRORS}}, "Missing username field";
    }

    #
    # The dn field is forbidden for remove-user, required for other
    # operations.
    #
    if ($OP eq 'remove-user' and defined $result->{dn}) {
        push @{$result->{ERRORS}}, "Extraneous dn field";
    }
    elsif ($OP ne 'remove-user' and not defined $result->{dn}) {
        push @{$result->{ERRORS}}, "Missing dn field";
    }

    #
    # A DN (as stored in the log file) must start and end with a '"'
    # character, and have no other '"' characters.
    #
    if (defined $result->{dn} and $result->{dn} !~ /^"[^"]+"$/) {
        push @{$result->{ERRORS}}, "Invalid DN (quote error)";
    }

    my $new_timestamp = Gridmap_Utils::Timestamp_Of $result->{timestamp};
    if (defined $new_timestamp) {
        $result->{timestamp} = $new_timestamp;

        my $seconds = $new_timestamp;
        $seconds =~ s/[. ].*$//;
        #
        # Make sure the timestamp isn't more than 60 seconds in the future.
        # (Allow 60 seconds for clock skew.)
        #
        if ($seconds - $Now > 60) {
            push @{$result->{ERRORS}}, "Future timestamp: $result->{timestamp}\n";
        }
    }
    else {
        push @{$result->{ERRORS}}, "Invalid timestamp: $result->{timestamp}\n";
    }

    #
    # Determine the actual owner of the file.
    #
    my @stat = stat $filename;
    if (not @stat) {
        die "stat failed: $!\n";
    }
    my $file_uid = $stat[4];
    my $file_pw = Gridmap_Utils::Get_PW $file_uid;
    $result->{OWNER_UID} = $file_uid;
    if (defined $file_pw and defined $file_pw->{name}) {
        $result->{OWNER_NAME} = $file_pw->{name};
    }

    my $owner_is_admin =
        ( defined $result->{OWNER_NAME} and
          Gridmap_Utils::Is_Admin_Account $result->{OWNER_NAME} );

    #
    # By convention, user-defined options are in lower case, and
    # annotations are in upper case.  The "source" option is
    # both; it can be specified by an administrator running gx-map,
    # and it can be set as an annotation.
    #
    # If "source" is not set, set "SOURCE" to "user" or "admin",
    # depending on who ran gx-map.
    # If "source" is set (only by an administrator), set "SOURCE" to
    # the same value.
    #
    if (defined $result->{source}) {
        if ($owner_is_admin) {
            $result->{SOURCE} = $result->{source};
        }
        else {
            my $user;
            if (defined $result->{OWNER_NAME}) {
                $user = $result->{OWNER_NAME};
            }
            else {
                $user = $result->{OWNER_UID};
            }
            push @{$result->{ERRORS}},
                 "User $user tried to define SOURCE " .
                 "\"$result->{SOURCE}\"\n";
        }
    }
    else {
        $result->{SOURCE} = ( $owner_is_admin ? "admin" : "user" );
    }

    $result->{NAMESPACE} = $User_Opt->{namespace};

    return $result;
} # Get_Request_Info

# ----------------------------------------------------------------------

sub Append_To_Log($@) {
    my($log_file, @requests) = @_;
    return if not @requests;

    my $log_file_dirname  = File::Basename::dirname  $log_file;
    my $log_file_basename = File::Basename::basename $log_file;
    my $RCS_dir  = "$log_file_dirname/RCS";
    my $RCS_file = "$RCS_dir/$log_file_basename,v";

    if (not -e $log_file) {
        open my $Log, '>', $log_file or die "$log_file: $!\n";
        print $Log "# \$", "Id:\$\n",
                   "# \$", "Source:\$\n",
                   "\n";
        close $Log;
    }

    #
    # The log file is normally read-only.
    # Temporarily make it writable, append the new
    # records to it, then change it back to read-only.
    # Watch out for the permissions on the RCS file (bug-0003).
    #
    my $readonly = oct $Gridmap_Utils::Config{REQUESTS_LOG_PERMISSIONS};
    my $writable = $readonly | 0200;

    if (-e $log_file) {
        chmod $writable, $log_file or die "chmod $log_file: $!\n";
    }

    Gridmap_Utils::Write_Records '-multiple', $log_file, @requests;

    chmod $readonly, $log_file or die "chmod $log_file: $!\n";

    #
    # Now check it into RCS.
    # The RCS file is normally kept locked.
    # Unlock it temporarily to check in the file.
    #
    if (not -d $RCS_dir) {
        #
        # It should already exist, but let's make sure.
        #
        mkdir $RCS_dir, 0777 or die "mkdir $RCS_dir: $!\n";
    }
    Gridmap_Utils::Use_Commands 'rcs', 'ci';
    system "rcs -l $log_file >/dev/null 2>/dev/null";
    system "ci -u -f $log_file </dev/null >/dev/null 2>/dev/null";

    chmod $readonly, $log_file or die "chmod $log_file: $!\n";
    chmod $readonly, $RCS_file or die "chmod $RCS_file: $!\n";
} # Append_To_Log

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name [options]
    -help           : Display this message and exit
    -version        : Display version information and exit
    -namespace name : Specify namespace (default is "$Gridmap_Utils::Config{NAMESPACE}")
    -copy file      : Copy the requests.log file to the specified location
                      (e.g., to make it visible on a web page)
                      The file's mode is set to 444 (-r--r--r--).
    -dryrun         : Passed to sbin/gx-propagate.
                      This is for testing purposes only; it can cause
                      requests to be permanently bypassed.
    -debugging      : Enable debugging output
EOF
#   -directory dir  : Data directory
#                     Default is $Default_Data_Dir
    exit 1;
} # Usage

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $User_Opt->{debugging};
} # Debugf
