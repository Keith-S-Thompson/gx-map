#!%PERL% -wT

# $Id: gx-check-requests.in,v 1.26 2004-07-30 18:08:08-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-check-requests.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2004 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use Getopt::Long ();

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

sub Usage(@);
sub Get_Request_Info($);
sub Flatten_Errors($);
sub Append_To_Log($@);
sub Debug(@);
sub Debugf(@);

my $Prog_Name = File::Basename::basename $0;

my $Hostname = Gridmap_Utils::Get_Hostname;
my $Default_Data_Dir = "$Install_Dir/var";

my $User_Opt = {};
my @Opts = ( $User_Opt,
             qw( help version namespace=s copy=s debugging ) );
             # directory=s
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;

if ($User_Opt->{version}) {
    print "gx-check-requests, part of gx-map version $Gridmap_Utils::VERSION\n";
    exit 0;
}

Usage "No -namespace option given\n" if not defined $User_Opt->{namespace};
$Gridmap_Utils::Debugging = 1 if $User_Opt->{debugging};

# my $Data_Dir = defined $User_Opt->{directory}
#                      ? $User_Opt->{directory}
#                      : $Default_Data_Dir;
my $Data_Dir = $Default_Data_Dir;
Gridmap_Utils::Untaint $Data_Dir;
if ($Data_Dir !~ /^\//) {
    die "Data directory $Data_Dir is not an absolute pathname\n";
}
my $requests_log     = "$Data_Dir/requests.log";
my $errors_log       = "$Data_Dir/errors.log";
my $new_request_dir  = "$Data_Dir/new-requests";
my $good_request_dir = "$Data_Dir/good-requests";
my $bad_request_dir  = "$Data_Dir/bad-requests";
my $lock_file        = "$Data_Dir/.lock";

die "No directory $Data_Dir\n"        if not -d $Data_Dir;
die "No directory $new_request_dir\n" if not -d $new_request_dir;
if (not -d $good_request_dir) {
    mkdir $good_request_dir, 0700 or die "mkdir $good_request_dir: $!\n";
}
if (not -d $bad_request_dir) {
    mkdir $bad_request_dir, 0700 or die "mkdir $bad_request_dir: $!\n";
}

if (-e $lock_file) {
    my $lock_time = Gridmap_Utils::Get_mtime $lock_file;
    my $now = time;
    die "Locked for ", $now - $lock_time, " seconds\n";
}
open LOCK, ">$lock_file";
close LOCK;

my @required_keys = qw( operation timestamp requested_by_name
                        requested_by_uid hostname );
my @valid_keys = ( @required_keys,
                   qw( dn map_to_name secondary email comment
		       map_to_uid NAMESPACE ) );
my @valid_operations = qw( add remove remove-dn remove-user );
my %is_required_key    = map { $_ => 1 } @required_keys;
my %is_valid_key       = map { $_ => 1 } @valid_keys;
my %is_valid_operation = map { $_ => 1 } @valid_operations;

opendir DIR, $new_request_dir or die "$new_request_dir: $!\n";
my @files = grep /\.request$/, sort readdir DIR;
closedir DIR;

foreach my $file (@files) {
    Gridmap_Utils::Untaint $file;
}

my @good_requests = ();
my @good_request_files = ();
my @bad_requests = ();
my @bad_request_files = ();

foreach my $file (@files) {
    my $request = Get_Request_Info "$new_request_dir/$file";
    if (defined $request->{ERRORS}) {
        Flatten_Errors $request;
        push @bad_requests, $request;
        push @bad_request_files, $file;
    }
    else {
        push @good_requests, $request;
        push @good_request_files, $file;
    }
}

if (not @good_requests and not @bad_requests) {
    #
    # No requests seen.  Bail out.
    #
    unlink $lock_file;
    exit;
}

#
# We have one or more new requests to process.  Append them to the
# requests log and/or the errors log.
#

if (not -d "$Data_Dir/RCS") {
    mkdir "$Data_Dir/RCS", 0700 or die "mkdir $Data_Dir/RCS: $!\n";
}

Append_To_Log $errors_log,   @bad_requests;
Append_To_Log $requests_log, @good_requests;

if (defined $User_Opt->{copy}) {
    Gridmap_Utils::Untaint $User_Opt->{copy};
    Gridmap_Utils::Untaint $requests_log;
    my $target_file = $User_Opt->{copy};
    my $tmp_file = $User_Opt->{copy} . ".new";

    Gridmap_Utils::Use_Commands 'cp';
    my $result = system 'cp', '-p', '-f', $requests_log, $tmp_file;
    rename $tmp_file, $target_file;
    chmod 0444, $target_file;
}

#
# Now that the records have been safely appended to the log and
# checked into RCS, move the individual request files into appropriate
# subdirectories.
#
my @rename_errors = ();
foreach my $file (@good_request_files) {
    rename "$new_request_dir/$file", "$good_request_dir/$file"
        or push @rename_errors, "${file}: $!\n";
}
foreach my $file (@bad_request_files) {
    rename "$new_request_dir/$file", "$bad_request_dir/$file"
        or push @rename_errors, "${file}: $!\n";
}

if (@rename_errors) {
    print STDERR "Error(s) moving request files:\n",
                 @rename_errors;
}

unlink $lock_file;

########################################################################

#
# Given the name of a request file, returns a reference to the information
# from the file.  If any error occurs, the information will include an
# "ERRORS" field, a reference to an array of error messages.
#
# We use an eval block to catch any errors via die().
#
sub Get_Request_Info($) {
    my($filename) = @_;
    my @records;
    my $request_file = File::Basename::basename $filename,
    my $processed    = Gridmap_Utils::Time_Image time;
    my $result = undef;

    Debug "Get_Request_Info $filename\n";
    eval {
        @records = Gridmap_Utils::Read_Records $filename;
    };
    if ($@) {
        my $message = $@;
        chomp $message;
        return { REQUEST_FILE => $request_file,
                 PROCESSED    => $processed,
                 ERRORS       => [ $message ] };
    }
    elsif (scalar @records == 0) {
        return { REQUEST_FILE => $request_file,
                 PROCESSED    => $processed,
                 ERRORS       => [ "No records in $filename" ] };
    }
    elsif (scalar @records > 1) {
        return { REQUEST_FILE => $request_file,
                 PROCESSED    => $processed,
                 ERRORS       => [ "Multiple records in $filename" ] };
    }

    $result = $records[0];

    foreach my $key (sort keys %$result) {
        Debug "    $key => $result->{$key}\n";
    }

    my @invalid = ();
    foreach my $key (keys %$result) {
        if (not $is_valid_key{$key}) {
            push @invalid, $key;
        }
    }
    if (@invalid) {
        push @{$result->{ERRORS}}, "Invalid key(s): @invalid";
    }

    my @missing = ();
    foreach my $key (@required_keys) {
        if (not defined $result->{$key}) {
            push @missing, $key;
        }
    }
    if (@missing) {
        push @{$result->{ERRORS}}, "Missing key(s): @missing";
    }

    $result->{REQUEST_FILE} = $request_file;
    $result->{PROCESSED}    = $processed;

    if (defined $result->{ERRORS}) {
        return $result;
    }

    if (not $is_valid_operation{$result->{operation}}) {
        push @{$result->{ERRORS}}, "Invalid operation";
    }

    if ($result->{operation} ne 'remove-dn' and
        not defined $result->{map_to_name})
    {
        push @{$result->{ERRORS}}, "Missing map_to_name field";
    }

    if ($result->{operation} ne 'remove-user' and
        not defined $result->{dn})
    {
        push @{$result->{ERRORS}}, "Missing dn field";
    }

    if ($result->{timestamp} =~ /^(\d+)/) {
        $result->{timestamp} = Gridmap_Utils::Time_Image $1;
    }
    else {
        push @{$result->{ERRORS}}, "Invalid timestamp: $result->{timestamp}\n";
    }

    #
    # Determine the actual owner of the file.
    #
    my @stat = stat $filename;
    if (not @stat) {
        die "stat failed: $!\n";
    }
    my $file_uid = $stat[4];
    my $file_pw = Gridmap_Utils::Get_PW $file_uid;
    $result->{OWNER_UID} = $file_uid;
    if (defined $file_pw and defined $file_pw->{name}) {
        $result->{OWNER_NAME} = $file_pw->{name};
    }

    if (defined $result->{NAMESPACE}) {
        if (defined $result->{OWNER_NAME} and
            Gridmap_Utils::Is_Globus_Admin $result->{OWNER_NAME})
        {
            # ok, leave NAMESPACE as it is
        }
        else {
            my $user;
            if (defined $result->{OWNER_NAME}) {
                $user = $result->{OWNER_NAME};
            }
            else {
                $user = $result->{OWNER_UID};
            }
            push @{$result->{ERRORS}},
                 "User $user tried to define NAMESPACE " .
                 "\"$result->{NAMESPACE}\"\n";
        }
    }
    else {
        $result->{NAMESPACE} = $User_Opt->{namespace};
    }

    return $result;
} # Get_Request_Info

# ----------------------------------------------------------------------

#
# The ERRORS field is a reference to an array, but the Read_Records and
# Write_Records routines can only deal with simple scalar field values.
# Flatten the ERRORS array into a series of fields named ERROR_00,
# ERROR_01, etc.
#
sub Flatten_Errors($) {
    my($ref) = @_;

    if (defined $ref->{ERRORS}) {
        my @errors = @{$ref->{ERRORS}};
        for (my $i = 0; $i <= $#errors; $i ++) {
            my $key = sprintf "ERROR_%02d", $i;
            $ref->{$key} = $errors[$i];
        }
        delete $ref->{ERRORS};
    }
} # Flatten_Errors

# ----------------------------------------------------------------------

sub Append_To_Log($@) {
    my($log_file, @requests) = @_;
    return if not @requests;

    if (not -e $log_file) {
        open LOG, ">$log_file" or die "$log_file: $!\n";
        print LOG "# \$", "Id:\$\n",
                  "# \$", "Source:\$\n",
                  "\n";
        close LOG;
    }

    #
    # The log file is normally read-only (mode 400).
    # Temporarily make it writable (mode 600), append the new
    # records to it, then change it back to read-only.
    #
    if (-e $log_file) {
        chmod 0600, $log_file or die "chmod $log_file: $!\n";
    }

    Gridmap_Utils::Write_Records($log_file, @requests);

    chmod 0400, $log_file or die "chmod $log_file: $!\n";

    #
    # Now check it into RCS.
    # The RCS file is normally kept locked.
    # Unlock it temporarily to check in the file.
    #
    Gridmap_Utils::Use_Commands 'rcs', 'ci';
    system "rcs -l $log_file >/dev/null 2>/dev/null";
    system "ci -u -f $log_file </dev/null >/dev/null 2>/dev/null";
} # Append_To_Log

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Prog_Name [options]
    -help           : Display this message and exit
    -version        : Display version information and exit
    -namespace name : Specify namespace (e.g., "%NAMESPACE%"); mandatory
    -copy file      : Copy the requests.log file to the specified location
                      (e.g., to make it visible on a web page)
                      The file's mode is set to 444 (-r--r--r--).
    -debugging      : Enable debugging output
EOF
#   -directory dir  : Data directory
#                     Default is $Default_Data_Dir
    exit 1;
} # Usage

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $User_Opt->{debugging};
} # Debugf
