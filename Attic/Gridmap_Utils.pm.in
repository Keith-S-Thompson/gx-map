# $Id: Gridmap_Utils.pm.in,v 1.20 2003-07-25 18:53:23-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/Attic/Gridmap_Utils.pm.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2003 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

package Gridmap_Utils;

################ Module Preamble ################

BEGIN {
    require 5.004;
    use vars qw($VERSION $Debugging);
    $VERSION = "0.2";
    $Debugging = undef;
    use File::Basename ();
}

# ----------------------------------------------------------------------

sub Is_Tainted($);
sub Check_Tainting($$);
sub Untaint(\$);

sub Get_mtime($);
sub Get_PW(;$);
sub Get_GR(;$);
sub Get_Groups($);
sub Get_Hostname();

sub Is_Globus_Admin($);

sub Ensure_RCS();

sub Time_Image($);

sub Write_Records($@);
sub Read_Records($);

sub Init_Cache_Info();
sub Cache_File($);

sub Debug(@);
sub Debugf(@);

# ----------------------------------------------------------------------

sub Is_Tainted($) {
    my($arg) = @_;
    my $nada = substr($arg, 0, 0);  # zero-length
    local $@;  # preserve caller's version
    eval { eval "# $nada" };
    return length($@) != 0;
} # Is_Tainted

# ----------------------------------------------------------------------

sub Check_Tainting($$) {
    my($name, $value) = @_;
    if (Is_Tainted $value) {
        die ">>> $name = \"$value\" is tainted\n";
    }
} # Check_Tainting

# ----------------------------------------------------------------------

sub Untaint(\$) {
    my($ref) = @_;
    ($$ref) = ($$ref =~ /(.*)/);
} # Untaint

# ----------------------------------------------------------------------

#
# If the named file exists, returns its mtime.
# If not, returns undef.
#
sub Get_mtime($) {
    my($filename) = @_;
    my @stat = stat $filename;
    if (@stat) {
        return $stat[9];
    }
    else {
        return undef;
    }
} # Get_mtime

# ----------------------------------------------------------------------

#
# A friendlier getpw* function
# Calls getpwent, getpwuid, or getpwnam depending on arguments (if any)
# Returns a hash reference; keys are 'name', 'passwd', etc.
# Returns undef on failure.
#
sub Get_PW(;$) {
    my $user = @_ ? $_[0] : undef;
    my @pw;
   
    if (not defined $user) {
        @pw = getpwent;
    }
    elsif ($user =~ /^\d+$/) {
        @pw = getpwuid($_[0]);
    }
    else {
        @pw = getpwnam($_[0]);
    }
    if (scalar @pw != 9) {
        return undef;
    }
    else {
        my $result;
        my @fields = qw(name passwd uid gid quota comment gcos dir shell);
        for (my $i = 0; $i <= $#fields; $i ++) {
            $result->{$fields[$i]} = $pw[$i];
        }
        return $result;
    }
} # Get_PW

# ----------------------------------------------------------------------

#
# A friendlier getgr* function
# Calls getgrent, getgruid, or getgrnam depending on arguments (if any)
# Returns a hash reference; keys are 'name', 'passwd', etc.
# 'members' is a ref to an array of member names
# Returns undef on failure.
#
sub Get_GR(;$) {
    my $group = @_ ? $_[0] : undef;
    my @gr;

    if (not defined $group) {
        @gr = getgrent;
    }
    elsif ($_[0] =~ /^\d+$/) {
        @gr = getgrgid($group);
    }
    else {
        @gr = getgrnam($group);
    }
    if (scalar @gr != 4) {
        return undef;
    }
    else {
        my $result;
        $result->{name}   = $gr[0];
        $result->{passwd} = $gr[1];
        $result->{gid}    = $gr[2];
        my @members = split / /, $gr[3];
        $result->{members} = \@members;
        return $result;
    }
} # Get_GR

# ----------------------------------------------------------------------

#
# Returns a list of the groups to which the specified user belongs.
# Groups are specified by name, not by number.
#
sub Get_Groups($) {
    my($user) = @_;
    my %is_member = ();
    my $pw = Get_PW($user);
    return () if not defined $pw;
    my $primary_gid = $pw->{gid};
    my $primary_group = Get_GR $primary_gid;
    if (defined $primary_group) {
        $is_member{$primary_group->{name}} = 1;
    }

    setgrent;
    while (my $group = Get_GR()) {
        MEMBER:
        foreach my $member (@{$group->{members}}) {
            if ($member eq $pw->{name}) {
                $is_member{$group->{name}} = 1;
                last MEMBER;
            }
        }
    }
    endgrent;

    return sort keys %is_member;
} # Get_Groups

# ----------------------------------------------------------------------

#
# Return the current hostname, as a fully qualified domain name if
# possible.
#
sub Get_Hostname() {
    my $hostname   = undef;
    my $domainname = undef;

    chomp($hostname = `/bin/hostname 2>/dev/null`);

    if ($hostname =~ /\./) {
        #
        # hostname returned an FQDN; return it
        #
        return $hostname;
    }

    open FILE, '/etc/resolv.conf' or return $hostname;
    LINE:
    while (<FILE>) {
        chomp;
        my @fields = split;
        if (scalar @fields == 2 and $fields[0] eq 'domain'
            or
            scalar @fields >= 2 and $fields[0] eq 'search')
        {
            $domainname = $fields[1];
            last LINE;
        } 
    } 
    close FILE;

    if (defined $domainname) {
        return "$hostname.$domainname";
    }
    else {       
        #
        # Punt.
        #
        return $hostname;
    }
} # Get_Hostname

# ----------------------------------------------------------------------

my %is_globus_admin = (); # cache for Is_Globus_Admin function

sub Is_Globus_Admin($) {
    my($user) = @_;
    my $admins = '%GLOBUS_ADMINS%';

    Debug ">>> Is_Globus_Admin \"$user\"\n";
    if (exists $is_globus_admin{$user}) {
        Debug "    value is cached\n";
    }
    if (not exists $is_globus_admin{$user}) {
        ENTRY:
        foreach my $entry (split /\s+/, $admins) {
            if ($entry =~ /^user:(.*)$/) {
                if ($1 eq $user) {
                    Debug "    Yes for user $user\n";
                    return ($is_globus_admin{$user} = 1);
                }
            }
            elsif ($entry =~ /^group:(.*)$/) {
                my $group = $1;
                foreach my $gr (Get_Groups $user) {
                    if ($gr eq $group) {
                        Debug "    Yes for group $group\n";
                        return ($is_globus_admin{$user} = 1);
                        last ENTRY;
                    }
                }
            }
        }
        Debug "    No\n";
        return ($is_globus_admin{$user} = 0);
    }

    Debug "Returning $is_globus_admin{$user}\n";
    return $is_globus_admin{$user};
} # Is_Globus_Admin

# ----------------------------------------------------------------------

#
# Ensure that the RCS commands co, ci, and rcs are available in $PATH.
# Assumes they're all in the same directory, either already in $PATH
# or in /usr/local/bin.
#
sub Ensure_RCS() {
    my @path = split /:/, $ENV{PATH};
    foreach my $dir (@path) {
        if (-x "$dir/co" and -x "$dir/ci" and -x "$dir/rcs") {
            return;
        }
    }
    if (-x "/usr/local/bin/co" and
        -x "/usr/local/bin/ci" and
        -x "/usr/local/bin/rcs")
    {
        $ENV{PATH} = "/usr/local/bin:$ENV{PATH}";
    }
    else {
        die "Can't find RCS commands\n";
    }
} # Ensure_RCS

# ----------------------------------------------------------------------

#
# For a given time, returns a string of the form
#     "ssssssssss YYYY-MM-DD hh:mm:ss UTC"
# where "ssssssssss" is the raw Unix timestamp.
#
sub Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime $time;

    return sprintf "%010d %s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   $time,
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec;
}

# ----------------------------------------------------------------------

#
# Given a file name and a list of records, write a text representation
# of the records to the file.  The file is created if it doesn't already
# exist; the records are then appended to the file.
#
# Each record is a reference to a hash, where the keys are field names.
#
sub Write_Records($@) {
    my($filename, @refs) = @_;
    return if not @refs;

    my $output = "";

    foreach my $ref (@refs) {
        $output .= "{\n";

        my $max_key_len = 0;
        foreach my $key (keys %$ref) {
            $max_key_len = length $key if length $key > $max_key_len;
        }

        foreach my $key (sort keys %$ref) {
            $output .= sprintf "\t%-${max_key_len}s  %s\n",
                               $key, $ref->{$key};
        }

        $output .= "}\n\n";
    }

    open FILE, ">>$filename" or die "${filename}: $!\n";
    print FILE $output or die "printing to ${filename}: $!\n";
    close FILE or die "closing ${filename}: $!\n";
} # Write_Records

# ----------------------------------------------------------------------

#
# Given a file name, reads (zero or more) records from the file and
# returns them in a list.
#
sub Read_Records($) {
    my ($filename) = @_;
    open FILE, $filename or die "${filename}: $!\n";
    my @result = ();
    my $ref = undef;
    LINE:
    while (<FILE>) {
        chomp;
        s/^\s+//;
        s/\s+$//;
        next LINE if $_ eq '';
        if (defined $ref) {
            if ($_ eq '}') {
                push @result, $ref;
                undef $ref;
            }
            elsif (/(\w+)\s+(.*)$/) {
                my($key, $value) = ($1, $2);
                if (defined $ref->{$key}) {
                    die "Duplicate key $key at line $. of $filename\n";
                }
                $ref->{$key} = $value;
            }
        }
        else {
            #
            # Allow comments between records, not within them.
            #
            next LINE if /^#/;
            if ($_ eq '{') {
                $ref = {};
            }
            else {
                die "Syntax error (expected '{' or EOF) " .
                    "at line $. of $filename\n";
            }
        }
    }
    return @result;
} # Read_Records

# ----------------------------------------------------------------------

my %Cache_File = ();
my $Download_Dir = "%INSTALL_DIR%/var/cache";
my $Download_Index = 0;

# ----------------------------------------------------------------------

sub Init_Cache_Info() {
    opendir DIR, $Download_Dir or die "$Download_Dir: $!\n";
    SUBDIR:
    foreach my $subdir (sort readdir DIR) {
        next SUBDIR if $subdir !~ /^\d+-\d+-\d+$/;
        open URL, "$Download_Dir/$subdir/.url" or next SUBDIR;
        my $url = <URL>;
        chomp $url;
        close URL;
        my $filename = "$Download_Dir/$subdir/" .
                       File::Basename::basename $url;
        Untaint $url;
        Untaint $filename;
        $Cache_File{$url} = $filename;
    }
    closedir DIR;
} # Init_Cache_Info

# ----------------------------------------------------------------------

#
# Given a URL, returns the name of a local file containing a copy of
# the specified file.  Uses the wget or ncftpget command.
#
# If the specified file has already been cached, we attempt to update it;
# if the update fails, we still return the name of the old cached file.
#
# The wget command, if invoked with the "-N" (or "--timestamping") option,
# sets the mtime of the local file to be the same as the modification
# time of the remote file.  The "-N" option also says not to re-retrieve
# the file unless the remote file is newer than the local copy.
#
# Due to a bug in wget, we need to chdir to the target directory before
# downloading the file (rather than using the "-O" option); otherwise
# we risk clobbering the target file.
#
sub Cache_File($) {
    my($url) = @_;
    my $is_ftp = $url =~ /^ftp/;
    my $result;

    Init_Cache_Info();
    my $initial_download = not defined $Cache_File{$url};

    if ($initial_download) {
        my $dir = "$Download_Dir/" . time . "-$$-$Download_Index";
        my $file = File::Basename::basename $url;
        $Download_Index ++;
        mkdir $dir, 0777 or die "${dir}: $!\n";
        my $cache_file = "$dir/$file";
        chdir $dir or die "${dir}: $!\n";
        if ($is_ftp) {
            $result = system "%NCFTPGET% -V $url 2>/dev/null";
        }
        else {
            $result = system '%WGET%',
                             '-N',
                             '-o', '/dev/null',
                             $url;
        }
        if ($result == 0) {
            open URL, ">$dir/.url" or die "$dir/.url: $!\n";
            print URL "$url\n";
            close URL;
            $Cache_File{$url} = $cache_file;
        }
        else {
            unlink $cache_file;
            rmdir $dir;
            my $cmd = $is_ftp ? 'ncftpget' : 'wget';
            die "$cmd failed for $url, system() returned $result\n";
        }
    }
    else {
        #
        # Try to refresh the file.
        #
        my $dir = File::Basename::dirname $Cache_File{$url};
        chdir $dir or die "${dir}: $!\n";
        if ($is_ftp) {
            $result = system "%NCFTPGET% -V $url 2>/dev/null";
        }
        else {
            $result = system '%WGET%',
                             '-N',
                             '-o', '/dev/null',
                             $url;
        }
        #
        # Ignore errors; we already have a copy of the file.
        #
    }
    return $Cache_File{$url};
} # Cache_File

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $Debugging;
} # Debug   

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $Debugging; 
} # Debugf  

1;
