# $Id: Gridmap_Utils.pm.in,v 1.62 2005-04-26 18:08:00-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/Attic/Gridmap_Utils.pm.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2005 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

package Gridmap_Utils;

################ Module Preamble ################

#
# This package does not use the Exporter module, so any code that uses
# entities declared here must use an explicit "Gridmap_Utils::" prefix.
#
# The value of the VERSION variable is the version number for the entire
# gx-map system.
#
# The %Config hash contains values generated before installation by
# configure-gx-map.  Note that the PERL and INSTALL_DIR options are
# necessarily expanded directly in each file, and the VALID_MAPPINGS
# option is used directly by configure-gx-map; other options should be
# referenced via the %Gridmap_Utils::Config hash.
# 

#
# Some Perl installations don't have the Net::Domain module.  We want
# to use it in the Get_Hostname function if it's available; otherwise
# we'll fall back to the "hostname" command.
#

my $Have_Net_Domain_Module;

BEGIN {
    require 5.006;
    use vars qw($VERSION $Debugging %Config $Registered_Handler_Function);
    $VERSION = '0.4.3';
    $Debugging = undef;
    %Config = ( PERL                     => '%PERL%',
                PATH                     => '%PATH%',
                NAMESPACE                => '%NAMESPACE%',
                INSTALL_DIR              => '%INSTALL_DIR%',
                DATA_DIR                 => '%DATA_DIR%',
                REQUESTS_LOG_PERMISSIONS => '%REQUESTS_LOG_PERMISSIONS%',
                GLOBUS_ADMINS            => '%GLOBUS_ADMINS%',
                ADMIN_EMAIL              => '%ADMIN_EMAIL%' );
    use File::Basename ();
    use Cwd ();
    eval { require Net::Domain };
    $Have_Net_Domain_Module = ( $@ eq '' );
}

# ----------------------------------------------------------------------

#
# Get_Config (for runtime configuration) should be in the next major
# release.
#
# sub Get_Config($);

sub Is_Tainted($);
sub Check_Tainting($$);
sub Untaint(\$);

sub Get_mtime($);
sub Get_PW(;$);
sub Get_GR(;$);
sub Get_Groups($);
sub Get_Hostname();
sub Dir_Error($);

sub Is_Globus_Admin($);

sub Use_Commands(@);
sub Ensure_RCS();   # Provided only for compatibility with gx-map 0.3

sub Time_Image($);
sub Long_Time_Image($);

sub Write_Records($$@);
sub Read_Records($$);

sub Init_Cache_Info();
sub Cache_File($);

sub Read_User_Map($;$);
sub Read_Admin_List($);

sub GT2_Subject($);
sub GT3_Subject($);

sub DN_List($);
sub Dup_Ref($);

sub Install_Die_Handler();
sub Install_Warn_Handler();
sub Register_Handler_Function($);

sub Debug(@);
sub Debugf(@);

########################################################################

# sub Get_Config($) {
#     my($config_file) = @_;
#     my $result = {};
#     my %valid_var_name = map { $_ => 1 }
#                              qw( PERL
#                                  PATH
#                                  NAMESPACE
#                                  INSTALL_DIR
#                                  DATA_DIR
#                                  REQUESTS_LOG_PERMISSIONS
#                                  GLOBUS_ADMINS
#                                  ADMIN_EMAIL
#                                  VALID_MAPPINGS_FILE );
#     my %optional_var = ( VALID_MAPPINGS_FILE => 1 );
#     open CONFIG, $config_file or die "$config_file: $!\n";
#     while (<CONFIG>) {
#         s/#.*$//;
#         s/^\s+//;
#         s/\s+$//;
#         next if /^$/;
#    
#         chomp;
#    
#         if (/^(\w+)\s+(.*)$/) {
#             my($name, $value) = ($1, $2);
#             eval { $value =~ s/~(\w+)/Home_Dir $1/eg; };
#             if ($@) {
#                 chomp $@;
#                 push @errors, "$@, $config_file line $.\n";
#             }
#             if ($valid_var_name{$name}) {
#                 if (exists $Config{$name}) {
#                     push @errors,
#                          "Duplicate name \"$name\", $config_file line $.\n";
#                 }
#                 else {
#                     $result->{$name} = $value;
#                 }
#             }
#             else {
#                 push @errors, "Invalid name \"$name\", $config_file line $.\n";
#             }
#             if ($value eq 'UNDEF' and not $optional_var{$name}) {
#                 push @errors,
#                      "Undefined value for \"$name\", $config_file line $.\n";
#             }
#         }
#     }
#     close CONFIG;
#     die @errors if @errors;
# } Get_Config

# ----------------------------------------------------------------------

sub Is_Tainted($) {
    my($arg) = @_;
    my $nada = substr($arg, 0, 0);  # zero-length
    local $@;  # preserve caller's version
    eval { eval "# $nada" };
    return length($@) != 0;
} # Is_Tainted

# ----------------------------------------------------------------------

sub Check_Tainting($$) {
    my($name, $value) = @_;
    if (Is_Tainted $value) {
        die ">>> $name = \"$value\" is tainted\n";
    }
} # Check_Tainting

# ----------------------------------------------------------------------

sub Untaint(\$) {
    my($ref) = @_;
    ($$ref) = ($$ref =~ /(.*)/);
} # Untaint

# ----------------------------------------------------------------------

#
# If the named file exists, returns its mtime.
# If not, returns undef.
#
sub Get_mtime($) {
    my($filename) = @_;
    my @stat = stat $filename;
    if (@stat) {
        return $stat[9];
    }
    else {
        return undef;
    }
} # Get_mtime

# ----------------------------------------------------------------------

#
# A friendlier getpw* function
# Calls getpwent, getpwuid, or getpwnam depending on arguments (if any)
# Returns a hash reference; keys are 'name', 'passwd', etc.
# Returns undef on failure.
#
sub Get_PW(;$) {
    my $user = @_ ? $_[0] : undef;
    my @pw;
   
    if (not defined $user) {
        @pw = getpwent;
    }
    elsif ($user =~ /^\d+$/) {
        @pw = getpwuid($_[0]);
    }
    else {
        @pw = getpwnam($_[0]);
    }
    if (scalar @pw != 9) {
        return undef;
    }
    else {
        my $result;
        my @fields = qw(name passwd uid gid quota comment gcos dir shell);
        for (my $i = 0; $i <= $#fields; $i ++) {
            $result->{$fields[$i]} = $pw[$i];
        }
        return $result;
    }
} # Get_PW

# ----------------------------------------------------------------------

#
# A friendlier getgr* function
# Calls getgrent, getgruid, or getgrnam depending on arguments (if any)
# Returns a hash reference; keys are 'name', 'passwd', etc.
# 'members' is a ref to an array of member names
# Returns undef on failure.
#
sub Get_GR(;$) {
    my $group = @_ ? $_[0] : undef;
    my @gr;

    if (not defined $group) {
        @gr = getgrent;
    }
    elsif ($_[0] =~ /^\d+$/) {
        @gr = getgrgid($group);
    }
    else {
        @gr = getgrnam($group);
    }
    if (scalar @gr != 4) {
        return undef;
    }
    else {
        my $result;
        $result->{name}   = $gr[0];
        $result->{passwd} = $gr[1];
        $result->{gid}    = $gr[2];
        my @members = split / /, $gr[3];
        $result->{members} = \@members;
        return $result;
    }
} # Get_GR

# ----------------------------------------------------------------------

#
# Returns a list of the groups to which the specified user belongs.
# Groups are specified by name, not by number.
#
sub Get_Groups($) {
    my($user) = @_;
    my %is_member = ();
    my $pw = Get_PW($user);
    return () if not defined $pw;
    my $primary_gid = $pw->{gid};
    my $primary_group = Get_GR $primary_gid;
    if (defined $primary_group) {
        $is_member{$primary_group->{name}} = 1;
    }

    setgrent;
    while (my $group = Get_GR()) {
        MEMBER:
        foreach my $member (@{$group->{members}}) {
            if ($member eq $pw->{name}) {
                $is_member{$group->{name}} = 1;
                last MEMBER;
            }
        }
    }
    endgrent;

    return sort keys %is_member;
} # Get_Groups

# ----------------------------------------------------------------------

#
# Return the current hostname, as a fully qualified domain name if
# possible.  Use the Net::Domain module if it's available; otherwise,
# fall back to the hostname command.
#
sub Get_Hostname() {
    if ($Have_Net_Domain_Module) {
        return Net::Domain::hostfqdn();
    }
    else {
        Use_Commands 'hostname';
        my $hostname = `hostname 2>/dev/null`;
        chomp $hostname;
        return $hostname;
    }
} # Get_Hostname

# ----------------------------------------------------------------------

#
# Argument is the name of a directory to be used as the
# "new-requests" directory.
# If the directory is ok, returns undef (denoting no error).
# Otherwise, returns a message describing the problem.
# Directory must have permissions 1733, non-root users must be able to
# create files, and non-root users must *not* be able to use chown to
# change the ownership of a file.
#
sub Dir_Error($) {
    my($dir) = @_;
    my $running_as_root = ($< == 0);
    return "$dir does not exist"     if not -e $dir;
    return "$dir is not a directory" if not -d $dir;
    my @stat = stat $dir;
    return "Cannot stat $dir" if not @stat;
    my $mode = $stat[2] & 07777;
    if ($mode != 01733) {
        return "Bad permissions on $dir, should be 1733";
    }

    my $temp_file_name = "$dir/tmp-" . time . "-$$";
    my $result = undef;
    if ($running_as_root) {
        $< = 1;
    }
    Untaint $temp_file_name;
    open TEMP, ">$temp_file_name" or return "Cannot create file in $dir";
    close TEMP;
    if (chown(0, 0, $temp_file_name) == 1) {
        $result = "$dir allows non-root chown";
    }
    unlink $temp_file_name;
    if ($running_as_root) {
        $< = 0;
    }
    return $result;
} # Dir_Error

# ----------------------------------------------------------------------

my %is_globus_admin = ();

sub Is_Globus_Admin($) {
    my($user) = @_;
    my $admins = $Gridmap_Utils::Config{GLOBUS_ADMINS};

    if (scalar keys %is_globus_admin == 0) {
        foreach my $entry (split /\s+/, $admins) {
            if ($entry =~ /:/) {
                die "Syntax error in GLOBUS_ADMINS: $entry\n";
            }
            else {
                $is_globus_admin{$entry} = 1;
            }
        }
    }

    return $is_globus_admin{$user};
} # Is_Globus_Admin

# ----------------------------------------------------------------------

#
# Ensure that the specified command is available in the configured $PATH.
# Call this before executing any external commands.
#
# Side effect: Sets $PATH environment variable.
#
sub Use_Commands(@) {
    my(@commands) = @_;
    my @unfound = ();
    $ENV{PATH} = $Gridmap_Utils::Config{PATH};
    my @path = split /:/, $ENV{PATH};
    foreach my $command (@commands) {
        my $foundit = 0;
        DIR:
        foreach my $dir (@path) {
            if (-x "$dir/$command") {
                $foundit = 1;
                last DIR;
            }
        }
        push @unfound, $command if not $foundit;
    }
    if (@unfound) {
        die "Can't find command(s) (@unfound)\n" .
            "in configured \$PATH ($ENV{PATH})\n";
    }
} # Use_Commands

# ----------------------------------------------------------------------

#
# Provided only for compatibility with gx-map 0.3
#
sub Ensure_RCS() {
    Use_Commands 'co', 'ci', 'rcs';
} # Ensure_RCS

# ----------------------------------------------------------------------

#
# For a given time, returns a string of the form
#     Ddd YYYY-MM-DD hh:mm:ss UTC"
#
sub Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime $time;

    return sprintf "%s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec;
} # Time_Image

# ----------------------------------------------------------------------

#
# For a given time, returns a string of the form
#     "ssssssssss YYYY-MM-DD hh:mm:ss UTC"
# where "ssssssssss" is the raw Unix timestamp.
#
sub Long_Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime $time;

    return sprintf "%10d %s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   $time,
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec;
} # Long_Time_Image

# ----------------------------------------------------------------------

#
# The first argument must be either '-single' or '-multiple', specifying
# the output format.
#
# The second argument is the name of a file to which the records are
# to be written.  The file is created if it doesn't already exist;
# the records are then appended to the file.
#
# The remaining arguments are the records to be written.  Each record
# is a reference to a hash, where the keys are field names.
#
# If the first argument is '-single', there must be exactly one record.
# Each field is written as a single line consisting of the field name,
# followed by spaces, followed by the value.
#
# If the first argument is '-multiple', there can be zero or more
# records.  The fields are written in the same manner as for '-single',
# but each record is preceded and followed by lines containing 
# a left and right curly brace ('{', '}'), respectively.
#
# Extra spaces and blank lines may be added for legibility.
#
sub Write_Records($$@) {
    my($format, $filename, @refs) = @_;
    my $multiple;
    if ($format eq '-single') {
        die "Write_Records: expected a single record\n" if scalar @refs != 1;
        $multiple = 0;
    }
    elsif ($format eq '-multiple') {
        return if not @refs;
        $multiple = 1;
    }
    else {
        die "Write_Records: bad first argument\n";
    }

    my $output = '';

    foreach my $ref (@refs) {
        my $deleted = exists $ref->{__DELETED__};

        $output .= "# " if $deleted;
        $output .= "{\n" if $multiple;

        my $max_key_len = 0;
        foreach my $key (keys %$ref) {
            next if $key eq '__DELETED__';
            $max_key_len = length $key if length $key > $max_key_len;
        }

        foreach my $key (sort keys %$ref) {
            next if $key eq '__DELETED__';
            my $value = $ref->{$key};
            my @values = (ref $value eq 'ARRAY' ? @$value : ($value));
            foreach my $item (@values) {
                $output .= "# " if $deleted;
                $output .= "\t" if $multiple;
                $output .= sprintf "%-${max_key_len}s  %s\n", $key, $item;
            }
        }

        $output .= "# " if $deleted;
        $output .= "}\n\n" if $multiple;
    }

    open FILE, ">>$filename" or die "${filename}: $!\n";
    print FILE $output or die "printing to ${filename}: $!\n";
    close FILE or die "closing ${filename}: $!\n";
} # Write_Records

# ----------------------------------------------------------------------

#
# The first argument must be either '-single' or '-multiple', specifying
# the input format (see Write_Records).
#
# The second argument is the name of the file from which to read the record
# or records.
#
# Comments, which extend from a '#' character to the end of a line,
# are ignored.  A comment must be a line by itself; end-of-line comments
# are not supported on lines containing other data (so '#' characters can
# be used in field values).  Leading and trailing whitespace are ignored.
# Empty lines are ignored.
# 
# For '-single', the record read from the file is returned as a hash
# reference.
# For '-multiple', the records read from the file are returned as a list
# of hash references.
#
sub Read_Records($$) {
    my ($format, $filename) = @_;
    my $multiple;
    if ($format eq '-single') {
        $multiple = 0;
    }
    elsif ($format eq '-multiple') {
        $multiple = 1;
    }
    else {
        die "Read_Records: bad first argument\n";
    }

    open FILE, $filename or die "${filename}: $!\n";
    my @result = ();
    my $ref = ( $multiple ? undef : {} );
    LINE:
    while (<FILE>) {
        chomp;
        s/^\s+//;
        s/\s+$//;
        next LINE if /^#/ or $_ eq '';
        if (defined $ref) {
            if ($multiple and $_ eq '}') {
                push @result, $ref;
                undef $ref;
            }
            elsif (/(\w+)\s+(.*)$/) {
                my($key, $value) = ($1, $2);
                if (defined $ref->{$key}) {
                    if (ref $ref->{$key} ne 'ARRAY') {
                        $ref->{$key} = [ $ref->{$key} ];
                    }
                    push @{$ref->{$key}}, $value;
                }
                else {
                    $ref->{$key} = $value;
                }
            }
            else {
                die "Syntax error at line $. of $filename\n";
            }
        }
        else {
            if ($multiple) {
                if ($_ eq '{') {
                    $ref = {};
                }
                else {
                    die "Syntax error (expected '{' or EOF) " .
                        "at line $. of $filename\n";
                }
            }
        }
    }
    if ($multiple) {
        return @result;
    }
    else {
        return $ref;
    }
} # Read_Records

# ----------------------------------------------------------------------

my %Cache_File = ();
my $Download_Dir = "$Gridmap_Utils::Config{INSTALL_DIR}/var/cache";
my $Download_Index = 0;

# ----------------------------------------------------------------------

sub Init_Cache_Info() {
    opendir DIR, $Download_Dir or die "$Download_Dir: $!\n";
    SUBDIR:
    foreach my $subdir (sort readdir DIR) {
        next SUBDIR if $subdir !~ /^\d+-\d+-\d+$/;
        open URL, "$Download_Dir/$subdir/.url" or next SUBDIR;
        my $url = <URL>;
        chomp $url;
        close URL;
        my $filename = "$Download_Dir/$subdir/" .
                       File::Basename::basename $url;
        Untaint $url;
        Untaint $filename;
        $Cache_File{$url} = $filename;
    }
    closedir DIR;
} # Init_Cache_Info

# ----------------------------------------------------------------------

#
# Given a URL, returns the name of a local file containing a copy of
# the specified file.  Uses the wget or ncftpget command.
#
# If the specified file has already been cached, we attempt to update it;
# if the update fails, we still return the name of the old cached file.
#
# The wget command, if invoked with the "-N" (or "--timestamping") option,
# sets the mtime of the local file to be the same as the modification
# time of the remote file.  The "-N" option also says not to re-retrieve
# the file unless the remote file is newer than the local copy.
#
# Due to a bug in wget, we need to chdir to the target directory before
# downloading the file (rather than using the "-O" option); otherwise
# we risk clobbering the target file.
#
sub Cache_File($) {
    my($url) = @_;
    my $is_ftp = $url =~ /^ftp/;
    my $result;
    my $cwd = Cwd::getcwd;
    Untaint $cwd;

    Init_Cache_Info();
    my $initial_download = not defined $Cache_File{$url};

    if ($initial_download) {
        my $dir = "$Download_Dir/" . time . "-$$-$Download_Index";
        my $file = File::Basename::basename $url;
        $Download_Index ++;
        mkdir $dir, 0777 or die "${dir}: $!\n";
        my $cache_file = "$dir/$file";
        chdir $dir or die "${dir}: $!\n";
        if ($is_ftp) {
            Gridmap_Utils::Use_Commands 'ncftpget';
            $result = system "ncftpget -V -t 30 $url 2>/dev/null";
        }
        else {
            Gridmap_Utils::Use_Commands 'wget';
            $result = system 'wget', '--timestamping',
                                     '--output-file=/dev/null',
                                     '--timeout=30',
                                     '--tries=1',
                                     $url;
        }
        if ($result == 0) {
            open URL, ">$dir/.url" or die "$dir/.url: $!\n";
            print URL "$url\n";
            close URL;
            $Cache_File{$url} = $cache_file;
        }
        else {
            unlink $cache_file;
            chdir '..';
            rmdir $dir;
            my $cmd = $is_ftp ? 'ncftpget' : 'wget';
            if ($result % 256 == 0) {
                die "$cmd failed for $url, exit(" . $result / 256 . ")\n";
            }
            else {
                die "$cmd failed for $url, system() returned $result\n";
            }
        }
    }
    else {
        #
        # Try to refresh the file.
        #
        my $dir = File::Basename::dirname $Cache_File{$url};
        chdir $dir or die "${dir}: $!\n";
        if ($is_ftp) {
            Gridmap_Utils::Use_Commands 'ncftpget';
            $result = system "ncftpget -V $url 2>/dev/null";
        }
        else {
            Gridmap_Utils::Use_Commands 'wget';
            $result = system 'wget', '--timestamping',
                                     '--output-file=/dev/null',
                                     '--timeout=30',
                                     '--tries=1',
                                     $url;
        }
        #
        # Ignore errors; we already have a copy of the file.
        #
    }
    chdir $cwd;
    return $Cache_File{$url};
} # Cache_File

# ----------------------------------------------------------------------

#
# Given the name of a user map file, reads it and returns a reference
# to a data structure containing the information from the file.
# This data structure can be used to query mappings from user names
# in one namespace to user names in another namespace (i.e., from one
# site to another).
#
# If an error occurs on the attempt to open the file, returns a
# string containing the error message (e.g., "No such file or directory").
# On a syntax error, returns a string with an error message.  Thus
# the "ref" operator can be used to determine whether the call was
# successful.
#
# The result is a reference to a nested set of hashes.
# At the outer level, the keys are namespace identifiers (the source
# namespace).
# At the next level, the keys are also namespace identifiers (the target
# namespace).
# At the innermost level, the keys are Unix user names or numeric UIDs
# within the outer namespace, and the values are Unix user names within
# the inner namespace.
#
# Sample usage, assuming that John Smith is "ux123456" at SDSC
# and "jsmith" at NCSA:
#
#     my $Map = Read_User_Map 'user-map';
#     if (ref $Map eq '') { # it returned a string error message
#         die "Read_User_Map failed: $Map\n";
#     }
#     my $sdsc_name = $Map->{NCSA}->{SDSC}->{jsmith};
#     if (defined $sdsc_name) {
#         # Maps "jsmith" to "ux123456"
#         print "jsmith at NCSA is $sdsc_name at SDSC\n";
#     else {
#         print "No mapping for NCSA user 'jsmith' to SDSC namespace\n";
#     }
#
# Note that if a mapping does not exist (is not specified in the user map
# file), checking for it will cause some keys in the referenced hashes
# to "auto-vivify", with values set to undef.  This could be avoided by
# checking the "exists" predicate at each level, but it's probably not
# worth the effort; extra "undef" values should be harmless.
# 
# TO DO:
#     Check for multiple occurences of the same namespace in a single
#     entry.  (Actually, we might want to allow this.  More generally,
#     we need to integrate the support for multiple user names in a
#     grid-mapfile entry into the user map support.  Ick.  Think about
#     it later.)
#
sub Read_User_Map($;$) {
    my($filename, $this_namespace) = @_;
    #
    # $this_namespace may be undef
    #

    #
    # Each entry is a reference to a hash representing a single
    # brace-enclosed entry in the user map file.  The structure is:
    #     <entry>->{USERNAME} is a reference to a hash
    #         mapping namespaces to user names
    #     <entry>->{UID} is a reference to a hash
    #         mapping namespaces to numeric UIDs
    #     <entry>->{name} is the user's real name
    #
    # The %seen hash is used to avoid duplicate user@namespace or
    # uid@namespace mappings.
    # 
    my @Entries = ();
    my $curr_entry = undef;
    my %seen = ();              # user@namespace or UID@namespace seen

    open MAP, $filename or return $!;
    LINE:
    while (<MAP>) {
        #
        # First, parse the line into tokens.
        #
        chomp;
        s/#.*$//;

        my @tokens = ();

        TOKEN:
        while ($_ ne '') {
            if (/^\s*$/) {                          # No more tokens on line
                last TOKEN;
            }
            elsif (/^\s*{\s*(.*)$/) {               # opening brace
                push @tokens, '{';
                $_ = $1;
            }
            elsif (/^\s*(\S+\@\w+)\s*(.*)$/) {      # user@NAMESPACE
                push @tokens, $1;
                $_ = $2;
            }
            elsif (/^\s*(\S+:\d+\@\w+)\s*(.*)$/) {  # user:UID@NAMESPACE
                push @tokens, $1;
                $_ = $2;
            }
            elsif (/^\s*("[^"]*")\s*(.*)$/) {       # "Real Name"
                push @tokens, $1;
                $_ = $2;
            }
            elsif (/^\s*}\s*(.*)$/) {               # closing brace
                push @tokens, '}';
                $_ = $1;
            }
            else {
                return "Unrecognized token, line $.";
            }
        }

        #
        # Now process each token.
        #
        # '{' introduces a new entry; '}' specifies the end of an entry.
        #
        # user:UID@NAMESPACE or user@NAMESPACE specifies a user
        # identity.
        #
        # A string enclosed in double quotes is a user's real name.
        #
        # Any other token is an error.
        #
        foreach my $token (@tokens) {
            #
            # opening brace
            #
            if ($token eq '{') {
                if (defined $curr_entry) {
                    return "Unexpected '{', line $.";
                }
                $curr_entry = {};
            }

            #
            # user:UID@NAMESPACE or user@NAMESPACE
            # (numeric UID is optional)
            #
            elsif ($token =~ /^([^:@\s]+)(:(\d+))?\@(\S+)$/) {
                my($username, $uid, $namespace) = ($1, $3, $4);
                if (not defined $curr_entry) {
                    return "Unexpected token \"$token\", line $."
                }
                if (defined $curr_entry->{USERNAME}->{$namespace}) {
                    return "Duplicate namespace within entry, line $.";
                }
                if ($seen{"$username\@$namespace"}) {
                    return "Duplicate entry for $username\@$namespace";
                }
                if (defined $uid and $seen{"$uid\@$namespace"}) {
                    return "Duplicate entry for $uid\@$namespace";
                }
                $curr_entry->{USERNAME}->{$namespace} = $username;
                $seen{"$username\@$namespace"} = 1;
                if (defined $uid) {
                    $curr_entry->{UID}->{$namespace} = $uid;
                    $seen{"$uid\@$namespace"} = 1;
                }
            }

            #
            # "Real Name"
            #
            elsif ($token =~ /^".*"$/) {
                if (not defined $curr_entry) {
                    return "Unexpected token \"$token\", line $."
                }
                if (defined $curr_entry->{name}) {
                    return "Name already defined, line $.";
                }
                $curr_entry->{name} = $token;
            }

            #
            # closing brace
            #
            elsif ($token eq '}') {
                if (not defined $curr_entry) {
                    return "Unexpected '}'"
                }
                if (not defined $curr_entry->{name}) {
                    return "No name defined";
                }
                if (not defined $curr_entry->{USERNAME}) {
                    return "No user ids defined";
                }
                push @Entries, $curr_entry;
                undef $curr_entry;
            }
            else {
                return "Internal error";
            }
        }
    }
    close MAP;

    # Add a '{' to this comment so brace-matching works when I edit this.
    return "Missing '}' at end of file" if defined $curr_entry;

    #
    # Traverse the Entries array and build the Map data structure.
    # For a user with username "ux123456" (UID 123456) at SDSC and "jmith"
    # (UID 1234) at NCSA, we'll have
    #     $Map->{SDSC}->{NCSA}->{ux123456} eq "jsmith"
    #     $Map->{SDSC}->{NCSA}->{123456}   eq "jsmith"
    #     $Map->{NCSA}->{SDSC}->{jsmith}   eq "ux123456"
    #     $Map->{NCSA}->{SDSC}->{1234}     eq "ux123456"
    #

    my $Map = {};
    foreach my $entry (@Entries) {
        foreach my $namespace0 (sort keys %{$entry->{USERNAME}}) {
            foreach my $namespace1 (sort keys %{$entry->{USERNAME}}) {
                if ($namespace0 eq $namespace1) {
                    #
                    # Don't bother mapping from a namespace to itself.
                    #
                    next;
                }
                if (defined $this_namespace and
                    $namespace1 ne $this_namespace)
                {
                    #
                    # If specified, don't bother with mappings to any
                    # namespace other than this one.
                    #
                    next;
                }
                my $username0 = $entry->{USERNAME}->{$namespace0};
                my $username1 = $entry->{USERNAME}->{$namespace1};
                $Map->{$namespace0}->{$namespace1}->{$username0} = $username1;
                if (defined $entry->{UID}->{$namespace0}) {
                    my $uid0 = $entry->{UID}->{$namespace0};
                    $Map->{$namespace0}->{$namespace1}->{$uid0} = $username1;
                }
            }
        }
    }

    return $Map;
} # Read_User_Map

# ----------------------------------------------------------------------

# Given the name of an admin map file, reads it and returns a reference
# to a data structure containing the information from the file.
# This data structure can be used to determine whether a given user within
# a specified namespace is an admin (i.e., is allowed to request mappings
# on behalf of other users).
#
# Comments extend from a '#' character to the end of the line.
# Leading and trailing whitespace and blank lines are ignored.
# Each line consists of a single entry of the form "username@NAMESPACE"
# (e.g., "globus@SDSC" or "root@NCSA").
#
# The list of admins for the current namespace should match the list
# specified in the config file, but this is not currently enforced.
# 
# If an error occurs on the attempt to open the file, returns a
# string containing the error message (e.g., "No such file or directory").
# On a syntax error, returns a string with an error message.  Thus
# the "ref" operator can be used to determine whether the call was
# successful.
#
# The result is a reference to a hash.
# The keys are of the form "username@NAMESPACE".
# The values are 1 for valid administrators.
#
# (Future directions might include associating a range of timestamps with
# an entry, so a given user is considered an admin only over a specified
# range of time.)
#
sub Read_Admin_List($) {
    my($filename) = @_;
    my $Map = {};
    open MAP, $filename or return $!;
    while (<MAP>) {
        chomp;
        s/#.*$//;
        s/^\s*//;
        s/\s*$//;
        next if /^$/;
        if (/^\S+\@\S+$/) {
            $Map->{$_} = 1;
        }
        else {
            my $line = $.;
            close MAP;
            return "Syntax error on line $line";
        }
    }
    close MAP;
    return $Map;
} # Read_Admin_List

# ----------------------------------------------------------------------

#
# Given a string, possibly containing one or more certificate subject
# names, translates certain fields to be compatible with GT2 and
# OpenSSL 0.9.6.  The input string may consist of multiple lines.
# See <http://bugzilla.globus.org/bugzilla/show_bug.cgi?id=575>.
# 
sub GT2_Subject($) {
    my($string) = @_;
    $string =~ s(/0\.9\.2342\.19200300\.100\.1\.1=)(/USERID=)g;
    $string =~ s(/UID=)(/USERID=)g;
    $string =~ s(/emailAddress=)(/Email=)g;
    return $string;
} # GT2_Subject

# ----------------------------------------------------------------------

#
# Given a string, possibly containing one or more certificate subject
# names, translates certain fields to be compatible with GT3 and
# OpenSSL 0.9.7.  The input string may consist of multiple lines.
# See <http://bugzilla.globus.org/bugzilla/show_bug.cgi?id=575>.
# 
sub GT3_Subject($) {
    my($string) = @_;
    $string =~ s(/0\.9\.2342\.19200300\.100\.1\.1=)(/UID=)g;
    $string =~ s(/USERID=)(/UID=)g;
    $string =~ s(/Email=)(/emailAddress=)g;
    return $string;
} # GT3_Subject

# ----------------------------------------------------------------------

#
# Given a single DN, returns a list of one or two DNs for compatibility
# with both GT2 and GT3.
# 
sub DN_List($) {
    my $dn = $_[0];

    my $gt2_dn = GT2_Subject $dn;
    my $gt3_dn = GT3_Subject $dn;

    if ($gt2_dn eq $gt3_dn) {
        return ($gt2_dn);
    }
    else {
        return ($gt2_dn, $gt3_dn);
    }
} # DN_List

# ----------------------------------------------------------------------

#
# Given a hash reference, returns a list of one or two hash references
# based on applying DN_List to the 'dn' attribute (if any).  Note that
# if some fields are references, some of the referenced data may be
# shared between the two resulting references.
#
sub Dup_Ref($) {
    my ($ref) = @_;
    return $ref if not defined $ref->{dn};
    my @dn_list = DN_List $ref->{dn};
    return $ref if scalar @dn_list == 1;

    my %copy_of_hash = %$ref;
    my $new_ref = \%copy_of_hash;
    $ref->{dn}     = $dn_list[0];
    $new_ref->{dn} = $dn_list[1];
    return ( $ref, $new_ref );
} # Dup_Ref

# ----------------------------------------------------------------------

sub Die_Handler($) {
    if (defined $Gridmap_Utils::Registered_Handler_Function) {
        &$Gridmap_Utils::Registered_Handler_Function;
    }

    print STDERR $_[0];

    my @traceback = ();

    my $i = 0;
    while (1) {
        my @caller = caller $i;
        last if not @caller;
        push @traceback, { file    => $caller[1],
                           line    => $caller[2],
                           subname => $caller[3] };
        $i++;
    }

    print STDERR "Traceback:\n";
    for (my $i = 0; $i <= $#traceback; $i++) {
        my $curr = $traceback[$i];
        if ($i < $#traceback) {
            my $next = $traceback[$i+1];
            print STDERR "    $curr->{file}:$curr->{line} in ",
                         "$next->{subname}\n";
        }
        else {
            print STDERR "    $curr->{file}:$curr->{line}\n";;
        }
    }

    exit 1;
} # Die_Handler

# ----------------------------------------------------------------------

sub Install_Die_Handler() {
    $SIG{__DIE__} = \&Gridmap_Utils::Die_Handler;
} # Install_Die_Handler

# ----------------------------------------------------------------------

sub Install_Warn_Handler() {
    $SIG{__WARN__} = \&Gridmap_Utils::Die_Handler;
} # Install_Warn_Handler

# ----------------------------------------------------------------------

sub Register_Handler_Function($) {
    $Gridmap_Utils::Registered_Handler_Function = $_[0];
} # Register_Handler_Function

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $Debugging;
} # Debug   

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $Debugging; 
} # Debugf  

1;
