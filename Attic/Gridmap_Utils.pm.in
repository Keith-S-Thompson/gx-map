# $Id: Gridmap_Utils.pm.in,v 1.11 2003-07-17 03:14:40-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/Attic/Gridmap_Utils.pm.in,v $

package Gridmap_Utils;

################ Module Preamble ################

BEGIN {
    require 5.004;
    use vars qw($VERSION);
    $VERSION = "0.2";
    $Debugging = undef;
    use File::Basename ();
}

# ----------------------------------------------------------------------

sub Is_Tainted($);
sub Check_Tainting($$);
sub Untaint(\$);

sub Get_mtime($);
sub Get_PW(;$);
sub Get_GR(;$);
sub Get_Groups($);
sub Get_Hostname();

sub Is_Globus_Admin($);

sub Ensure_RCS();

sub Time_Image($);

sub Write_Records($@);
sub Read_Records($);

sub Valid_Mappings($);

sub Init_Cache_Info();
sub Cache_File($);

sub Debug(@);
sub Debugf(@);

# ----------------------------------------------------------------------

sub Is_Tainted($) {
    my($arg) = @_;
    my $nada = substr($arg, 0, 0);  # zero-length
    local $@;  # preserve caller's version
    eval { eval "# $nada" };
    return length($@) != 0;
} # Is_Tainted

# ----------------------------------------------------------------------

sub Check_Tainting($$) {
    my($name, $value) = @_;
    if (Is_Tainted $value) {
        die ">>> $name = \"$value\" is tainted\n";
    }
} # Check_Tainting

# ----------------------------------------------------------------------

sub Untaint(\$) {
    my($ref) = @_;
    ($$ref) = ($$ref =~ /(.*)/);
} # Untaint

# ----------------------------------------------------------------------

#
# If the named file exists, returns its mtime.
# If not, returns undef.
#
sub Get_mtime($) {
    my($filename) = @_;
    my @stat = stat $filename;
    if (@stat) {
        return $stat[9];
    }
    else {
        return undef;
    }
} # Get_mtime

# ----------------------------------------------------------------------

#
# A friendlier getpw* function
# Calls getpwent, getpwuid, or getpwnam depending on arguments (if any)
# Returns a hash reference; keys are 'name', 'passwd', etc.
# Returns undef on failure.
#
sub Get_PW(;$) {
    my $user = @_ ? $_[0] : undef;
    my @pw;
   
    if (not defined $user) {
        @pw = getpwent;
    }
    elsif ($user =~ /^\d+$/) {
        @pw = getpwuid($_[0]);
    }
    else {
        @pw = getpwnam($_[0]);
    }
    if (scalar @pw != 9) {
        return undef;
    }
    else {
        my $result;
        my @fields = qw(name passwd uid gid quota comment gcos dir shell);
        for (my $i = 0; $i <= $#fields; $i ++) {
            $result->{$fields[$i]} = $pw[$i];
        }
        return $result;
    }
} # Get_PW

# ----------------------------------------------------------------------

#
# A friendlier getgr* function
# Calls getgrent, getgruid, or getgrnam depending on arguments (if any)
# Returns a hash reference; keys are 'name', 'passwd', etc.
# 'members' is a ref to an array of member names
# Returns undef on failure.
#
sub Get_GR(;$) {
    my $group = @_ ? $_[0] : undef;
    my @gr;

    if (not defined $group) {
        @gr = getgrent;
    }
    elsif ($_[0] =~ /^\d+$/) {
        @gr = getgrgid($group);
    }
    else {
        @gr = getgrnam($group);
    }
    if (scalar @gr != 4) {
        return undef;
    }
    else {
        my $result;
        $result->{name}   = $gr[0];
        $result->{passwd} = $gr[1];
        $result->{gid}    = $gr[2];
        my @members = split / /, $gr[3];
        $result->{members} = \@members;
        return $result;
    }
} # Get_GR

# ----------------------------------------------------------------------

#
# Returns a list of the groups to which the specified user belongs.
# Groups are specified by name, not by number.
#
sub Get_Groups($) {
    my($user) = @_;
    my %is_member = ();
    my $pw = Get_PW($user);
    return () if not defined $pw;
    my $primary_gid = $pw->{gid};
    my $primary_group = Get_GR $primary_gid;
    if (defined $primary_group) {
        $is_member{$primary_group->{name}} = 1;
    }

    setgrent;
    while (my $group = Get_GR()) {
        MEMBER:
        foreach my $member (@{$group->{members}}) {
            if ($member eq $pw->{name}) {
                $is_member{$group->{name}} = 1;
                last MEMBER;
            }
        }
    }
    endgrent;

    return sort keys %is_member;
} # Get_Groups

# ----------------------------------------------------------------------

#
# Return the current hostname, as a fully qualified domain name if
# possible.
#
sub Get_Hostname() {
    my $hostname   = undef;
    my $domainname = undef;

    chomp($hostname = `/bin/hostname 2>/dev/null`);

    if ($hostname =~ /\./) {
        #
        # hostname returned an FQDN; return it
        #
        return $hostname;
    }

    open FILE, '/etc/resolv.conf' or return $hostname;
    LINE:
    while (<FILE>) {
        chomp;
        my @fields = split;
        if (scalar @fields == 2 and $fields[0] eq 'domain'
            or
            scalar @fields >= 2 and $fields[0] eq 'search')
        {
            $domainname = $fields[1];
            last LINE;
        } 
    } 
    close FILE;

    if (defined $domainname) {
        return "$hostname.$domainname";
    }
    else {       
        #
        # Punt.
        #
        return $hostname;
    }
} # Get_Hostname

# ----------------------------------------------------------------------

my %is_globus_admin = (); # cache for Is_Globus_Admin function

sub Is_Globus_Admin($) {
    my($user) = @_;
    my $admins = '%GLOBUS_ADMINS%';

    Debug ">>> Is_Globus_Admin \"$user\"\n";
    if (exists $is_globus_admin{$user}) {
        Debug "    value is cached\n";
    }
    if (not exists $is_globus_admin{$user}) {
        ENTRY:
        foreach my $entry (split /\s+/, $admins) {
            if ($entry =~ /^user:(.*)$/) {
                if ($1 eq $user) {
                    Debug "    Yes for user $user\n";
                    return ($is_globus_admin{$user} = 1);
                }
            }
            elsif ($entry =~ /^group:(.*)$/) {
                my $group = $1;
                foreach my $gr (Get_Groups $user) {
                    if ($gr eq $group) {
                        Debug "    Yes for group $group\n";
                        return ($is_globus_admin{$user} = 1);
                        last ENTRY;
                    }
                }
            }
        }
        Debug "    No\n";
        return ($is_globus_admin{$user} = 0);
    }

    Debug "Returning $is_globus_admin{$user}\n";
    return $is_globus_admin{$user};
} # Is_Globus_Admin

# ----------------------------------------------------------------------

#
# Ensure that the RCS commands co, ci, and rcs are available in $PATH.
# Assumes they're all in the same directory, either already in $PATH
# or in /usr/local/bin.
#
sub Ensure_RCS() {
    my @path = split /:/, $ENV{PATH};
    foreach my $dir (@path) {
        if (-x "$dir/co" and -x "$dir/ci" and -x "$dir/rcs") {
            return;
        }
    }
    if (-x "/usr/local/bin/co" and
        -x "/usr/local/bin/ci" and
        -x "/usr/local/bin/rcs")
    {
        $ENV{PATH} = "/usr/local/bin:$ENV{PATH}";
    }
    else {
        die "Can't find RCS commands\n";
    }
} # Ensure_RCS

# ----------------------------------------------------------------------

#
# For a given time, returns a string of the form
#     "ssssssssss YYYY-MM-DD hh:mm:ss UTC"
# where "ssssssssss" is the raw Unix timestamp.
#
sub Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime $time;

    return sprintf "%010d %s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   $time,
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec;
}

# ----------------------------------------------------------------------

#
# Given a file name and a list of records, write a text representation
# of the records to the file.  The file is created if it doesn't already
# exist; the records are then appended to the file.
#
# Each record is a reference to a hash, where the keys are field names.
#
sub Write_Records($@) {
    my($filename, @refs) = @_;
    return if not @refs;

    my $output = "";

    foreach my $ref (@refs) {
        $output .= "{\n";

        my $max_key_len = 0;
        foreach my $key (keys %$ref) {
            $max_key_len = length $key if length $key > $max_key_len;
        }

        foreach my $key (sort keys %$ref) {
            $output .= sprintf "\t%-${max_key_len}s  %s\n",
                               $key, $ref->{$key};
        }

        $output .= "}\n\n";
    }

    open FILE, ">>$filename" or die "${filename}: $!\n";
    print FILE $output or die "printing to ${filename}: $!\n";
    close FILE or die "closing ${filename}: $!\n";
} # Write_Records

# ----------------------------------------------------------------------

#
# Given a file name, reads (zero or more) records from the file and
# returns them in a list.
#
sub Read_Records($) {
    my ($filename) = @_;
    open FILE, $filename or die "${filename}: $!\n";
    my @result = ();
    my $ref = undef;
    LINE:
    while (<FILE>) {
        chomp;
        s/^\s+//;
        s/\s+$//;
        next LINE if $_ eq '';
        if (defined $ref) {
            if ($_ eq '}') {
                push @result, $ref;
                undef $ref;
            }
            elsif (/(\w+)\s+(.*)$/) {
                my($key, $value) = ($1, $2);
                if (defined $ref->{$key}) {
                    die "Duplicate key $key at line $. of $filename\n";
                }
                $ref->{$key} = $value;
            }
        }
        else {
            #
            # Allow comments between records, not within them.
            #
            next LINE if /^#/;
            if ($_ eq '{') {
                $ref = {};
            }
            else {
                die "Syntax error (expected '{' or EOF) " .
                    "at line $. of $filename\n";
            }
        }
    }
    return @result;
} # Read_Records

# ----------------------------------------------------------------------

#
# Given a reference to a request record, returns a list of references
# to hashes specifying valid mappings, where each hash has keys "dn" and
# "map_to_name".  Both keys are optional; at least one will always be set.
# (For "add" and "remove" operations, both "dn" and "map_to_name" are set;
# for "remove-dn" only "dn" is set; for "remove-user" only "map_to_name"
# is set.)  If there are no valid mappings, an empty list is returned.
#
# This function is intended to be customized for each installation.
# In particular, the check for the NAMESPACE field will almost certainly
# need to be modified.
#
# The most basic implementation returns a single mapping if the
# map_to_name field (if set) is a valid account on this system, the
# OWNER_NAME field either matches map_to_name (if set) or is a Globus
# administrator, and the NAMESPACE field is correct.  If the map_to_name
# field is not set (for a remove-dn operation), the OWNER_NAME field
# must be a Globus administrator.
#
# A more sophisticated implementation might refer to a user database,
# map to a local user derived from a (possibly remote) user name in the
# record, confirm that the dn corresponds to a recognized CA, return
# multiple mappings (see Globus Bugzilla # 575) and so forth.
#
sub Valid_Mappings($) {
    my($request) = @_;

    Debug ">>> Entering Valid_Mappings\n";
    Debug "    operation = $request->{operation}\n";
    Debug "    dn = ", (exists $request->{dn} ? $request->{dn} : 'undef'), "\n";
    Debug "    map_to_name = ",
          (exists $request->{map_to_name} ? $request->{map_to_name} : 'undef'),
          "\n";

    if (not defined $request->{OWNER_NAME}) {
        Debug ">>> Invalid, no OWNER_NAME\n";
        return ();
    }
    if (defined $request->{map_to_name} and
                not getpwnam $request->{map_to_name})
    {
        Debug ">>> Invalid, no such user\n";
        return ();
    }
    if (not defined $request->{NAMESPACE}) {
        Debug ">>> Invalid, no NAMESPACE\n";
        return ();
    }
    if ($request->{NAMESPACE} ne '%NAMESPACE%') {
        Debug ">>> Invalid, NAMESPACE ne '%NAMESPACE%'\n";
        return ();
    }
    if (exists $request->{map_to_name}) {
        if ($request->{OWNER_NAME} ne $request->{map_to_name} and
            not Is_Globus_Admin $request->{OWNER_NAME})
        {
            Debug ">>> Invalid, bad OWNER_NAME\n";
            return ();
        }
    }
    else {
        if (not Is_Globus_Admin $request->{OWNER_NAME}) {
            Debug ">>> Invalid, OWNER_NAME is not an admin\n";
            return ();
        }
    }

    my $mapping = {};
    if (defined $request->{dn}) {
        $mapping->{dn} = $request->{dn}
    }
    if (defined $request->{map_to_name}) {
        $mapping->{map_to_name} = $request->{map_to_name}
    }
    return ( $mapping );
} # Valid_Mappings

# ----------------------------------------------------------------------

my %Cache_File = ();
my $Download_Dir = "%INSTALL_DIR%/var/cache";
my $Download_Index = 0;

# ----------------------------------------------------------------------

sub Init_Cache_Info() {
    opendir DIR, $Download_Dir or die "$Download_Dir: $!\n";
    SUBDIR:
    foreach my $subdir (sort readdir DIR) {
        next SUBDIR if $subdir !~ /^\d+-\d+-\d+$/;
        open URL, "$Download_Dir/$subdir/.url" or next SUBDIR;
        my $url = <URL>;
        chomp $url;
        close URL;
        my $filename = "$Download_Dir/$subdir/" .
                       File::Basename::basename $url;
        Untaint $url;
        Untaint $filename;
        $Cache_File{$url} = $filename;
    }
    closedir DIR;
} # Init_Cache_Info

# ----------------------------------------------------------------------

#
# Given a URL, returns the name of a local file containing a copy of
# the specified file.  Uses the wget command.
#
# If the specified file has already been cached, we attempt to update it;
# if the update fails, we still return the name of the old cached file.
#
# The wget command sets the mtime of the local file to be the same as
# the modification time of the remote file.  The "-N" option says not
# to re-retrieve the file unless the remote file is newer than the
# local copy.
# 
#
sub Cache_File($) {
    my($url) = @_;
    Init_Cache_Info();
    my $initial_download = not defined $Cache_File{$url};

    if ($initial_download) {
        my $dir = "$Download_Dir/" . time . "-$$-$Download_Index";
        $Download_Index ++;
        mkdir $dir, 0777 or die "${dir}: $!\n";
        my $cache_file = "$dir/" . File::Basename::basename $url;
        my $result = system '%WGET%',
                            '-o', '/dev/null',
                            '-O', $cache_file,
                            $url;
        if ($result == 0) {
            open URL, ">$dir/.url" or die "$dir/.url: $!\n";
            print URL "$url\n";
            close URL;
            $Cache_File{$url} = $cache_file;
        }
        else {
            unlink $cache_file;
            rmdir $dir;
            die "wget failed for $url, system() returned $result\n";
        }
    }
    else {
        #
        # Try to refresh the file.
        #
        my $result = system '%WGET%',
                            '-N',
                            '-o', '/dev/null',
                            '-O', $Cache_File{$url},
                            $url;
        #
        # Ignore errors; we already have a copy of the file.
        #
    }
    return $Cache_File{$url};
} # Cache_File

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $Debugging;
} # Debug   

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $Debugging; 
} # Debugf  

1;
