#!%PERL% -w

# $Id: gx-request.in,v 1.49 2006-09-12 18:11:04-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-request.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2006 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Advanced Cyberinfrastructure
# Laboratory at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use Getopt::Long ();

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

my $Default_Data_Dir = "$Install_Dir/gx-map-data";

sub Usage(@);
sub Long_Usage();
sub Strip($);
sub Get_Options_Interactively();
sub Get_Options_From_Command_Line();
sub Request_Update();
sub Get_DN_From_Certificate($);
sub Proxy_File_Name();
sub User_Cert_File_Name();
sub Gen_Request_File_Name($);
sub Clone($);
sub Unique(@);
sub Die_Quietly(@);
sub Debug(@);
sub Debugf(@);

my $Program_Name = File::Basename::basename $0;
my $hostname;
my $Now = Gridmap_Utils::Get_Time_Of_Day;
my $proxy_file        = Proxy_File_Name;
my $user_cert_file    = User_Cert_File_Name;
my $default_cert_file =
    defined $proxy_file     ? $proxy_file     :
    defined $user_cert_file ? $user_cert_file :
    undef;

if ($Program_Name eq 'gx-request') {
    # ok
}
elsif ($Program_Name eq 'gx-map') {
    print ">>> The name \"gx-map\" for this client program is obsolescent.\n";
    print "    It works for now, but will be disabled in a future release.\n";
    print "    Use \"gx-request\" instead.\n";
}
else {
    print ">>> Unexpected program name \"$Program_Name\".\n";
    print "    Expected \"gx-request\".\n";
}

#
# There are three variables dealing with command-line options.
#
# @Opts is an array that is passed to Getopt::Long::GetOptions;
# it defines what command-line options are recognized.
#
# $User_Opt is a hash reference; the hash is filled in by
# Getopt::Long::GetOptions, and contains information about any
# command-line arguments that were actually given.  The field names are
# simply the names of the command-line options.  Multi-word field names
# are punctuated with hyphens, matching the command-line syntax.
#
# $Options is also a hash reference; the hash contains the information
# necessary to perform the specified operation.  This can be set either
# from command-line options or interactively.
#
# Fields are:
#    operation (one of add, remove, remove-dn, remove-user, set, update)
#    username
#    dn (an array)
#    email (optional)
#    comment (optional)
# Plus the following flags:
#    interactive
#    quiet
#    force
#

my $User_Opt = { dn => [] };
my @Opts = ( $User_Opt,
             qw( help long-help version
                 interactive
                 quick-add quick-remove
                 add
                 remove remove-dn remove-user
                 update
                 quiet force no-admin
                 dn=s@ certificate-file=s default-dn
                 username=s
                 directory=s
                 email=s
                 force-dn no-email comment=s
                 source=s
                 debugging ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;
Long_Usage if $User_Opt->{'long-help'};

if ($User_Opt->{version}) {
    print "$Program_Name (gx-map) $Gridmap_Utils::VERSION\n";
    exit 0;
}

$Gridmap_Utils::Debugging = 1 if $User_Opt->{debugging};

#
# The -quick-add option is mapped to -add -default-dn
# The -quick-remove option is mapped to -remove -default-dn
#
if (defined $User_Opt->{'quick-add'} or
    defined $User_Opt->{'quick-remove'})
{
    if (defined $User_Opt->{'quick-add'} and
        defined $User_Opt->{'quick-remove'})
    {
        Usage "The -quick-add and -quick-remove options " .
              "cannot be used together\n";
    }
    my $opt = defined $User_Opt->{'quick-add'} ? 'quick-add' : 'quick-remove';
    my $conflict = 0;
    foreach my $other_opt ( qw( interactive add remove remove-dn
                                remove-user set update default-dn
                                certificate-file dn-list-file ) )
    {
        if (defined $User_Opt->{$other_opt}) {
            $conflict = 1;
        }
    }
    if (scalar @{$User_Opt->{dn}} > 0) {
        $conflict = 1;
    }
    if ($conflict) {
        Usage "The $opt option cannot be used with other options\n";
    }
    $User_Opt->{'default-dn'} = 1;
    if ($opt eq 'quick-add') {
        $User_Opt->{add} = 1;
    }
    else {
        $User_Opt->{remove} = 1;
    }
}

Gridmap_Utils::Check_Data_Dir;

Gridmap_Utils::Install_Die_Handler;
Gridmap_Utils::Install_Warn_Handler;

#
# First, gather and verify some basic information about the user.
#
if ($< != $>) {
    die "Real UID ($<) != effective UID ($>)\n";
}

#
# $PW is a reference to the password information (name, uid, etc)
# of the user running this command.
#
my $PW = Gridmap_Utils::Get_PW $<;

if ($PW->{uid} != $<) {
    die "Internal error, uid from passwd ($PW->{uid}) != real uid ($<)\n";
}

#
# $Is_Admin is true if the user running the command is an authorized
# gx-map administrator and has not specified the "-no-admin" command-line
# option.
#
my $Is_Admin = (not $User_Opt->{'no-admin'} and
                Gridmap_Utils::Is_Admin_Account $PW->{name});
my $Options  = {};

if ($User_Opt->{interactive}) {
    $Options = Get_Options_Interactively();
}
else {
    $Options = Get_Options_From_Command_Line();
}

Debug "Options =>\n";
foreach my $key (sort keys %$Options) {
    Debug "    $key => $Options->{$key}\n";;
}

my $Requests_Dir = "$Options->{directory}/new-requests";

Die_Quietly "No directory $Options->{directory}\n"
    if not -d $Options->{directory};

Die_Quietly "No directory $Requests_Dir\n" if not -d $Requests_Dir;

Die_Quietly "Directory $Requests_Dir is not writable\n"
    if not -w $Requests_Dir;

if ($Options->{operation} eq 'update') {
    Request_Update();
    exit 0;
}

if (( $Options->{operation} eq 'add' or
      $Options->{operation} eq 'remove' or
      $Options->{operation} eq 'remove-user' or
      $Options->{operation} eq 'set' )
    and not defined $Options->{username})
{
    if ($Is_Admin) {
        Usage "No username specified\n";
    }
    else {
        $Options->{username} = $PW->{name};
    }
}

if ( $Options->{operation} eq 'add' or
     $Options->{operation} eq 'remove' or
     $Options->{operation} eq 'remove-dn' )
{
    if (scalar @{$Options->{dn}} == 0) {
        Usage "No DN specified\n";
    }
    elsif (scalar @{$Options->{dn}} > 1) {
        Usage "Cannot specify multiple DNs\n";
    }
}

{
    my @errors = ();
    foreach my $dn (@{$Options->{dn}}) {
        my @args = ();
        push @args, '-check-syntax' if not defined $Options->{'force-dn'};
        push @args, $dn;
        my $dn_error = Gridmap_Utils::DN_Error @args;
        if (defined $dn_error) {
            push @errors, "Invalid DN \"$dn\"\n";
            push @errors, "$dn_error\n";
        }
    }
    Usage @errors if @errors;
}

#
# Disallow non-printing characters that may corrupt the request file.
#
if (defined $Options->{email}) {
    $Options->{email} =~ s/[^ -~]/?/g;
}
if (defined $Options->{comment}) {
    $Options->{comment} =~ s/[^\t -~]/?/g;
}

Debug "Options =>\n";
foreach my $key (sort keys %$Options) {
    Debug "    $key => $Options->{$key}\n";;
}

#
# The operation is either 'add', 'remove', 'remove-dn', 'remove-user',
# or 'set'.
#

my $requested_pw;
if ($Options->{operation} ne 'remove-dn') {
    if ($Options->{username} eq $PW->{name}) {
        $requested_pw = $PW;
    }
    else {
        #
        # Note: For an ordinary user, I need to validate the passwd
        # information.  If a gx-map administrator runs this command,
        # it may be for an account that doesn't exist on this machine;
        # it may not be possible to determine the uid.
        #
        $requested_pw = Gridmap_Utils::Get_PW $Options->{username};
        if (defined $requested_pw and
            $requested_pw->{name} ne $Options->{username})
        {
            die "Internal error, name from passwd ($requested_pw->{name}) != ",
                "specified name ($Options->{username})\n";
        }
    }
}

#
# Translate the DN(s) to the proper form.
# Strip trailing components from a proxy DN.
# Translate to the newer GT3/GT4 form.
#
foreach my $dn (@{$Options->{dn}}) {
    $dn = Gridmap_Utils::Normalize_DN $dn;
}

my @dn_list = Unique @{$Options->{dn}};

if (not $Options->{quiet}) {
    $| = 1;
    my $Mapping  = ( $Options->{force} ? 'Mapping'  : 'About to map' );
    my $Removing = ( $Options->{force} ? 'Removing' : 'About to remove' );
    my $Setting  = ( $Options->{force} ? 'Setting'  : 'About to set' );
    if ($Options->{operation} eq 'set') {
        print "$Setting DN(s) for user\n",
              "    $Options->{username}\n",
              "to\n";
        if (scalar @{$Options->{dn}} == 0) {
            print "    empty list\n";
        }
        else {
            foreach my $dn (@dn_list) {
                print "    $dn\n";
            }
        }
    }
    elsif ($Options->{operation} eq 'add') {
        print "$Mapping distinguished name\n",
              "    \"$dn_list[0]\"\n",
              "to user\n",
              "    $Options->{username}\n";
    }
    elsif ($Options->{operation} eq 'remove') {
        print "$Removing mapping for distinguished name\n",
              "    \"$dn_list[0]\"\n",
              "to user\n",
              "    $Options->{username}\n";
    }
    elsif ($Options->{operation} eq 'remove-dn') {
        print "$Removing all mappings for distinguished name\n",
              "    \"$dn_list[0]\"\n";
    }
    elsif ($Options->{operation} eq 'remove-user') {
        print "$Removing all mappings for user $Options->{username}\n";
    }
}
if (not $Options->{force}) {
    PROMPT:
    while (1) {
        print "Proceed? [yn] ";
        my $response = lc scalar <STDIN>;
        chomp $response;
        if ($response =~ /^y/) {
            last PROMPT;
        }
        elsif ($response =~ /^n/) {
            Die_Quietly "Request cancelled\n";
        }
        else {
            print "Unrecognized input\n";
        }
    }
}

$hostname = Gridmap_Utils::Get_Hostname();

my $Timestamp = Gridmap_Utils::Long_Time_Image $Now;
my $requested_uid = undef;
if (defined $requested_pw) {
    $requested_uid = $requested_pw->{uid};
}

if ((defined $Options->{username} and $Options->{username} eq 'root')
    or
    (defined $requested_uid and $requested_uid == 0))
{
    Die_Quietly "Mapping to root or uid 0 is not allowed\n";
}

my $request = {
    operation         => $Options->{operation},
    timestamp         => $Timestamp,
    requested_by_uid  => $PW->{uid},
    requested_by_name => $PW->{name},
    hostname          => $hostname
};
if (defined $Options->{dn}) {
    $request->{dn} = $Options->{dn};
    map { $_ = "\"$_\"" } @{$request->{dn}};
}
$request->{username} = $Options->{username} if defined $Options->{username};
$request->{user_uid} = $requested_uid       if defined $requested_uid;
$request->{email}    = $Options->{email}    if defined $Options->{email};
$request->{comment}  = $Options->{comment}  if defined $Options->{comment};
$request->{source}   = $Options->{source}   if defined $Options->{source};

#
# A 'set' request is expanded to a 'remove-user' request
# followed by zero or more 'add' requests.  No 'set' request
# will actually be written to a file.
#
if ($Options->{operation} eq 'set') {
    $request->{operation} = 'remove-user';
    delete $request->{dn};
}

my @requests = ( $request );

my $previous_timestamp = $Timestamp;
if ($Options->{operation} eq 'set') {
    foreach my $dn (@dn_list) {
        my $add_request = Clone $request;
        $add_request->{operation} = 'add';
        $add_request->{dn} = "\"$dn\"";

        my $new_timestamp = Gridmap_Utils::Long_Time_Image
                                Gridmap_Utils::Get_Time_Of_Day;
        if ($new_timestamp eq $previous_timestamp) {
            $new_timestamp = Gridmap_Utils::Increment_Timestamp $new_timestamp;
        }
        $add_request->{timestamp} = $new_timestamp;
        $previous_timestamp = $new_timestamp;

        push @requests, $add_request;
    }
}

my $index = 0;

foreach my $request (@requests) {
    #
    # If gx-check-requests sees a partial request file, it will reject it
    # and move it to the bad-requests directory.  To avoid this, create
    # a temporary request file with a name ending in ".tmp" (making it
    # invisible to gx-check-requests).  After the temporary file is created
    # and has the proper permissions, rename it to the correct name.
    #
    my $request_file = Gen_Request_File_Name $request->{timestamp};
    my $tmp_file = $request_file . ".tmp";
    Gridmap_Utils::Write_Records '-single', $tmp_file, $request;
    chmod 0444, $tmp_file;
    rename $tmp_file, $request_file;
}

unless ($Options->{force} and $Options->{quiet}) {
    print "Mapping request submitted.\n";
    print "The grid-mapfile should be updated in a few minutes\n";
}

########################################################################

#
# Given a certificate file name, invokes openssl to determine the subject
# name and returns the resulting DN.
# 
# The output must be a single line starting with '/'.
#
# If an error occurs, return a brief description of the error.  This can
# be distinguished from a valid DN by the absence of a leading '/'.
# (Not pretty, but it works.)
#
sub Get_DN_From_Certificate($) {
    my($file) = @_;
    return "No file $file"     if not -e $file;
    return "Cannot read $file" if not -r $file;

    Gridmap_Utils::Use_Commands 'openssl';

    #
    # We deliberately don't bother checking for errors.  If we get the
    # expected output, we use it; if not, we don't bother to distinguish
    # the reason we couldn't execute the command.
    #
    open my $Pipe, '-|', "openssl x509 -in '$file' -noout -subject 2>/dev/null";
    my @output = <$Pipe>;
    close $Pipe;

    return "Missing or bad output from openssl for $file"
        if scalar @output != 1;
    my $line = $output[0];
    chomp $line;
    return "Unrecognized output from openssl for $file"
        if $line !~ /^subject=/;
    $line =~ s/^subject=\s*//;
    return "Bad DN from openssl for $file" if $line !~ /^\//;
    return $line;
} # Get_DN_From_Certificate

# ----------------------------------------------------------------------

sub Proxy_File_Name() {
    if (defined $ENV{X509_USER_PROXY} and -r $ENV{X509_USER_PROXY}) {
        return $ENV{X509_USER_PROXY};
    }
    elsif (-r "/tmp/x509up_u$>") {
        return "/tmp/x509up_u$>";
    }
    else {
        return undef;
    }
} # Proxy_File_Name

# ----------------------------------------------------------------------

sub User_Cert_File_Name() {
    if (defined $ENV{X509_USER_CERT} and -r $ENV{X509_USER_CERT}) {
        return $ENV{X509_USER_CERT};
    }
    elsif (-r "$ENV{HOME}/.globus/usercert.pem") {
        return "$ENV{HOME}/.globus/usercert.pem";
    }
    else {
        return undef;
    }
} # User_Cert_File_Name

# ----------------------------------------------------------------------

sub Gen_Request_File_Name($) {
    my($timestamp) = @_;
    my $result = "$Requests_Dir/";
    $timestamp =~ s/ .*$//;
    $result .= $timestamp;
    $result .= "-$hostname-$PW->{name}";
    if (defined $Options->{username} and
        $Options->{username} ne $PW->{name})
    {
        $result .= "_$Options->{username}";
    }
    $result .= "-$$.request";
    return $result;
} # Gen_Request_File_Name

# ----------------------------------------------------------------------

#
# Always reject non-printable characters and '"' characters.
# If "-force-dn" option was not specified, do a minimal syntax check.
#
sub Is_Valid_DN($) {
    my($DN) = @_;

    return 0 if $DN !~ /^[ -~]*$/;
    return 0 if $DN =~ /"/;
    return 0 if defined $Options->{'force-dn'} and
                $DN !~ m<^(/[^/=]+=[^=]+)+$>;
    return 1;
} # Is_Valid_DN

# ----------------------------------------------------------------------

#
# Request an update of the grid-mapfiles.
# Append a line of information to the requests/.update file.
# gx-gen-mapfile will check the timestamp of this file; if it's
# later than any of its output files, it will re-generate them.
#
sub Request_Update() {
    my $request_file = "$Requests_Dir/.update";
    my $PW = Gridmap_Utils::Get_PW $<;
    my $hostname = Gridmap_Utils::Get_Hostname();
    my $timestamp = Gridmap_Utils::Long_Time_Image $Now;
    my $info = "Update requested by $PW->{name} on $hostname at $timestamp\n";

    open my $Request, '>>', $request_file or die "$request_file: $!\n";
    print $Request $info;
    close $Request;
    if (not $Options->{quiet}) {
        print "Request processed.\n";
        print "The grid-mapfile should be updated within a few minutes.\n";
    }
} # Request_Update

# ----------------------------------------------------------------------

#
# For use with here documents (<<"EOF")
#
sub Strip($) {
    my($s) = @_;

    $s =~ s/^\s*> ?//gm;
    return $s;
} # Strip

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $User_Opt->{debugging};
} # Debugf

# ----------------------------------------------------------------------

sub Get_Options_Interactively() {
    $| = 1;

    my $Options = {};

    my $response;

    $Options->{interactive} = 1;

    print Strip <<"EOF";
    > The $Program_Name command lets you submit a request to modify the
    > Globus grid-mapfile(s) on one or more machines.  Once the request
    > is submitted, the updates should occur within a few minutes.
    > 
    > A grid-mapfile entry maps a DN (Distinguished Name) to a Unix
    > user name.  For example, an entry like
    >     "/O=Big University/OU=Small Department/CN=John Doe" jdoe
    > allows a user holding a Globus certificate with the specified
    > DN to run Globus jobs under the Unix account "jdoe".
    > 
    > $Program_Name can be run interactively or with command-line arguments.
    > 
    > In this interactive mode, you will be asked a series of questions.
    > Enter your responses followed by <return>.
    > 
    > Single-letter menu responses are case-insensitive; other responses
    > must be entered exactly.
    > 
    > If there is a default response indicated by the prompt, you can
    > enter it by just typing <return>.
EOF

    #
    # Get the operation
    #
    while (not defined $Options->{operation}) {
        print Strip <<"EOF";
        > 
        > (a) Add a grid-mapfile entry
        > (r) Remove a grid-mapfile entry
        > (u) Request an update of the grid-mapfiles
        > (x) Exit
        > (The "set" operation is not currently available in interactive mode.)
EOF
        print "What do you want to do? [arux] ";
        chomp($response = lc scalar <STDIN>);
        if ($response =~ /^a/) {
            $Options->{operation} = 'add';
        }
        elsif ($response =~ /^r/) {
            $Options->{operation} = 'remove';
        }
        elsif ($response =~ /^u/) {
            $Options->{operation} = 'update';
        }
        elsif ($response =~ /^x/) {
            exit 0;
        }
        else {
            print ">>> Unrecognized response\n";
        }
    }

    my $OP = $Options->{operation}; # just a convenient abbreviation

    if ($Is_Admin) {
        while (not defined $Options->{directory}) {
            print "Data directory (default is $Default_Data_Dir): ";
            chomp($response = scalar <STDIN>);
            if ($response eq '') {
                $Options->{directory} = $Default_Data_Dir;
            }
            elsif (not -e $response) {
                print ">>> $response does not exist\n";
            }
            elsif (not -d _) {
                print ">>> $response is not a directory\n";
            }
            elsif (not -r $response or not -x _ or not -w _) {
                print ">>> Insufficient access to directory $response\n";
            }
            else {
                $Options->{directory} = $response;
            }
        }
    }
    else {
        $Options->{directory} = $Default_Data_Dir;
    }

    if ($Is_Admin) {
        undef $response;
        while (not defined $response) {
            print "Source (default is none): ";
            chomp($response = scalar <STDIN>);
            $response =~ s/^\s*//;
            $response =~ s/\s*$//;
            if ($response =~ /^[A-Za-z0-9._-]*$/) {
                #
                # Leave "source" undefined if it's not specified
                # (no default).  It will be set to "USER" by
                # gx-check-requests.
                #
                $Options->{source} = $response if $response ne '';
            }
            else {
                print ">>> Invalid value (use only [A-Za-z0-9._-])\n";
                undef $response;
            }
        }
    }

    if ($OP eq 'remove') {
        TRY:
        while (1) {
            print "\n";
            if ($Is_Admin) {
                print Strip <<"EOF";
                > (d) Remove all mappings for a specified DN
                > (u) Remove all mappings for a specified user name
                > (m) Remove mapping for a specified DN and user name
                > (x) Exit
EOF
                print "Remove? [dumx] ";
            }
            else {
                print Strip <<"EOF";
                > (u) Remove all mappings for your user name
                > (m) Remove mapping for a specified DN and your user name
                > (x) Exit
EOF
                print "Remove? [umx] ";
            }
            chomp($response = lc scalar <STDIN>);
            if ($Is_Admin and $response =~ /^d/) {
                $OP = $Options->{operation} = 'remove-dn';
                last TRY;
            }
            elsif ($response =~ /^u/) {
                $OP = $Options->{operation} = 'remove-user';
                last TRY;
            }
            elsif ($response =~ /^m/) {
                $OP = $Options->{operation} = 'remove';
                last TRY;
            }
            elsif ($response =~ /^x/) {
                exit 0;
            }
            else {
                print ">>> Unrecognized response\n";
            }
        }
    }

    #
    # For update, no further information is needed, but ask the
    # user whether that's really what he wants to do.
    #
    if ($Options->{operation} eq 'update') {
        print Strip <<"EOF";
        > 
        > This will request an update of all grid-mapfiles the next
        > time gx-check-requests is run.  Normally updates are handled
        > automatically, so this is not usually necessary.
        > 
EOF
        while (1) {
            print "Proceed? [yn] ";
            $response = lc scalar <STDIN>;
            if ($response =~ /^y/) {
                return $Options;
            }
            elsif ($response =~ /^n/) {
                exit 0;
            }
            else {
                print ">>> Unrecognized response\n";
            }
        }
    }

    #
    # For other operations, collect more information.
    #
    else {
        my $what;
        if    ($OP eq 'add')     { $what = 'map' }
        elsif ($OP =~ /^remove/) { $what = 'unmap' }
        else                     { die "Internal error" }

        #
        # Get user name if needed
        #
        my $need_user_name = 0;
        if ($Is_Admin and $OP ne 'remove-dn') {
            $need_user_name = 1;
        }
        else {
            $Options->{username} = $PW->{name};
        }

        if ($need_user_name) {
            while (not defined $Options->{username}) {
                if ($PW->{name} eq 'root') {
                    print "What user name do you want to $what? ";
                }
                else {
                    print "What user name do you want to $what ",
                          "(default is $PW->{name}) ? ";
                }
                chomp($response = scalar <STDIN>);
                $response =~ s/^ *//;
                $response =~ s/ *$//;
                if ($response eq '') {
                    if ($PW->{name} ne 'root') {
                        $Options->{username} = $PW->{name};
                    }
                }
                else {
                    $Options->{username} = $response;
                }
            }
        }
        else {
            $Options->{username} = $PW->{name};
        }

        #
        # Get DN
        #
        if ($OP ne 'remove-user') {
            my $choices = '';
            $choices .= 'c' if defined $user_cert_file;
            $choices .= 'p' if defined $proxy_file;
            $choices .= 'fix';
            my $dn = undef;
            my $cert_file = undef;
            while (not defined $dn) {

                print Strip <<"EOF";
                > 
                > You can specify the DN in one of the following ways:
EOF

                print Strip <<"EOF" if defined $user_cert_file;
                > (c) Certificate, extract from $user_cert_file
EOF

                print Strip <<"EOF" if defined $proxy_file;
                > (p) Proxy, extract from your current proxy certificate,
                >     $proxy_file
EOF

                print Strip <<"EOF";
                > (f) File, extract from a specified certificate file
EOF

                print Strip <<"EOF";
                > (i) Input the DN directly
                > (x) Exit
EOF

                print "How do you want to specify the DN? [$choices] ";
                chomp($response = lc scalar <STDIN>);

                if (defined $user_cert_file and $response =~ /^c/) {
                    $cert_file = $user_cert_file;
                }
                elsif (defined $proxy_file and $response =~ /^p/) {
                    $cert_file = $proxy_file;
                }
                elsif ($response =~ /^f/) {
                    print "Enter certificate file name: ";
                    chomp($cert_file = scalar <STDIN>);
                }
                elsif ($response =~ /^i/) {
                    print "Enter distinguished name: ";
                    chomp($dn = scalar <STDIN>);
                    $dn =~ s/^"//;
                    $dn =~ s/"$//;
                    $dn = Gridmap_Utils::Normalize_DN $dn;
                }
                elsif ($response =~ /^x/) {
                    exit 0;
                }
                else {
                    print ">>> Unrecognized input\n";
                }

                if (defined $cert_file) {
                    $dn = Get_DN_From_Certificate $cert_file;
                    if ($dn =~ /^\//) {
                        $dn = Gridmap_Utils::Normalize_DN $dn;
                        print "DN is \"$dn\"\n";
                    }
                    else {
                        #
                        # Get_DN_From_Certificate returned an error message.
                        #
                        print "$dn\n";
                        undef $dn;
                        undef $cert_file;
                    }
                }
            }

            $Options->{dn} = [ $dn ];
        }

        #
        # Get e-mail address
        #
        print Strip <<"EOF";
        > 
        > You may provide your e-mail address if you wish.
        > It will be recorded in the request log, and may be used
        > to contact you if there is a problem with your certificate.
EOF
        print "E-mail address (<return> for none): ";
        chomp($response = scalar <STDIN>);
        $response =~ s/^\s*//;
        $response =~ s/\s*$//;
        if ($response ne '') {
            $Options->{email} = $response;
        }

        #
        # Get comment
        #
        print Strip <<"EOF";
        > 
        > You may provide an optional comment.
        > If you do, it will be recorded in the request log.
        > Press return if you don't wish to provide a comment.
EOF
        print "Comment: ";
        chomp($response = scalar <STDIN>);
        $response =~ s/^\s*//;
        $response =~ s/\s*$//;
        if ($response ne '') {
            $Options->{comment} = $response;
        }
    }
    print "\n";

    return $Options;
} # Get_Options_Interactively

# ----------------------------------------------------------------------

sub Get_Options_From_Command_Line() {
    my $Options = {};

    my @operations = ();
    foreach my $op (qw(add remove remove-dn remove-user set update))
    {
        push @operations, $op if $User_Opt->{$op};
    }

    if (scalar @operations == 0) {
        Usage "No operation specified\n";
    }
    elsif (scalar @operations == 1) {
        $Options->{operation} = $operations[0];
    }
    else {
        Usage "Specify only one of:\n",
              "    -add,\n",
              "    -remove, -remove-dn, -remove-user,\n",
              "    -set\n",
              "    -update\n";
    }

    my $OP = $Options->{operation}; # just a convenient abbreviation

    if (defined $User_Opt->{'dn-list-file'} and $OP ne 'set') {
        Usage "The \"-dn-list-file\" option can be used only with \"-set\"\n";
    }

    my @dn_list = @{$User_Opt->{dn}};
    if (defined $User_Opt->{'dn-list-file'}) {
        if (scalar @dn_list > 0) {
            Usage "The \"-dn\" and \"-dn-list-file\" options " .
                  "cannot be used together\n";
        }
        else {
            @dn_list = Gridmap_Utils::Get_DNs_From_List_File
                           $User_Opt->{'dn-list-file'};
        }
    }

    my $dn_count = scalar @dn_list +
                   (defined $User_Opt->{'certificate-file'} ? 1 : 0) +
                   (defined $User_Opt->{'default-dn'} ? 1 : 0);

    if ($OP eq 'set' and
        ( defined $User_Opt->{'certificate-file'} or
          defined $User_Opt->{'default-dn'} ))
    {
        Usage "Do not use \"-certificate-file\" or \"-default-dn\" " .
              "with \"-set\"\n";
    }
    elsif ($OP eq 'remove-dn' and defined $User_Opt->{username}) {
        Usage "Do not specify a user name with \"-$OP\"\n";
    }
    elsif ($OP eq 'remove-user' and $dn_count > 0) {
        Usage "Do not specify a DN or certificate file with \"$OP\"\n";
    }
    elsif ($OP eq 'add' or $OP eq 'remove' or $OP eq 'remove-dn') {
        if ($dn_count == 0) {
            Usage "No DN specified\n";
        }
        elsif ($dn_count > 1) {
            Usage "Multiple DNs may not be specified with \"-$OP\"\n";
        }
    }

    $Options->{'force-dn'} = 1 if $User_Opt->{'force-dn'};
    $Options->{quiet}      = 1 if $User_Opt->{quiet};
    $Options->{force}      = 1 if $User_Opt->{quiet} or $User_Opt->{force};

    if (defined $User_Opt->{directory}) {
        if ($Is_Admin) {
            $Options->{directory} = $User_Opt->{directory};
        }
        else {
            Usage "Only a gx-map administrator may specify a data directory\n"
        }
    }
    else {
        $Options->{directory} = $Default_Data_Dir;
    }

    if ($OP eq 'update') {
        return $Options;
    }

    if (defined $User_Opt->{source}) {
        if ($Is_Admin) {
            if ($User_Opt->{source} !~ /^[A-Za-z0-9._-]+$/) {
                Usage "Invalid argument to \"-source\" option\n";
            }
            $Options->{source} = $User_Opt->{source};
        }
        else {
            Usage "Only a gx-map administrator may specify a source\n"
        }
    }
    #
    # Leave "source" undefined if it's not specified (no default).
    # It will be set to "user" or "admin" by gx-check-requests.
    #

    if ($OP eq 'remove-dn' and not $Is_Admin) {
        Usage "Only a gx-map administrator may use the \"-remove-dn\" option\n";
    }

    if (defined $User_Opt->{username}) {
        if (not $Is_Admin and $User_Opt->{username} ne $PW->{name}) {
            Usage "You may not specify a user name other than your own\n";
        }
        $Options->{username} = $User_Opt->{username};
    }
    else {
        if ($OP ne 'remove-dn') {
            $Options->{username} = $PW->{name};
        }
    }

    if ($OP ne 'remove-user') {
        if (@dn_list or $OP eq 'set') {
            $Options->{dn} = \@dn_list;
        }
        else {
            my $cert_file;
            if (defined $User_Opt->{'default-dn'}) {
                if (defined $default_cert_file) {
                    $cert_file = $default_cert_file;
                }
                else {
                    Usage "Cannot determine name of default certificate\n";
                }
            }
            elsif (defined $User_Opt->{'certificate-file'}) {
                $cert_file = $User_Opt->{'certificate-file'};
            }
            else {
                if (defined $user_cert_file) {
                    $cert_file = $user_cert_file;
                }
                else {
                    Usage "Cannot determine name of user certificate\n";
                }
            }
            my $dn = Get_DN_From_Certificate $cert_file;
            if ($dn =~ /^\//) {
                #
                # Get_DN_From_Certificate returned a valid DN
                #
                $Options->{dn} = [ $dn ];
            }
            else {
                #
                # Get_DN_From_Certificate returned an error message
                #
                Usage "$dn\n";
            }
        }
    }

    if (defined $User_Opt->{email}) {
        $Options->{email} = $User_Opt->{email};
    }

    if (defined $User_Opt->{comment}) {
        $Options->{comment} = $User_Opt->{comment};
    }
    
    return $Options;
} # Get_Options_From_Command_Line

# ----------------------------------------------------------------------

#
# Given a hash reference, returns a new reference whose fields are copies
# of the original.  Used in expanding a 'set' request so we can
# generate a list of similar nodes.
#
sub Clone($) {
    my($ref) = @_;
    my $new_ref = {};
    foreach my $key (keys %$ref) {
        $new_ref->{$key} = $ref->{$key};
    }
    return $new_ref;
} # Clone

# ----------------------------------------------------------------------

#
# Given a list, returns a list with duplicate entries deleted.
#
sub Unique(@) {
    my %seen = ();
    my @result = ();
    foreach my $elem (@_) {
        push @result, $elem if not $seen{$elem}++;
    }
    return @result;
} # Unique

# ----------------------------------------------------------------------

#
# Die without invoking handler.
#
sub Die_Quietly(@) {
    #
    # This should be
    #     delete $SIG{__DIE__};
    # but that doesn't work properly in some versions of Perl.
    #
    $SIG{__DIE__} = sub { die @_ };  
    die @_;
} # Die_Quietly

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name [options]
Option names may be abbreviated.
    -help            : Show this message and exit.
    -version         : Show version information and exit.
    -quick-add       : Add a mapping for your current certificate.
                       Asks for verification before submitting request.
    -quick-remove    : Remove the mapping for your current certificate.
                       Asks for verification before submitting request.
    -interactive     : Run interactively.
                       In interactive mode, other options will be ignored.
    -long-help       : Show long usage message, explaining all
                       command-line options (recommended only for gx-map
                       administrators and masochists).
EOF
    exit 1;
} # Usage

# ----------------------------------------------------------------------

sub Long_Usage() {
    my $pager = defined $ENV{PAGER} ? $ENV{PAGER} : 'more';
    print <<"EOF";
Usage: $Program_Name [options]
Option names may be abbreviated.
    -help                   : Show a brief usage message and exit.
    -version                : Show version information and exit.
    -quick-add              : Add a mapping for your current certificate.
                              Equivalent to -add -default-dn.
    -quick-remove           : Remove the mapping for your current certificate.
                              Equivalent to -remove -default-dn.
    -interactive            : Run interactively.
    -long-help              : Show long usage message, explaining all
                              command-line options (recommended only
                              for gx-map administrators and masochists).
    -add                    : Add the specified mapping.
    -remove                 : Remove the specified mapping.
    -remove-dn              : Remove all mappings for the specified
                              distinguished name.  For use only by gx-map
                              administrators.
    -remove-user            : Remove all mappings for the specified user.
    -update                 : Request an update of all grid-mapfiles.
                              This normally isn't necessary, but it can be
                              useful if you already have a certificate and
                              get a new account on a machine.
Note: Exactly one of -interactive, -quick-add, -quick-remove,
      -add, -remove, -remove-dn, -remove-user, and -update
      (or -help, -usage, or -long-usage) must be specified.
------------------------------------------------------------------------
    -quiet                  : Work silently.
                              Implies -force.
    -force                  : Apply mapping without prompting.
                              Default is to ask for confirmation before
                              proceeding.
    -no-admin               : Assume the user is not a gx-map administrator.
                              Intended for testing only; has no effect if
                              you're not already a gx-map administrator.
    -dn "string"            : Distinguished name.
    -default-dn             : Extract DN from proxy or user certificate.
    -certificate-file file  : Name of file from which to extract DN.
    -force-dn               : Normally, gx-request (minimally) checks
                              the DN for proper syntax; this option
                              overrides that check.
    -username name          : Unix user name to map.
                              This option is for use by gx-map
                              administrators only.
    -directory dir          : Specify an alternate data directory.
                              This option is for use by gx-map administrators
                              only.
                              The default data directory is
                              $Default_Data_Dir .
    -email addr             : Your contact e-mail address (optional).
                              This may be used to contact you if there's
                              a problem with your certificate.
    -no-email               : Ignored (provided for compatibility with 0.3).
    -comment "string"       : Comment to be added to request log (optional)
    -source string          : Specify the source of the mapping.
                              Argument may consist only of letters, digits,
                              underscore, period, and hyphen characters
                              ([A-Za-z0-9_.-]).
                              This option is for use by gx-map administrators
                              only.
    -debugging              : Enable debugging output.
Note: If this help message has scrolled off the top of your screen, try
    $Program_Name -long-help | $pager
EOF
    exit 1;

#
# The "-set" option was added in release 0.5.1 and removed in 0.5.2.
# For now, the code that supports it is still here, but the command-line
# option is disabled.
#

#   -interactive            : Run interactively.
#                             The "set" operation is not currently
#                             available in interactive mode.
# ...
#   -set                    : Set mappings for the specified user,
#                             overriding any existing mappings.  Zero or
#                             more DNs may be specified.  This is
#                             equivalent to a "remove-user" request
#                             followed by zero or more "add" requests.
#                             The "-default-dn" and "-certificate-file" options
#                             cannot be used with "-set".  This operation
#                             is not available in "-interactive" mode.
# ...
#   -dn-list-file file      : Read a list of DNs from a specified text file,
#                             one DN per line.  Use "-dn-list-file -" to read
#                             from stdin.  This cannot be used with other
#                             DN options (-dn, -default-dn, -certificate-file),
#                             or with any operation other than "-set".

} # Long_Usage
