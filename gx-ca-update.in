#!%PERL% -w
# To do: Add '-T'

# $Id: gx-ca-update.in,v 1.44 2004-11-03 16:58:03-08 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-ca-update.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2004 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

#
# TO DO:
#
#      If the SIGNED_BY field is set, verify that the corresponding
#      CA certificate has been installed.
#

use strict;

use File::Basename ();
use File::Copy ();
use Getopt::Long ();
use Time::Local ();

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

sub Match_CA_Name($$);
sub String_To_Seconds($);
sub Seconds_To_String($);
sub Time_Image($);
sub Signing_Policy($);
sub Date_To_Seconds($);
sub Get_CA_Ref($);
sub Disabled($);
sub CRL_Info($$);
sub Certificate_Info($);
sub Update_Certificate($);
sub Update_CRL($);
sub Install_Certificate($);
sub Update_Signing_Policy($);
sub Check_Dependencies();
sub Log($$);
sub Error($$);
sub Vprint(@);
sub Notify();
sub Debug(@);
sub Usage(@);

my $Program_Name = File::Basename::basename $0;
my $now = time;

my $User_Opt = { email => 1 };
my @Opts = ( $User_Opt,
             qw( help!
                 version!
                 unsafe!
                 U! UN! UNS! UNSA! UNSAF!
                 UNSAFE!
                 ca=s@
                 all-cas!
                 list-cas!
                 target-dir=s
                 allow-missing-crl!
                 expire-crl=s
                 warn-crl=s
                 force!
                 ignore-disable!
                 email!
                 verbose!
                 debugging! ) );
$Getopt::Long::ignorecase = 0; # options are case-sensitive
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;

if ($User_Opt->{version}) {
    print "gx-ca-update, part of gx-map version $Gridmap_Utils::VERSION\n";
    exit 0;
}

$| = 1 if $User_Opt->{verbose};

if (defined $User_Opt->{unsafe}) {
    Usage "The \"-UNSAFE\" option is case-sensitive\n";
}
foreach my $opt (qw(U UN UNS UNSA UNSAF)) {
    if (defined $User_Opt->{$opt}) {
        Usage "The \"-UNSAFE\" option must be spelled out in full\n";
    }
}

if (not $User_Opt->{UNSAFE}) {
    my @errors = ();
    foreach my $opt ( qw( all-cas
                          allow-missing-crl
                          expire-crl
                          ignore-disable ) )
    {
        if (defined $User_Opt->{$opt}) {
            push @errors, "The \"$opt\" option is disabled " .
                          "(use \"-UNSAFE\" to enable it).\n";
        }
    }
    Usage @errors if @errors;
}

if (defined $User_Opt->{ca} and $User_Opt->{'all-cas'}) {
    Usage "The \"-ca\" and \"-all-cas\" options may not be used together\n";
}

my $Data_Dir = "$Install_Dir/var";
my $lock_file = "$Data_Dir/.gx-ca-update.lock";

my $ca_conf_dir = "$Install_Dir/etc/ca.conf";
my @ca_list_all;
my $requested_all = undef; # true if user specified "-ca ALL"

opendir CONF_DIR, $ca_conf_dir or die "$ca_conf_dir: $!\n";
@ca_list_all = sort
                   grep { /\.cadesc$/ and not /^00000000\./ }
                       readdir CONF_DIR;
closedir CONF_DIR;

if ($User_Opt->{'list-cas'}) {
    foreach my $ca (@ca_list_all) {
        #
        # This clobbers the contents of @ca_list all, but that's ok
        # since we're going to exit.
        #
        $ca =~ s/\.cadesc$//;
        $ca =~ s/\./ /g;
        print "$ca\n";
    }
    exit 0;
}

if (not $User_Opt->{'all-cas'} and not defined $User_Opt->{ca}) {
    Usage "No CA specified\n"
}
if (not defined $User_Opt->{'target-dir'}) {
    Usage "No target directory specified\n"
}

my $CRL_Expiration = undef;
foreach my $opt (qw(expire-crl warn-crl)) {
    if (defined $User_Opt->{$opt}) {
        if ($User_Opt->{$opt} =~ /^(\d+)([smhd])$/) {
            $CRL_Expiration = $1;
            if    ($2 eq 'm') { $CRL_Expiration *= 60 }
            elsif ($2 eq 'h') { $CRL_Expiration *= 3600 }
            elsif ($2 eq 'd') { $CRL_Expiration *= 86400 }
        }
        else {
            Usage "Invalid argument to \"-$opt\" option\n";
        }
    }
}

if ($User_Opt->{debugging}) {
    foreach my $opt (sort keys %$User_Opt) {
        print "$opt => ";
        if (defined $User_Opt->{$opt}) {
            if (ref $User_Opt->{$opt} eq 'ARRAY') {
                print "[\n";
                foreach my $item (@{$User_Opt->{$opt}}) {
                    print "    $item\n";
                }
                print "]\n";
            }
            else {
                print "\"$User_Opt->{$opt}\"\n";
            }
        }
        else {
            print "undef\n";
        }
    }
}

if (scalar @ca_list_all == 0) {
    die "No *.cadesc files in $ca_conf_dir\n";
}

my %selected = ();

my @requested_ca_list = ();
if (defined $User_Opt->{ca}) {
    foreach my $arg (@{$User_Opt->{ca}}) {
        push @requested_ca_list, split /[ ,]/, $arg;
    }
}

Debug "\@ca_list_all = ( @ca_list_all )\n";
Debug "\@requested_ca_list = ( @requested_ca_list )\n";

my @mismatches = ();

if ($User_Opt->{'all-cas'}) {
    %selected = map { $_ => 1 } @ca_list_all;
}
else {
    foreach my $requested_ca (@requested_ca_list) {
        my $match = 0;
        foreach my $ca (@ca_list_all) {
            if (Match_CA_Name $requested_ca, $ca) {
                $selected{$ca} = 1;
                $match = 1;
                last;
            }
        }
        if (not $match) {
            push @mismatches, $requested_ca;
        }
    }
}

my @ca_list = grep $selected{$_}, @ca_list_all;

if (scalar @ca_list == 0 or scalar @mismatches > 0) {
    my @message = ();
    if (scalar @ca_list == 0) {
        push @message, "No CAs selected"
    }
    if (scalar @mismatches == 1) {
        push @message, "No CA matching $mismatches[0]";
    }
    elsif (scalar @mismatches > 1) {
        push @message, "No CA matching any of " . join(', ', @mismatches);
    }
    die join(', ', @message), "\n";
}

my @ca_info = ();

foreach my $ca_desc_file (@ca_list) {
    my $ref = Get_CA_Ref "$ca_conf_dir/$ca_desc_file";
    push @ca_info, $ref if defined $ref;
}

Debug "Got ", scalar @ca_info, " ca record(s):\n";
if ($User_Opt->{debugging}) {
    Gridmap_Utils::Write_Records '-multiple', '-', @ca_info;
}

Gridmap_Utils::Use_Commands 'openssl';

if (-e $lock_file) {
    my $lock_time = Gridmap_Utils::Get_mtime $lock_file;
    die "Locked for ", $now - $lock_time, " seconds\n";
}
open LOCK, ">$lock_file";
close LOCK;

Gridmap_Utils::Init_Cache_Info;

CA:
foreach my $ref (@ca_info) {
    Vprint "Processing $ref->{HASH} $ref->{CA_NAME}\n";
    if (Disabled $ref) {
        if ($requested_all or $User_Opt->{'ignore-disable'}) {
            Vprint "CA is disabled\n";
        }
        else {
            #
            # The user explicitly requested a disabled CA without
            # specifying the "-ignore-disable" option.
            #
            Error $ref, "CA is disabled\n";
        }
        if ($User_Opt->{'ignore-disable'}) {
            Vprint "Overriding \"DISABLE\" attribute\n";
            $ref->{DISABLE} = 'no';
        }
    }
    if (not Disabled $ref) {
        my $prefix = "$User_Opt->{'target-dir'}/$ref->{HASH}";
        $ref->{_CERT_FILE}           = "$prefix.0";
        $ref->{_SIGNING_POLICY_FILE} = "$prefix.signing_policy";
        $ref->{_CRL_FILE}            = "$prefix.r0";

        Update_Certificate    $ref;
        Update_CRL            $ref;
        Install_Certificate   $ref;
        Update_Signing_Policy $ref;

    }
    if (defined $ref->{_ERRORS}) {
        foreach my $error (@{$ref->{_ERRORS}}) {
            Vprint ">>> $error";
        }
    }

    Vprint "\n";
}

Check_Dependencies;

Notify;

unlink $lock_file;

########################################################################

#
# Given an argument to the "-ca" option and the name of a *.cadesc
# file, return true iff the requested CA name matches a subfield of the
# file name.
#
sub Match_CA_Name($$) {
    my($requested_ca, $cadesc_filename) = @_;
    # Debug "Match_CA_Name \"$requested_ca\", \"$cadesc_filename\"";
    my @fields = split /\./, $cadesc_filename;
    pop @fields; # drop ".cadesc" suffix
    foreach my $field (@fields) {
        if (lc $requested_ca eq lc $field) {
            # Debug " => 1\n";
            return 1;
        }
    }
    # Debug " => 0\n";
    return 0;
} # Match_CA_Name

# ----------------------------------------------------------------------

#
# Given a string such as "1 hour" or "10 minutes", returns the number
# of seconds.  The numeric portion must be an integer, and exactly
# one unit may be specified, either seconds, minutes, hours, or days
# (trailing 's' optional).  If you want 1.5 hours, specify "90 minutes").
#
sub String_To_Seconds($) {
    my($timestamp) = lc $_[0];
    if ($timestamp =~ /^(\d+)\s+seconds?$/) {
        return $1;
    }
    elsif ($timestamp =~ /^(\d+)\s+minutes?$/) {
        return $1 * 60;
    }
    elsif ($timestamp =~ /^(\d+)\s+hours?$/) {
        return $1 * 3600;
    }
    elsif ($timestamp =~ /^(\d+)\s+days?$/) {
        return $1 * 86400;
    }
    else {
        return undef;
    }
} # String_To_Seconds

# ----------------------------------------------------------------------

#
# Given a non-negative number of seconds, returns a string such as
# "1m12s" or "32d 12h00m00s" for display.
#
# This function is not an exact inverse of String_To_Seconds();
# the formatting is different.
#
sub Seconds_To_String($) {
    use integer;
    my($total) = @_;
    die "Internal error: Seconds_To_String($total)" if $total < 0;
    my $seconds = $total % 60;
    $total = $total / 60;
    my $minutes = $total % 60;
    $total = $total / 60;
    my $hours = $total % 24;
    my $days = $total / 24;

    if ($days > 0) {
        return sprintf "%dd %02dh %02dm %02ds",
                       $days, $hours, $minutes, $seconds;
    }
    elsif ($hours > 0) {
        return sprintf "%dh %02dm %02ds",
                       $hours, $minutes, $seconds;
    }
    else {
        return sprintf "%dm %02ds",
                       $minutes, $seconds;
    }
} # Seconds_To_String

# ----------------------------------------------------------------------

#
# Given a timestamp, return a string of the form
# "Ddd YYYY-MM-DD HH:MM::SS UTC"
#
sub Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime $time;
    
    return sprintf "%s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec; 
} # Time_Image 

# ----------------------------------------------------------------------

#
# Given a reference to a CA description record, returns a multi-line
# string suitable for use as a signing_policy, compatible with both GT2
# and GT3.
#
sub Signing_Policy($) {
    my($ref) = @_;

    my $cond_subjects;
    if (ref $ref->{MAY_SIGN} eq 'ARRAY') {
        my @list = map { $_ = "\"$_\"" } @{$ref->{MAY_SIGN}};
        $cond_subjects = "'@list'";
    }
    else {
        $cond_subjects = "'$ref->{MAY_SIGN}'";
    }

    my $result = "# $ref->{CA_NAME} Signing Policy\n\n";

    my $body   = "access_id_CA   X509    '$ref->{SUBJECT}'\n" .
                 "pos_rights     globus  CA:sign\n" .
                 "cond_subjects  globus  $cond_subjects\n";

    my $gt2_body = Gridmap_Utils::GT2_Subject $body;
    my $gt3_body = Gridmap_Utils::GT3_Subject $body;

    $result .= $gt2_body;
    if ($gt3_body ne $gt2_body) {
        $result .= "\n";
        $result .= $gt3_body;
    }
    return $result;
} # Signing_Policy;

# ----------------------------------------------------------------------

#
# Given a date string, returns a raw timestamp (seconds since the epoch).
# The input string is assumed to be in the format printed by OpenSSL.
#
sub Date_To_Seconds($) {
    my($timestamp) = @_;
    my %month_num =
        ( Jan => 0, Feb => 1, Mar =>  2, Apr =>  3,
          May => 4, Jun => 5, Jul =>  6, Aug =>  7,
          Sep => 8, Oct => 9, Nov => 10, Dec => 11 );
    if ($timestamp =~
            /^([a-z][a-z][a-z]) \s+
              (\d+)\s+
              (\d+\d+):(\d+\d+):(\d+\d+) \s+
              (\d+) \s+
              (\w+) $/ix )
    {
        my $month_name = $1;
        my $mday = $2;
        my($hour, $minute, $second) = ($3, $4, $5);
        my($year) = $6;
        my($TZ) = uc $7;
        if (defined $month_num{$month_name} and
            ($TZ eq 'GMT' or $TZ eq 'UTC'))
        {
            return Time::Local::timegm
                      $second, $minute, $hour,
                      $mday, $month_num{$month_name}, $year;
        }
    }
    return undef;
} # Date_To_Seconds

# ----------------------------------------------------------------------

#
# Given the name of a cadesc file, returns a reference to a hash containing
# information about the CA.
#
sub Get_CA_Ref($) {
    my($filename) = @_;
    my $ref = Gridmap_Utils::Read_Records '-single', $filename;
    my @errors = ();

    $ref->{_FILENAME} = $filename;

    if (Disabled $ref) {
        return $ref;
    }

    my %valid = map { $_ => 1 } qw( CA_NAME HOMEPAGE CONTACT HASH
                                    SIGNED_BY SUBJECT MAY_SIGN
                                    CERTIFICATE_MD5 CERTIFICATE_URL
                                    SIGNING_POLICY_URL CRL_URL
                                    INDEX CERT_EXPIRES DISABLE
                                    _FILENAME );
    my @required = qw( CA_NAME HASH SUBJECT MAY_SIGN
                       CERTIFICATE_MD5 CERTIFICATE_URL );
    my %remap = ( SIGNED_BY => 1,
                  SUBJECT   => 1,
                  MAY_SIGN  => 1 );
                       
    foreach my $key (@required) {
        if (not defined $ref->{$key}) {
            push @errors, "Missing key $key\n";
        }
    }

    foreach my $key (sort keys %$ref) {
        if (not $valid{$key}) {
            push @errors, "Unrecognized key $key\n";
        }
        if ($key =~ /_URL$/) {
            if ($ref->{$key} ne '?' and $ref->{$key} !~ m<^(https?|ftp):>) {
                push @errors, "Bad value for $key\n";
            }
        }
        #
        # Map subject names to GT3-compatible forms.
        #
        if ($remap{$key}) {
            if (ref $ref->{$key} eq 'ARRAY') {
                map { $_ = Gridmap_Utils::GT3_Subject $_ } @{$ref->{$key}};
            }
            else {
                $ref->{$key} = Gridmap_Utils::GT3_Subject $ref->{$key};
            }
        }
    }
    if (defined $ref->{HASH} and $ref->{HASH} !~ /^[\da-f]{8}$/) {
        push @errors, "Invalid HASH\n";
    }
    if (defined $ref->{DISABLE} and lc $ref->{DISABLE} ne 'no') {
        push @errors, "Value for DISABLE must be \"yes\" or \"no\"\n";
    }

    if (@errors) {
        my $s = (scalar @errors != 1);
        Vprint ">>> Error$s in ${filename}:\n";
        Vprint @errors;
        return undef;
    }
    else {
        return $ref;
    }
} # Get_CA_Ref

# ----------------------------------------------------------------------

#
# Returns true if the DISABLE field in the *.cadesc file exists and is
# set to "yes", false otherwise.
#
sub Disabled($) {
    my($ref) = @_;
    return (defined $ref->{DISABLE} and lc $ref->{DISABLE} eq 'yes');
} # Disabled

# ----------------------------------------------------------------------

#
# Give a reference to a CRL description record, returns a reference to
# information about the CRL:
#     hash
#     issuer
#     last_update (raw timestamp)
#     next_update (raw timestamp)
#     lifetime    (in seconds)
#     used        (proportion of lifetime already used, e.g.
#                 0.0 if it was just issued,
#                 1.0 if it's just now expiring)
#     verified
#
# Returns undef if the hash, issuer, last_update, and next_update values
# cannot be determined.
#
sub CRL_Info($$) {
    my($CRL_file, $cert_file) = @_;
    my $result = {};

    return undef if not defined $CRL_file or not -r $CRL_file;

    #
    # Get attributes of CRL
    #
    open PIPE, "openssl crl -in $CRL_file -noout " .
               "-hash -issuer -lastupdate -nextupdate 2>&1 |" or return undef;
    while (<PIPE>) {
        chomp;
        if (/^[\da-f]{8}$/) {
            $result->{hash} = $_;
        }
        elsif (/^issuer=\s*(.*)$/) {
            $result->{issuer} = Gridmap_Utils::GT3_Subject $1;
        }
        elsif (/^lastUpdate=\s*(.*)$/) {
            $result->{last_update} = Date_To_Seconds $1;
        }
        elsif (/^nextUpdate=\s*(.*)$/) {
            $result->{next_update} = Date_To_Seconds $1;
        }
    }
    close PIPE;
    
    #
    # If we didn't get everything we need, don't return any information.
    #
    foreach my $key (qw(hash issuer last_update next_update)) {
        return undef if not defined $result->{$key};
    }

    $result->{lifetime} = $result->{next_update} - $result->{last_update};
    $result->{used} = ($now - $result->{last_update}) / $result->{lifetime};

    #
    # Verify CRL against certificate.
    # (If it's ok, openssl prints "verify OK" to stderr.)
    #
    if (defined $cert_file and -r $cert_file) {
        open PIPE, "openssl crl -in $CRL_file -noout " .
                   "-CAfile $cert_file 2>&1 |";
        while (<PIPE>) {
            if (/verify ok/i) {
                $result->{verified} = 1;
            }
        }
        close PIPE;
    }

    return $result;
} # CRL_Info

# ----------------------------------------------------------------------

#
# Given the name of a certificate file, returns a reference to information
# about the certificate:
#     hash
#     issuer
#     subject
#     md5sum
#     startdate (raw timestamp)
#     enddate   (raw timestamp)
#
# Returns undef if any of these fields cannot be determined.
#
sub Certificate_Info($) {
    my($cert_file) = @_;
    return undef if not -r $cert_file;
    my $result = {};
    open PIPE, "openssl x509 -in $cert_file -noout -hash -issuer -subject " .
               "-md5 -fingerprint -startdate -enddate |";
    while (<PIPE>) {
        chomp;
        if (/^[\da-f]{8}$/) {
            $result->{hash} = $_;
        }
        elsif (/^issuer=\s*(.*)$/) {
            $result->{issuer} = Gridmap_Utils::GT3_Subject $1;
        }
        elsif (/^subject=\s*(.*)$/) {
            $result->{subject} = Gridmap_Utils::GT3_Subject $1;
        }
        elsif (/^md5.*=\s*(.*)$/i) {
            $result->{md5sum} = $1;
        }
        elsif (/^notBefore=\s*(.*)$/) {
            $result->{startdate} = Date_To_Seconds $1;
        }
        elsif (/^notAfter=\s*(.*)$/) {
            $result->{enddate} = Date_To_Seconds $1;
        }
    }
    close PIPE;

    foreach my $key (qw(hash issuer subject md5sum startdate enddate)) {
        return undef if not defined $result->{$key};
    }

    return $result;
} # Certificate_Info

# ----------------------------------------------------------------------

#
# Update CA certificate if necessary.
# Don't install it yet; wait until after we've checked the CRL.
# (We need the certificate to validate the CRL, but we don't to
# see whether we have a CRL before installing the certificate.)
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# Refuse to install an expired certificate, but leave it alone if
# it's already installed.
#
sub Update_Certificate($) {
    my($ref) = @_;

    Debug "Update_Certificate, CA_NAME = ",
          (defined $ref->{CA_NAME} ? $ref->{CA_NAME} : '???'),
          "\n";
    if (not $User_Opt->{force} and -e $ref->{_CERT_FILE}) {
        Vprint "Skipping existing $ref->{_CERT_FILE}\n";
    }
    elsif ($ref->{CERTIFICATE_URL} =~ m<(https?|ftp)://>) {
        my $cache_file;
        eval {
            $cache_file = Gridmap_Utils::Cache_File
                              $ref->{CERTIFICATE_URL}
        };
        if (defined $@ and $@ ne '') {
            #
            # Error in Cache_File function
            #
            Error $ref, $@;
        }
        elsif (defined $cache_file and -r $cache_file) {
            $ref->{_CACHED_CERT_FILE} = $cache_file;
            # Debug "_CACHED_CERT_FILE = \"$cache_file\"\n";
            my $cert_info = Certificate_Info $cache_file;
            if (defined $cert_info->{enddate}) {
                if ($cert_info->{enddate} < $now) {
                    Error $ref, "Certificate expired " .
                                Seconds_To_String
                                    ($now - $cert_info->{enddate}) .
                                " ago\n";
                }
            }
            else {
                Error $ref,
                      "Unable to determine certificate expiration date\n";
            }
            if ($cert_info->{hash} ne $ref->{HASH}) {
                Error $ref, "Mismatched hash, expected $ref->{HASH}, " .
                            "got $cert_info->{hash}\n";
            }
            if ($cert_info->{subject} ne $ref->{SUBJECT}) {
                Error $ref, "Mismatched subject, expected " .
                            "\"$ref->{SUBJECT}\", got " .
                            "\"$cert_info->{subject}\"\n";
            }
            if (defined $ref->{SIGNED_BY} and
                $ref->{SIGNED_BY} ne '?')
            {
                if ($cert_info->{issuer} ne $ref->{SIGNED_BY}) {
                    Error $ref, "Mismatched issuer, expected " .
                                "\"$ref->{SIGNED_BY}\", got " .
                                "\"$cert_info->{issuer}\"\n";
                }
            }
            else {
                if ($cert_info->{issuer} ne $cert_info->{subject}) {
                    Error $ref, "Certificate is not self-signed, " .
                                "but no SIGNED_BY attribute was " .
                                "specified in $ref->{_FILENAME}\n";
                }
            }
            if ($cert_info->{md5sum} ne $ref->{CERTIFICATE_MD5}) {
                Error $ref, "Mismatched md5 fingerprint, expected " .
                            "\"$ref->{CERTIFICATE_MD5}\", got " .
                            "\"$cert_info->{md5sum}\"\n";
            }

        }
    }
    else {
        Vprint "No URL given for certificate\n";
    }
} # Update_Certificate

# ----------------------------------------------------------------------

#
# Update CRL if necessary
#
sub Update_CRL($) {
    my($ref) = @_;
    my $cert_file;

    return if defined $ref->{_ERRORS};

    Debug "Update_CRL, CA_NAME = ",
          (defined $ref->{CA_NAME} ? $ref->{CA_NAME} : '???'),
          "\n";

    #
    # _CACHED_CERT_FILE, if set, is the newly downloaded or cached
    # certificate.  Otherwise, _CERT_FILE is the installed certificate.
    #
    if (defined $ref->{_CACHED_CERT_FILE} and -e $ref->{_CACHED_CERT_FILE}) {
        $cert_file = $ref->{_CACHED_CERT_FILE};
    }
    elsif (-e $ref->{_CERT_FILE}) {
        $cert_file = $ref->{_CERT_FILE};
    }
    else {
        #
        # We don't have a certificate, so we can't check the CRL (and
        # there's no point in installing it).  We should have already
        # flagged an error in Update_Certificate, so we should never
        # get here, but check it anyway.
        #
        Error $ref, "No certificate, can't check CRL\n";
        return;
    }

    # Debug "Checking $ref->{_CRL_FILE} against $cert_file\n";

    my $old_crl_info = CRL_Info $ref->{_CRL_FILE}, $cert_file;

    # if ($User_Opt->{debugging}) {
    #     if (defined $old_crl_info) {
    #         Debug "old_crl_info:\n";
    #         my @arr = ( $old_crl_info );
    #         Gridmap_Utils::Write_Records '-multiple', '-', @arr;
    #     }
    #     else {
    #         Debug "old_crl_info = undef\n";
    #     }
    # }

    my $install_new_crl = 0;

    my $have_crl_url = $ref->{CRL_URL} =~ m<(https?|ftp)://>;
    my $new_crl_file = undef;
    if ($have_crl_url) {
        #
        # Attempt to download a new CRL (or use a cached copy)
        #
        eval { $new_crl_file = Gridmap_Utils::Cache_File $ref->{CRL_URL} };
        if (defined $@ and $@ ne '') {
            #
            # Error in Cache_File function
            #
            Error $ref, $@;
        }
    }
    else {
        if (not $User_Opt->{'allow-missing-crl'}) {
            Error $ref, "No CRL specified\n";
        }
    }
    #
    # Verify signature against certificate.
    #

    # Debug "Checking " .
    #       (defined $new_crl_file ? $new_crl_file : 'undef') .
    #       " against " .
    #       (defined $cert_file ? $cert_file : 'undef') .
    #       "\n";

    my $new_crl_info = CRL_Info $new_crl_file, $cert_file;

    # if ($User_Opt->{debugging}) {
    #     if (defined $new_crl_info) {
    #         Debug "new_crl_info:\n";
    #         my @arr = ( $new_crl_info );
    #         Gridmap_Utils::Write_Records '-multiple', '-', @arr;
    #     }
    #     else {
    #         Debug "new_crl_info = undef\n";
    #     }
    # }

    if (defined $new_crl_info) {
        #
        # We have a new CRL; decide whether to install it.
        #
        my $remaining = $new_crl_info->{next_update} - $now;
        # Debug "remaining = $remaining\n";
        if ($remaining <= 0) {
            if ($User_Opt->{'allow-missing-crl'}) {
                Vprint "Newly downloaded CRL has expired\n";
            }
            else {
                Error $ref, "Newly downloaded CRL has expired\n";
            }
        }
        elsif (defined $CRL_Expiration and $remaining < $CRL_Expiration) {
            Error $ref, "Newly downloaded CRL expires in " .
                        Seconds_To_String($remaining) .
                        ", not installing\n";
        }
        elsif (not $new_crl_info->{verified}) {
            Error $ref, "Can't verify new CRL\n";
        }
        elsif (defined $old_crl_info) {
            #
            # We have an old CRL and a new CRL; decide whether to
            # replace the old one with the new one.
            #
            if ($new_crl_info->{last_update} == $old_crl_info->{last_update} and
                $new_crl_info->{next_update} == $old_crl_info->{next_update})
            {
                Vprint "CRL update not needed\n";
            }
            elsif ($new_crl_info->{next_update} <
                   $old_crl_info->{next_update})
            {
                Error $ref, "Newly downloaded CRL expires sooner " .
                            "than old CRL, not installing\n";
            }
            else {
                $install_new_crl = 1;
            }
        }
        else {
            $install_new_crl = 1;
        }
    }
    else {
        #
        # We don't have a new CRL
        #
        if (not $have_crl_url) {
            Vprint "No URL given for CRL\n";
        }
        else {
            Error $ref, "Unable to get information for CRL\n";
        }
    }

    # Debug "install_new_crl = $install_new_crl\n";

    if ($install_new_crl) {
        Vprint    "Installing $ref->{_CRL_FILE}\n";
        Log $ref, "Installing $ref->{_CRL_FILE}\n";
        File::Copy::copy $new_crl_file, "$ref->{_CRL_FILE}.$$"
            or Error $ref, "Failed to copy CRL: $!\n";
        rename "$ref->{_CRL_FILE}.$$", $ref->{_CRL_FILE}
            or Error $ref, "Failed to rename CRL: $!\n";
    }

    #
    # Just to be sure, re-fetch CRL info from the target CRL file
    # (which may or may not have just been updated).
    #
    if (-r $ref->{_CRL_FILE}) {
        my $crl_info = CRL_Info $ref->{_CRL_FILE}, $cert_file;
        my $remaining = $crl_info->{next_update} - $now;
        my $remove_crl = 0;
        if (defined $crl_info) {
            if (not $crl_info->{verified}) {
                Error $ref, "Removing unverified CRL\n";
                $remove_crl = 1;
            }
            elsif (defined $CRL_Expiration and
                   $remaining < $CRL_Expiration)
            {
                Error $ref, "CRL will expire in " .
                            Seconds_To_String($remaining) .
                            ", removing it\n";
                $remove_crl = 1;
            }
            if ($remove_crl) {
                unlink $ref->{_CRL_FILE};
            }
            else {
                my $expiration_string = Time_Image $crl_info->{next_update};
                my $how_long = Seconds_To_String abs $remaining;
                my $notify = 0;
                if ($crl_info->{used} > 0.9) {
                    $notify = 1;
                }
                elsif (defined $User_Opt->{'warn-crl'}) {
                    if ($remaining < $User_Opt->{'warn-crl'}) {
                        $notify = 1;
                    }
                }
                if ($remaining < 0) {
                    Error $ref, "CRL expired at $expiration_string " .
                                "($how_long ago)\n";
                }
                elsif ($remaining == 0) {
                    Error $ref, "CRL expires at $expiration_string\n";
                }
                else {
                    if ($notify) {
                        Error $ref, "CRL will expire at $expiration_string " .
                                    "($how_long from now)\n";
                    }
                    else {
                        Vprint "CRL will expire at $expiration_string " .
                               "($how_long from now)\n";
                    }
                }
                if (not $crl_info->{verified}) {
                    Error $ref, "CRL is not verified\n";
                }
            }
        }
    }
    else {
        Vprint"No CRL\n";
    }
} # Update_CRL

# ----------------------------------------------------------------------

sub Install_Certificate($) {
    my($ref) = @_;

    #
    # Don't install the certificate file if there are any errors.
    # This includes a missing CRL if the "-allow-missing-crl" option
    # was not specified.
    #
    return if defined $ref->{_ERRORS};

    if (not $User_Opt->{force} and -e $ref->{_CERT_FILE}) {
        Vprint "Certificate $ref->{HASH}.0 is already installed\n";
        return;
    }
    Vprint    "Installing $ref->{_CERT_FILE}\n";
    Log $ref, "Installing $ref->{_CERT_FILE}\n";
    File::Copy::copy $ref->{_CACHED_CERT_FILE}, "$ref->{_CERT_FILE}.$$"
        or Error $ref, "Failed to copy certificate: $!\n";
    rename "$ref->{_CERT_FILE}.$$", $ref->{_CERT_FILE}
        or Error $ref, "Failed to rename certificate: $!\n";
} # Install_Certificate

# ----------------------------------------------------------------------

#
# Update signing_policy file if necessary.
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# For now, we ignore the SIGNING_POLICY_URL; the signing_policy is
# generated from the MAY_SIGN attributes.
# Don't bother to install if there have been any errors.
#
sub Update_Signing_Policy($) {
    my($ref) = @_;

    return if defined $ref->{_ERRORS};

    if (not $User_Opt->{force} and -e $ref->{_SIGNING_POLICY_FILE}) {
        Vprint "Skipping existing $ref->{_SIGNING_POLICY_FILE}\n";
    }
    else {
        if (defined $ref->{_ERRORS}) {
            Vprint "Skipping $ref->{_SIGNING_POLICY_FILE} " .
                   "due to previous errors\n";
        }
        else {
            Vprint    "Creating $ref->{_SIGNING_POLICY_FILE}\n";
            Log $ref, "Creating $ref->{_SIGNING_POLICY_FILE}\n";
            open POLICY, ">$ref->{_SIGNING_POLICY_FILE}"
                or die "$ref->{_SIGNING_POLICY_FILE}: $!\n";
            print POLICY Signing_Policy $ref;
            close POLICY;
            $ref->{_INSTALLED_SIGNING_POLICY} = 1;
        }
    }
} # Update_Signing_Policy

# ----------------------------------------------------------------------

#
# 
sub Check_Dependencies() {
    Vprint "Dependency checking not yet implemented\n";
} # Check_Dependencies

# ----------------------------------------------------------------------

#
# Log a message.
# Annotate the CA reference (first argument) with the message.
#
sub Log($$) {
    my($ref, $message) = @_;
    push @{$ref->{_MESSAGES}}, $message;
} # Log

# ----------------------------------------------------------------------

#
# Report an error.
# Annotate the CA reference (first argument) with the error message.
#
sub Error($$) {
    my($ref, $message) = @_;
    push @{$ref->{_ERRORS}}, $message;
} # Error

# ----------------------------------------------------------------------

#
# Send an error notification by e-mail.
# Log messages to log file.
#
sub Notify() {
    my $total_ca_count = scalar @ca_info;
    my $error_ca_count = 0;
    my $error_count = 0;
    my $message_body = '';

    my $log_file = "$Install_Dir/var/$Program_Name.log";
    open LOG, ">>$log_file";
    print LOG Time_Image $now, " $Program_Name\n";

    foreach my $ref (@ca_info) {
        if (defined $ref->{_ERRORS}) {
            $error_ca_count ++;
            $error_count += scalar @{$ref->{_ERRORS}};
        }
    }

    foreach my $ref (@ca_info) {
        if (defined $ref->{_MESSAGES} or defined $ref->{_ERRORS}) {
            print LOG "$ref->{HASH} $ref->{CA_NAME}:\n";

            if (defined $ref->{_MESSAGES}) {
                foreach my $message (@{$ref->{_MESSAGES}}) {
                    print LOG "    $message";
                }
            }

            if (defined $ref->{_ERRORS}) {
                my @error_list = @{$ref->{_ERRORS}};
                $message_body .= "$ref->{HASH} $ref->{CA_NAME}:\n";
                $message_body .= join '', @error_list;
                $message_body .= "\n";
                foreach my $error (@error_list) {
                    print LOG "    >>> ERROR: $error";
                }
            }
        }
    }

    print LOG "\n";
    close LOG;

    if ($User_Opt->{email} and $error_count > 0) {
        my $subject = "$Program_Name: $error_count error(s), " .
                      "$error_ca_count/$total_ca_count CA(s)";

        my $recipient = $Gridmap_Utils::Config{ADMIN_EMAIL};
        #
        # Find a mail program.
        # Look in /usr/bin, /bin, /usr/sbin, and /sbin; prefer mailx to mail.
        # (On some systems with both "mail" and "mailx", "mailx"
        # recognizes the "-s" option but "mail" doesn't; on systems
        # without "mailx", "mail" usually recoognizes "-s".)
        # This isn't pretty, but it should work on most systems.
        #
        my $mail_program = undef;
        TRY:
        foreach my $prog (qw(mailx mail)) {
            foreach my $dir(qw(/usr/bin /bin /usr/sbin)) {
                if (-x "$dir/$prog") {
                    $mail_program = "$dir/$prog";
                    last TRY;
                }
            }
        }
        if (defined $mail_program) {
            open PIPE, "| $mail_program -s '$subject' $recipient";
            print PIPE $message_body;
            close PIPE;
        }
    }
} # Notify

# ----------------------------------------------------------------------

#
# Print a message if "-verbose" option was given
#
sub Vprint(@) {
    print @_ if $User_Opt->{verbose};
} # Vprint

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Usage(@) {
    if (@_) {
        print @_;
        print "Run \"$Program_Name -help\" for more information\n";
    }
    else {
        print <<"EOF";
Usage: $Program_Name [options]
    -help              Display this message and exit.
    -version           Display version information and exit.
    -UNSAFE            By default, options that can create security
                       problems are disabled.  You can use the
                       "-UNSAFE" option (case-sensitive) to enable
                       them.  The "unsafe" options are:
                            -all-cas
                            -allow-missing-crl
                            -expire-crl time
                            -ignore-disable
    -ca name           Name of a CA.  This argument may be given multiple
                       times, or CA names may be delimited by commas or
                       blanks.  The argument is a field of the *.cadesc
                       file name; use the hash value to avoid ambiguity.
    -all-cas           Use all available CAs.
                       Requires "-UNSAFE".
    -list-cas          List available CAs and exit.
    -target-dir dir    Target directory.
    -allow-missing-crl Allow a CA with no CRL to be installed.
                       Requires "-UNSAFE".
    -expire-crl time   Remove a CRL that will expire within
                       "time".  "time" is expressed as a number
                       followed by 's' (seconds), 'm' (minutes),
                       'h' (hours) or 'd' (days); for example
                       "-expire-crl 75m".  By default, expiring CRLs
                       are left in place.
                       Requires "-UNSAFE".
    -warn-crl time     Issue a warning message if the CRL will expire
                       within the specified time.  Regardless of this
                       option, a warning will also be issued if the CRL
                       has used more than 90% of its lifetime.
    -force             Force file updates (applies to certificate and
                       signing_policy files).
    -ignore-disable    Ignore "DISABLE" attribute in cadesc files.
                       Requires "-UNSAFE".
    -email             Send e-mail to configured ADMIN_EMAIL address on errors.
                       Default is "-email"; use "-noemail" to disable.
    -verbose           Print verbose messages.
    -debugging         Enable debugging output.
EOF
    }
    exit 1;
} # Usage
