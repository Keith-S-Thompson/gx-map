#!%PERL% -w
# To do: Add '-T'

# $Id: gx-ca-update.in,v 1.7 2004-09-15 18:40:20-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-ca-update.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2004 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use Getopt::Long ();
use Time::Local ();

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

sub Seconds($);
sub Signing_Policy($);
sub Timestamp_To_Seconds($);
sub CRL_Expiration($);
sub Usage(@);
sub Debug(@);

my $Prog_Name = File::Basename::basename $0;
my $now = time;

my $User_Opt = {};
my @Opts = ( $User_Opt,
             qw( help! version! ca=s@ target-dir=s force! debugging! ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;

if ($User_Opt->{version}) {
    print "gx-ca-update, part of gx-map version $Gridmap_Utils::VERSION\n";
    exit 0;
}

if (not defined $User_Opt->{ca}) {
    Usage "No CA specified\n"
}
if (not defined $User_Opt->{'target-dir'}) {
    Usage "No target directory specified\n"
}

if ($User_Opt->{debugging}) {
    foreach my $opt (sort keys %$User_Opt) {
        print "$opt => ";
        if (defined $User_Opt->{$opt}) {
            if (ref $User_Opt->{$opt} eq 'ARRAY') {
                print "[\n";
                foreach my $item (@{$User_Opt->{$opt}}) {
                    print "    $item\n";
                }
                print "]\n";
            }
            else {
                print "\"$User_Opt->{$opt}\"\n";
            }
        }
        else {
            print "undef\n";
        }
    }
}

my @ca_info = ();
my $ca_conf_dir = "$Install_Dir/var/ca.conf";

my @ca_list = @{$User_Opt->{ca}};
if (scalar @ca_list == 1 and $ca_list[0] eq 'ALL') {
    opendir CONF_DIR, $ca_conf_dir or die "$ca_conf_dir: $!\n";
    @ca_list = sort grep /\.cadesc$/, readdir CONF_DIR;
    closedir CONF_DIR;
    Debug "\@files = ( @ca_list )\n";
    if (not @ca_list) {
        die "No *.cadesc files in $ca_conf_dir\n";
    }
    map s/\.cadesc$//, @ca_list;
    Debug "\@ca_list = ( @ca_list )\n";
}

foreach my $ca (@ca_list) {
    my $ca_desc_file = "$ca_conf_dir/$ca.cadesc";
    my $ref = Gridmap_Utils::Read_Records '-single', $ca_desc_file;
    if (defined $ref->{CRL_MAX_AGE}) {
        my $seconds = Seconds $ref->{CRL_MAX_AGE};
        if (defined $seconds) {
            $ref->{CRL_MAX_AGE} = $seconds;
        }
    }
    push @ca_info, $ref;
}

Debug "Got ", scalar @ca_info, " ca record(s):\n";
if ($User_Opt->{debugging}) {
    Gridmap_Utils::Write_Records '-multiple', '-', @ca_info;
}

Gridmap_Utils::Init_Cache_Info;

foreach my $ref (@ca_info) {
    print "Processing $ref->{HASH} $ref->{CA_DESC}\n";
    my $target_dir = $User_Opt->{'target-dir'};
    # Gridmap_Utils::Untaint $target_dir;

    #
    # Update CA certificate if necessary
    #
    my $target_cert_file = "$target_dir/$ref->{HASH}.0";
    if (not $User_Opt->{force} and -e $target_cert_file) {
        print "Skipping existing $target_cert_file\n";
    }
    elsif ($ref->{CERTIFICATE} =~ m<(http|ftp)://>) {
        print "Installing $target_cert_file\n";
        # Gridmap_Utils::Untaint $target_cert_file;
        my $cache_file;
        eval { $cache_file = Gridmap_Utils::Cache_File $ref->{CERTIFICATE} };
        if (defined $@ and $@ ne '') {
            #
            # Error in Cache_File function
            #
            print ">>> $@";
        }
        elsif (defined $cache_file and -r $cache_file) {
            system 'cp', '-p', $cache_file, "$target_cert_file.$$";
            rename "$target_cert_file.$$", $target_cert_file;
        }
    }
    else {
        print "No URL given for certificate\n";
    }

    #
    # Update signing_policy file if necessary
    #
    my $policy_file
        = "$User_Opt->{'target-dir'}/$ref->{HASH}.signing_policy";
    if (not $User_Opt->{force} and -e $policy_file) {
        print "Skipping existing $policy_file\n";
    }
    else {
        # Gridmap_Utils::Untaint $policy_file;
        print "Creating $policy_file\n";
        open POLICY, ">$policy_file" or die "$policy_file: $!\n";
        print POLICY Signing_Policy $ref;
        close POLICY;
    }

    #
    # Update CRL if necessary
    #
    my $target_crl_file = "$target_dir/$ref->{HASH}.r0";
    my $needs_update = 0;
    if ($User_Opt->{force} or not -e $target_crl_file) {
        $needs_update = 1;
    }
    else {
        my $mtime = (stat $target_crl_file)[9];
        my $age = $now - $mtime;
        if ($age > $ref->{CRL_MAX_AGE}) {
            print "Stale file $target_crl_file\n";
            $needs_update = 1;
        }
    }
    if (not $needs_update) {
        print "Skipping existing $target_crl_file\n";
    }
    elsif ($ref->{CRL} =~ m<(http|ftp)://>) {
        print "Installing $target_crl_file\n";
        # Gridmap_Utils::Untaint $target_crl_file;
        my $cache_file;
        eval { $cache_file = Gridmap_Utils::Cache_File $ref->{CRL} };
        if (defined $@ and $@ ne '') {
            #
            # Error in Cache_File function
            #
            print ">>> $@";
        }
        elsif (defined $cache_file and -r $cache_file) {
            system 'cp', '-p', $cache_file, "$target_crl_file.$$";
            rename "$target_crl_file.$$", $target_crl_file;
        }
    }
    else {
        print "No URL given for CRL\n";
    }

    #
    # Check expiration date of CRL.
    # To do: warn if time to expiration is less than a specified
    # threshold.
    #
    my $expires = CRL_Expiration $target_crl_file;
    if (defined $expires) {
        my $remaining = $expires - time;
        my $delta = abs $remaining;
        if ($delta >= 86400) {
            $delta = sprintf "%.2f day(s)", $delta / 86400;
        }
        elsif ($delta >= 3600) {
            $delta = sprintf "%.2f hour(s)", $delta / 3600;
        }
        elsif ($delta >= 60) {
            $delta = sprintf "%.2f hour(s)", $delta / 60;
        }
        else {
            $delta .= " second(s)";
        }
        if ($remaining <= 0) {
            print "$target_crl_file expired $delta ago\n";
        }
        else {
            print "$target_crl_file expires in $delta\n";
        }
    }
    print "\n";
}

########################################################################

sub Seconds($) {
    my($timestamp) = @_;
    if ($timestamp =~ /^(\d+)\s+(seconds?)$/) {
        return $1;
    }
    elsif ($timestamp =~ /^(\d+)\s+(minutes?)$/) {
        return $1 * 60;
    }
    elsif ($timestamp =~ /^(\d+)\s+(hours?)$/) {
        return $1 * 3600;
    }
    elsif ($timestamp =~ /^(\d+)\s+(day?)$/) {
        return $1 * 86400;
    }
    else {
        return undef;
    }
} # Seconds

# ----------------------------------------------------------------------

sub Signing_Policy($) {
    my($ref) = @_;

    my $cond_subjects;
    if (ref $ref->{MAY_SIGN} eq 'ARRAY') {
        my @list = map { $_ = "\"$_\"" } @{$ref->{MAY_SIGN}};
        $cond_subjects = "'@list'";
    }
    else {
        $cond_subjects = "'$ref->{MAY_SIGN}'";
    }

    my $result = "# $ref->{CA_DESC} Signing Policy\n\n";

    my $body   = "access_id_CA   X509    '$ref->{SUBJECT}'\n" .
                 "pos_rights     globus  CA:sign\n" .
                 "cond_subjects  globus  $cond_subjects\n";

    my $gt2_body = $body;
    $gt2_body =~ s(/0\.9\.2342\.19200300\.100\.1\.1=)(/USERID=)g;
    $gt2_body =~ s(/UID=)(/USERID=)g;
    $gt2_body =~ s(/emailAddress=)(/Email=)g;

    my $gt3_body = $body;
    $gt3_body =~ s(/0\.9\.2342\.19200300\.100\.1\.1=)(/UID=)g;
    $gt3_body =~ s(/USERID=)(/UID=)g;
    $gt3_body =~ s(/Email=)(/emailAddress=)g;

    $result .= $gt2_body;
    if ($gt3_body ne $gt2_body) {
        $result .= "\n";
        $result .= $gt3_body;
    }
    return $result;
} # Signing_Policy;

# ----------------------------------------------------------------------

sub Timestamp_To_Seconds($) {
    my($timestamp) = @_;
    my %month_num =
        ( Jan => 0, Feb => 1, Mar =>  2, Apr =>  3,
          May => 4, Jun => 5, Jul =>  6, Aug =>  7,
          Sep => 8, Oct => 9, Nov => 10, Dec => 11 );
    if ($timestamp =~
            /^([a-z][a-z][a-z]) \s+
              (\d+)\s+
              (\d+\d+):(\d+\d+):(\d+\d+) \s+
              (\d+) \s+
              (\w+) $/ix )
    {
        my $month_name = $1;
        my $mday = $2;
        my($hour, $minute, $second) = ($3, $4, $5);
        my($year) = $6;
        my($TZ) = uc $7;
        if (defined $month_num{$month_name} and
            ($TZ eq 'GMT' or $TZ eq 'UTC'))
        {
            return Time::Local::timegm
                      $second, $minute, $hour,
                      $mday, $month_num{$month_name}, $year;
        }
    }
    return undef;
} # Timestamp_To_Seconds

# ----------------------------------------------------------------------

sub CRL_Expiration($) {
    my($filename) = @_;
    open PIPE, "openssl crl -in $filename -noout -text |" or return undef;
    while (<PIPE>) {
        if (/^\s*Next Update: (.*)$/) {
            close PIPE;
            return Timestamp_To_Seconds $1;
        }
    }
    close PIPE;
    return undef;
} # CRL_Expiration

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Prog_Name [options]
    -help            : Display this message and exit
    -version         : Display version information and exit
    -ca name         : Name of a CA (may be given multiple times)
    -ca ALL          : Use all available CAs
    -target-dir dir  : Target directory
    -force           : Force file updates
    -debugging       : Enable debugging output
EOF
    exit 1;
} # Usage

# ----------------------------------------------------------------------

sub Debug(@) {
    if ($User_Opt->{debugging}) {
        if (scalar @_ >= 1 and $_[0] eq '-f') {
            shift @_;
            printf @_;
        }
        else {
            print @_;
        }
    }
} # Debug
