#!%PERL% -w
# To do: Add '-T'

# $Id: gx-ca-update.in,v 1.36 2004-10-13 16:41:29-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-ca-update.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2004 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

#
# TO DO:
#
#      If the SIGNED_BY field is set, verify that the corresponding
#      CA certificate has been installed.
#
#      Drop the CRL_WARNING field (or make it optional?); instead,
#      warn if the CRL is past 90% of its lifetime.
#

use strict;

use File::Basename ();
use File::Copy ();
use Getopt::Long ();
use Time::Local ();

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

sub Match_CA_Name($$);
sub String_To_Seconds($);
sub Seconds_To_String($);
sub Time_Image($);
sub Signing_Policy($);
sub Date_To_Seconds($);
sub Get_CA_Ref($);
sub Disabled($);
sub CRL_Info($$);
sub Certificate_Info($);
sub Update_Certificate($);
sub Update_Signing_Policy($);
sub Update_CRL($);
sub Usage(@);
sub Log($$);
sub Error($$);
sub Vprint(@);
sub Notify();
sub Debug(@);

my $Program_Name = File::Basename::basename $0;
my $now = time;

my $User_Opt = { email => 1 };
my @Opts = ( $User_Opt,
             qw( help!
                 version!
                 ca=s@
                 list-cas!
                 target-dir=s
                 expire-crl=s
                 force!
                 ignore-disable!
                 email!
                 verbose!
                 debugging! ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;

if ($User_Opt->{version}) {
    print "gx-ca-update, part of gx-map version $Gridmap_Utils::VERSION\n";
    exit 0;
}

$| = 1 if $User_Opt->{verbose};

my $ca_conf_dir = "$Install_Dir/etc/ca.conf";
my @ca_list_all;
my $requested_all = undef; # true if user specified "-ca ALL"

opendir CONF_DIR, $ca_conf_dir or die "$ca_conf_dir: $!\n";
@ca_list_all = sort
                   grep { /\.cadesc$/ and not /^00000000\./ }
                       readdir CONF_DIR;
closedir CONF_DIR;

if ($User_Opt->{'list-cas'}) {
    foreach my $ca (@ca_list_all) {
        $ca =~ s/\.cadesc$//;
        $ca =~ s/\./ /g;
        print "$ca\n";
    }
    exit 0;
}

if (not defined $User_Opt->{ca}) {
    Usage "No CA specified\n"
}
if (not defined $User_Opt->{'target-dir'}) {
    Usage "No target directory specified\n"
}

my $CRL_Expiration = undef;
if (defined $User_Opt->{'expire-crl'}) {
    if ($User_Opt->{'expire-crl'} =~ /^(\d+)([smhd])$/) {
        $CRL_Expiration = $1;
        if    ($2 eq 'm') { $CRL_Expiration *= 60 }
        elsif ($2 eq 'h') { $CRL_Expiration *= 3600 }
        elsif ($2 eq 'd') { $CRL_Expiration *= 86400 }
    }
    else {
        Usage "Invalid argument to -expire-url option\n";
    }
}

if ($User_Opt->{debugging}) {
    foreach my $opt (sort keys %$User_Opt) {
        print "$opt => ";
        if (defined $User_Opt->{$opt}) {
            if (ref $User_Opt->{$opt} eq 'ARRAY') {
                print "[\n";
                foreach my $item (@{$User_Opt->{$opt}}) {
                    print "    $item\n";
                }
                print "]\n";
            }
            else {
                print "\"$User_Opt->{$opt}\"\n";
            }
        }
        else {
            print "undef\n";
        }
    }
}

if (scalar @ca_list_all == 0) {
    die "No *.cadesc files in $ca_conf_dir\n";
}

my %selected = ();

my @requested_ca_list = ();
foreach my $arg (@{$User_Opt->{ca}}) {
    push @requested_ca_list, split /[ ,]/, $arg;
}

foreach my $requested_ca (@requested_ca_list) {
    if ($requested_ca eq 'ALL') {
        %selected = map { $_ => 1 } @ca_list_all;
        $requested_all = 1;
    }
    else {
        foreach my $ca (@ca_list_all) {
            if (Match_CA_Name $requested_ca, $ca) {
                $selected{$ca} = 1;
            }
        }
    }
}

my @ca_list = grep $selected{$_}, @ca_list_all;

if (scalar @ca_list == 0) {
    die "No CAs selected\n";
}

my @ca_info = ();

foreach my $ca_desc_file (@ca_list) {
    my $ref = Get_CA_Ref "$ca_conf_dir/$ca_desc_file";
    push @ca_info, $ref if defined $ref;
}

Debug "Got ", scalar @ca_info, " ca record(s):\n";
if ($User_Opt->{debugging}) {
    Gridmap_Utils::Write_Records '-multiple', '-', @ca_info;
}

Gridmap_Utils::Use_Commands 'openssl';

Gridmap_Utils::Init_Cache_Info;

CA:
foreach my $ref (@ca_info) {
    Vprint "Processing $ref->{HASH} $ref->{CA_NAME}\n";
    if (Disabled $ref) {
        if ($requested_all or $User_Opt->{'ignore-disable'}) {
            Vprint "CA is disabled\n";
        }
        else {
            #
            # The user explicitly requested a disabled CA without
            # specifying the "-ignore-disable" option.
            #
            Error $ref, "CA is disabled\n";
        }
        if ($User_Opt->{'ignore-disable'}) {
            Vprint "Ignoring \"disable\" attribute\n";
        }
        else {
            Vprint "\n";
            next CA;
        }
    }

    my $prefix = "$User_Opt->{'target-dir'}/$ref->{HASH}";
    $ref->{_CERT_FILE}           = "$prefix.0";
    $ref->{_SIGNING_POLICY_FILE} = "$prefix.signing_policy";
    $ref->{_CRL_FILE}            = "$prefix.r0";

    Update_Certificate    $ref;
    Update_Signing_Policy $ref;
    Update_CRL            $ref;

    if (defined $ref->{_ERRORS}) {
        foreach my $error (@{$ref->{_ERRORS}}) {
            Vprint ">>> $error";
        }
    }

    Vprint "\n";
}

Notify;

########################################################################

#
# Given an argument to the "-ca" option and the name of a *.cadesc
# file, return true iff the requested CA name matches a subfield of the
# file name.
#
sub Match_CA_Name($$) {
    my($requested_ca, $cadesc_filename) = @_;
    my @fields = split /\./, $cadesc_filename;
    pop @fields; # drop ".cadesc" suffix
    foreach my $field (@fields) {
        return 1 if lc $requested_ca eq lc $field;
    }
    return 0;
} # Match_CA_Name

# ----------------------------------------------------------------------

#
# Given a string such as "1 hour" or "10 minutes", returns the number
# of seconds.  The numeric portion must be an integer, and exactly
# one unit may be specified, either seconds, minutes, hours, or days
# (trailing 's' optional).  If you want 1.5 hours, specify "90 minutes").
#
sub String_To_Seconds($) {
    my($timestamp) = lc $_[0];
    if ($timestamp =~ /^(\d+)\s+seconds?$/) {
        return $1;
    }
    elsif ($timestamp =~ /^(\d+)\s+minutes?$/) {
        return $1 * 60;
    }
    elsif ($timestamp =~ /^(\d+)\s+hours?$/) {
        return $1 * 3600;
    }
    elsif ($timestamp =~ /^(\d+)\s+days?$/) {
        return $1 * 86400;
    }
    else {
        return undef;
    }
} # String_To_Seconds

# ----------------------------------------------------------------------

#
# Given a non-negative number of seconds, returns a string such as
# "1m12s" or "32d 12h00m00s" for display.
#
# This function is not an exact inverse of String_To_Seconds();
# the formatting is different.
#
sub Seconds_To_String($) {
    use integer;
    my($total) = @_;
    die "Internal error: Seconds_To_String($total)" if $total < 0;
    my $seconds = $total % 60;
    $total = $total / 60;
    my $minutes = $total % 60;
    $total = $total / 60;
    my $hours = $total % 24;
    my $days = $total / 24;

    if ($days > 0) {
        return sprintf "%dd %02dh %02dm %02ds",
                       $days, $hours, $minutes, $seconds;
    }
    elsif ($hours > 0) {
        return sprintf "%dh %02dm %02ds",
                       $hours, $minutes, $seconds;
    }
    else {
        return sprintf "%dm %02ds",
                       $minutes, $seconds;
    }
} # Seconds_To_String

# ----------------------------------------------------------------------

#
# Given a timestamp, return a string of the form
# "Ddd YYYY-MM-DD HH:MM::SS UTC"
#
sub Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime $time;
    
    return sprintf "%s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec; 
} # Time_Image 

# ----------------------------------------------------------------------

#
# Given a reference to a CA description record, returns a multi-line
# string suitable for use as a signing_policy, compatible with both GT2
# and GT3.
#
sub Signing_Policy($) {
    my($ref) = @_;

    my $cond_subjects;
    if (ref $ref->{MAY_SIGN} eq 'ARRAY') {
        my @list = map { $_ = "\"$_\"" } @{$ref->{MAY_SIGN}};
        $cond_subjects = "'@list'";
    }
    else {
        $cond_subjects = "'$ref->{MAY_SIGN}'";
    }

    my $result = "# $ref->{CA_NAME} Signing Policy\n\n";

    my $body   = "access_id_CA   X509    '$ref->{SUBJECT}'\n" .
                 "pos_rights     globus  CA:sign\n" .
                 "cond_subjects  globus  $cond_subjects\n";

    my $gt2_body = Gridmap_Utils::GT2_Subject $body;
    my $gt3_body = Gridmap_Utils::GT3_Subject $body;

    $result .= $gt2_body;
    if ($gt3_body ne $gt2_body) {
        $result .= "\n";
        $result .= $gt3_body;
    }
    return $result;
} # Signing_Policy;

# ----------------------------------------------------------------------

#
# Given a date string, returns a raw timestamp (seconds since the epoch).
# The input string is assumed to be in the format printed by OpenSSL.
#
sub Date_To_Seconds($) {
    my($timestamp) = @_;
    my %month_num =
        ( Jan => 0, Feb => 1, Mar =>  2, Apr =>  3,
          May => 4, Jun => 5, Jul =>  6, Aug =>  7,
          Sep => 8, Oct => 9, Nov => 10, Dec => 11 );
    if ($timestamp =~
            /^([a-z][a-z][a-z]) \s+
              (\d+)\s+
              (\d+\d+):(\d+\d+):(\d+\d+) \s+
              (\d+) \s+
              (\w+) $/ix )
    {
        my $month_name = $1;
        my $mday = $2;
        my($hour, $minute, $second) = ($3, $4, $5);
        my($year) = $6;
        my($TZ) = uc $7;
        if (defined $month_num{$month_name} and
            ($TZ eq 'GMT' or $TZ eq 'UTC'))
        {
            return Time::Local::timegm
                      $second, $minute, $hour,
                      $mday, $month_num{$month_name}, $year;
        }
    }
    return undef;
} # Date_To_Seconds

# ----------------------------------------------------------------------

#
# Given the name of a cadesc file, returns a reference to a hash containing
# information about the CA.
#
sub Get_CA_Ref($) {
    my($filename) = @_;
    my $ref = Gridmap_Utils::Read_Records '-single', $filename;
    my @errors = ();

    $ref->{_FILENAME} = $filename;

    if (defined $ref->{DISABLE} and lc $ref->{DISABLE} eq 'yes') {
        return $ref;
    }

    my %valid = map { $_ => 1 } qw( CA_NAME HOMEPAGE CONTACT HASH
                                    SIGNED_BY SUBJECT MAY_SIGN
                                    CERTIFICATE_MD5 CERTIFICATE_URL
                                    SIGNING_POLICY_URL CRL_URL CRL_WARNING
                                    INDEX DISABLE
                                    _FILENAME );
    my @required = qw( CA_NAME HASH SUBJECT MAY_SIGN
                       CERTIFICATE_MD5 CERTIFICATE_URL );
    my %remap = ( SIGNED_BY => 1,
                  SUBJECT   => 1,
                  MAY_SIGN  => 1 );
                       
    foreach my $key (@required) {
        if (not defined $ref->{$key}) {
            push @errors, "Missing key $key\n";
        }
    }

    foreach my $key (sort keys %$ref) {
        if (not $valid{$key}) {
            push @errors, "Unrecognized key $key\n";
        }
        if ($key =~ /_URL$/) {
            if ($ref->{$key} ne '?' and $ref->{$key} !~ m<^(https?|ftp):>) {
                push @errors, "Bad value for $key\n";
            }
        }
        #
        # Map subject names to GT3-compatible forms.
        #
        if ($remap{$key}) {
            if (ref $ref->{$key} eq 'ARRAY') {
                map { $_ = Gridmap_Utils::GT3_Subject $_ } @{$ref->{$key}};
            }
            else {
                $ref->{$key} = Gridmap_Utils::GT3_Subject $ref->{$key};
            }
        }
    }
    if (defined $ref->{HASH} and $ref->{HASH} !~ /^[\da-f]{8}$/) {
        push @errors, "Invalid HASH\n";
    }
    if (defined $ref->{CRL_WARNING} and $ref->{CRL_WARNING} ne '?') {
        my $seconds = String_To_Seconds $ref->{CRL_WARNING};
        if (defined $seconds) {
            $ref->{CRL_WARNING_SECONDS} = $seconds;
        }
        else {
            push @errors, "Bad value for CRL_WARNING\n";
        }
    }
    if (defined $ref->{DISABLE} and lc $ref->{DISABLE} ne 'no') {
        push @errors, "Value for DISABLE must be \"yes\" or \"no\"\n";
    }

    if (@errors) {
        my $s = (scalar @errors != 1);
        Vprint ">>> Error$s in ${filename}:\n";
        Vprint @errors;
        return undef;
    }
    else {
        return $ref;
    }
} # Get_CA_Ref

# ----------------------------------------------------------------------

#
# Returns true if the DISABLE field in the *.cadesc file exists and is
# set to "yes", false otherwise.
#
sub Disabled($) {
    my($ref) = @_;
    return (defined $ref->{DISABLE} and lc $ref->{DISABLE} eq 'yes');
} # Disabled

# ----------------------------------------------------------------------

#
# Give a reference to a CRL description record, returns a reference to
# information about the CRL:
#     hash
#     issuer
#     last_update (raw timestamp)
#     next_update (raw timestamp)
#     lifetime    (in seconds)
#     used        (proportion of lifetime already used, e.g.
#                 0.0 if it was just issued,
#                 1.0 if it's just now expiring)
#     verified
#
# Returns undef if the hash, issuer, last_update, and next_update values
# cannot be determined.
#
sub CRL_Info($$) {
    my($CRL_file, $cert_file) = @_;
    my $result = {};

    return undef if not defined $CRL_file or not -r $CRL_file;

    #
    # Get attributes of CRL
    #
    open PIPE, "openssl crl -in $CRL_file -noout " .
               "-hash -issuer -lastupdate -nextupdate 2>&1 |" or return undef;
    while (<PIPE>) {
        chomp;
        if (/^[\da-f]{8}$/) {
            $result->{hash} = $_;
        }
        elsif (/^issuer=\s*(.*)$/) {
            $result->{issuer} = Gridmap_Utils::GT3_Subject $1;
        }
        elsif (/^lastUpdate=\s*(.*)$/) {
            $result->{last_update} = Date_To_Seconds $1;
        }
        elsif (/^nextUpdate=\s*(.*)$/) {
            $result->{next_update} = Date_To_Seconds $1;
        }
    }
    close PIPE;
    
    #
    # If we didn't get everything we need, don't return any information.
    #
    foreach my $key (qw(hash issuer last_update next_update)) {
        return undef if not defined $result->{$key};
    }

    $result->{lifetime} = $result->{next_update} - $result->{last_update};
    $result->{used} = ($now - $result->{last_update}) / $result->{lifetime};

    #
    # Verify CRL against certificate.
    # (If it's ok, openssl prints "verify OK" to stderr.)
    #
    if (defined $cert_file and -r $cert_file) {
        open PIPE, "openssl crl -in $CRL_file -noout " .
                   "-CAfile $cert_file 2>&1 |";
        while (<PIPE>) {
            if (/verify ok/i) {
                $result->{verified} = 1;
            }
        }
        close PIPE;
    }

    return $result;
} # CRL_Info

# ----------------------------------------------------------------------

#
# Given the name of a certificate file, returns a reference to information
# about the certificate:
#     hash
#     issuer
#     subject
#     md5sum
#     startdate (raw timestamp)
#     enddate   (raw timestamp)
#
# Returns undef if any of these fields cannot be determined.
#
sub Certificate_Info($) {
    my($cert_file) = @_;
    return undef if not -r $cert_file;
    my $result = {};
    open PIPE, "openssl x509 -in $cert_file -noout -hash -issuer -subject " .
               "-md5 -fingerprint -startdate -enddate |";
    while (<PIPE>) {
        chomp;
        if (/^[\da-f]{8}$/) {
            $result->{hash} = $_;
        }
        elsif (/^issuer=\s*(.*)$/) {
            $result->{issuer} = Gridmap_Utils::GT3_Subject $1;
        }
        elsif (/^subject=\s*(.*)$/) {
            $result->{subject} = Gridmap_Utils::GT3_Subject $1;
        }
        elsif (/^md5.*=\s*(.*)$/i) {
            $result->{md5sum} = $1;
        }
        elsif (/^notBefore=\s*(.*)$/) {
            $result->{startdate} = Date_To_Seconds $1;
        }
        elsif (/^notAfter=\s*(.*)$/) {
            $result->{enddate} = Date_To_Seconds $1;
        }
    }
    close PIPE;

    foreach my $key (qw(hash issuer subject md5sum startdate enddate)) {
        return undef if not defined $result->{$key};
    }

    return $result;
} # Certificate_Info

# ----------------------------------------------------------------------

#
# Update CA certificate if necessary.
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# Refuse to install an expired certificate, but leave it alone if
# it's already installed.
#
sub Update_Certificate($) {
    my($ref) = @_;

    if (not $User_Opt->{force} and -e $ref->{_CERT_FILE}) {
        Vprint "Skipping existing $ref->{_CERT_FILE}\n";
    }
    elsif ($ref->{CERTIFICATE_URL} =~ m<(https?|ftp)://>) {
        my $cache_file;
        eval {
            $cache_file = Gridmap_Utils::Cache_File
                              $ref->{CERTIFICATE_URL}
        };
        if (defined $@ and $@ ne '') {
            #
            # Error in Cache_File function
            #
            Error $ref, $@;
        }
        elsif (defined $cache_file and -r $cache_file) {
            my $cert_info = Certificate_Info $cache_file;
            if (defined $cert_info->{enddate}) {
                if ($cert_info->{enddate} < $now) {
                    Error $ref, "Certificate expired " .
                                Seconds_To_String
                                    ($now - $cert_info->{enddate}) .
                                " ago\n";
                }
            }
            else {
                Error $ref,
                      "Unable to determine certificate expiration date\n";
            }
            if ($cert_info->{hash} ne $ref->{HASH}) {
                Error $ref, "Mismatched hash, expected $ref->{HASH}, " .
                            "got $cert_info->{hash}\n";
            }
            if ($cert_info->{subject} ne $ref->{SUBJECT}) {
                Error $ref, "Mismatched subject, expected " .
                            "\"$ref->{SUBJECT}\", got " .
                            "\"$cert_info->{subject}\"\n";
            }
            if ($cert_info->{md5sum} ne $ref->{CERTIFICATE_MD5}) {
                Error $ref, "Mismatched md5 fingerprint, expected " .
                            "\"$ref->{CERTIFICATE_MD5}\", got " .
                            "\"$cert_info->{md5sum}\"\n";
            }

            if (not defined $ref->{_ERRORS}) {
                Vprint    "Installing $ref->{_CERT_FILE}\n";
                Log $ref, "Installing $ref->{_CERT_FILE}\n";
                File::Copy::copy $cache_file,"$ref->{_CERT_FILE}.$$"
                    or Error $ref, "Failed to copy certificate: $!\n";
                rename "$ref->{_CERT_FILE}.$$", $ref->{_CERT_FILE}
                    or Error $ref, "Failed to rename certificate: $!\n";
            }
        }
    }
    else {
        Vprint "No URL given for certificate\n";
    }
} # Update_Certificate

# ----------------------------------------------------------------------

#
# Update signing_policy file if necessary.
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# For now, we ignore the SIGNING_POLICY_URL; the signing_policy is
# generated from the MAY_SIGN attributes.
#
sub Update_Signing_Policy($) {
    my($ref) = @_;
    if (not $User_Opt->{force} and -e $ref->{_SIGNING_POLICY_FILE}) {
        Vprint "Skipping existing $ref->{_SIGNING_POLICY_FILE}\n";
    }
    else {
        Vprint    "Creating $ref->{_SIGNING_POLICY_FILE}\n";
        Log $ref, "Creating $ref->{_SIGNING_POLICY_FILE}\n";
        open POLICY, ">$ref->{_SIGNING_POLICY_FILE}"
            or die "$ref->{_SIGNING_POLICY_FILE}: $!\n";
        print POLICY Signing_Policy $ref;
        close POLICY;
    }
} # Update_Signing_Policy

# ----------------------------------------------------------------------

#
# Update CRL if necessary
#
sub Update_CRL($) {
    my($ref) = @_;
    my $old_crl_info = CRL_Info $ref->{_CRL_FILE}, $ref->{_CERT_FILE};
    my $install_new_crl = 0;

    my $have_crl_url = $ref->{CRL_URL} =~ m<(https?|ftp)://>;
    my $new_crl_file = undef;
    if ($have_crl_url) {
        #
        # Attempt to download a new CRL (or use a cached copy)
        #
        eval { $new_crl_file = Gridmap_Utils::Cache_File $ref->{CRL_URL} };
        if (defined $@ and $@ ne '') {
            #
            # Error in Cache_File function
            #
            Error $ref, $@;
        }
    }
    my $new_crl_info = CRL_Info $new_crl_file, $ref->{_CERT_FILE};

    if (defined $new_crl_info) {
        #
        # We have a new CRL; decide whether to install it.
        #
        my $remaining = $new_crl_info->{next_update} - $now;
        if ($remaining <= 0) {
            Error $ref, "Newly downloaded CRL has expired\n";
        }
        elsif (defined $CRL_Expiration and $remaining < $CRL_Expiration) {
            Error $ref, "Newly downloaded CRL expires in " .
                        Seconds_To_String($remaining) .
                        ", not installing\n";
        }
        elsif (not $new_crl_info->{verified}) {
            Error $ref, "Can't verify new CRL\n";
        }
        elsif (defined $old_crl_info) {
            #
            # We have an old CRL and a new CRL; decide whether to
            # replace the old one with the new one.
            #
            if ($new_crl_info->{last_update} == $old_crl_info->{last_update} and
                $new_crl_info->{next_update} == $old_crl_info->{next_update})
            {
                Vprint "CRL update not needed\n";
            }
            elsif ($new_crl_info->{next_update} <
                   $old_crl_info->{next_update})
            {
                Error $ref, "Newly downloaded CRL expires sooner " .
                            "than old CRL, not installing\n";
            }
            else {
                $install_new_crl = 1;
            }
        }
        else {
            $install_new_crl = 1;
        }
    }
    else {
        #
        # We don't have a new CRL
        #
        if (not $have_crl_url) {
            Vprint "No URL given for CRL\n";
        }
        else {
            Error $ref, "Unable to get information for CRL\n";
        }
    }

    if ($install_new_crl) {
        Vprint    "Installing $ref->{_CRL_FILE}\n";
        Log $ref, "Installing $ref->{_CRL_FILE}\n";
        File::Copy::copy $new_crl_file, "$ref->{_CRL_FILE}.$$"
            or Error $ref, "Failed to copy CRL: $!\n";
        rename "$ref->{_CRL_FILE}.$$", $ref->{_CRL_FILE}
            or Error $ref, "Failed to rename CRL: $!\n";
    }

    #
    # Just to be sure, re-fetch CRL info from the target CRL file
    # (which may or may not have just been updated).
    #
    if (-r $ref->{_CRL_FILE}) {
        my $crl_info = CRL_Info $ref->{_CRL_FILE}, $ref->{_CERT_FILE};
        my $remaining = $crl_info->{next_update} - $now;
        my $remove_crl = 0;
        if (defined $crl_info) {
            if (not $crl_info->{verified}) {
                Error $ref, "Removing unverified CRL\n";
                $remove_crl = 1;
            }
            elsif (defined $CRL_Expiration and
                   $remaining < $CRL_Expiration)
            {
                Error $ref, "CRL will expire in " .
                            Seconds_To_String($remaining) .
                            ", removing it\n";
                $remove_crl = 1;
            }
            if ($remove_crl) {
                unlink $ref->{_CRL_FILE};
            }
            else {
                my $expiration_string = Time_Image $crl_info->{next_update};
                my $how_long = Seconds_To_String abs $remaining;
                my $notify = 0;
#               if (defined $ref->{CRL_WARNING_SECONDS} and
#                   $remaining <= $ref->{CRL_WARNING_SECONDS})
#               {
#                   $notify = 1;
#               }
                if ($crl_info->{used} > 0.9) {
                    $notify = 1;
                }
                if ($remaining < 0) {
                    Error $ref, "CRL expired at $expiration_string " .
                                "($how_long ago)\n";
                }
                elsif ($remaining == 0) {
                    Error $ref, "CRL expires at $expiration_string\n";
                }
                else {
                    if ($notify) {
                        Error $ref, "CRL will expire at $expiration_string " .
                                    "($how_long from now)\n";
                    }
                    else {
                        Vprint "CRL will expire at $expiration_string " .
                               "($how_long from now)\n";
                    }
                }
                if (not $crl_info->{verified}) {
                    Error $ref, "CRL is not verified\n";
                }
            }
        }
    }
    else {
        Vprint"No CRL\n";
    }
} # Update_CRL

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name [options]
    -help              Display this message and exit
    -version           Display version information and exit
    -ca name           Name of a CA.  This argument may be given multiple
                       times, or CA names may be delimited by commas or
                       blanks.  The argument is a field of the *.cadesc
                       file name; use the hash value to avoid ambiguity
    -ca ALL            Use all available CAs
    -list-cas          List available CAs and exit
    -target-dir dir    Target directory
    -expire-crl time   Remove a CRL that will expire within
                       "time".  "time" is expressed as a number
                       followed by 's' (seconds), 'm' (minutes),
                       'h' (hours) or 'd' (days); for example
                       "-expire-crl 75m".  By default, expiring CRLs
                       are left in place.
    -force             Force file updates (applies to certificate and
                       signing_policy files)
    -ignore-disable    Ignore "DISABLE" attribute in cadesc files.
    -email             Send e-mail to configured ADMIN_EMAIL address on errors.
                       Default is "-email"; use "-noemail" to disable.
    -verbose           Print verbose messages
    -debugging         Enable debugging output
EOF
    exit 1;
} # Usage

# ----------------------------------------------------------------------

#
# Log a message.
# Annotate the CA reference (first argument) with the message.
#
sub Log($$) {
    my($ref, $message) = @_;
    push @{$ref->{_MESSAGES}}, $message;
} # Log

# ----------------------------------------------------------------------

#
# Report an error.
# Annotate the CA reference (first argument) with the error message.
#
sub Error($$) {
    my($ref, $message) = @_;
    push @{$ref->{_ERRORS}}, $message;
} # Error

# ----------------------------------------------------------------------

#
# Send an error notification by e-mail.
# Log messages to log file.
#
sub Notify() {
    my $total_ca_count = scalar @ca_info;
    my $error_ca_count = 0;
    my $error_count = 0;
    my $message_body = '';

    my $log_file = "$Install_Dir/var/$Program_Name.log";
    open LOG, ">>$log_file";
    print LOG Time_Image $now, " $Program_Name\n";

    foreach my $ref (@ca_info) {
        if (defined $ref->{_ERRORS}) {
            $error_ca_count ++;
            $error_count += scalar @{$ref->{_ERRORS}};
        }
    }

    foreach my $ref (@ca_info) {
        if (defined $ref->{_MESSAGES} or defined $ref->{_ERRORS}) {
            print LOG "$ref->{HASH} $ref->{CA_NAME}:\n";

            if (defined $ref->{_MESSAGES}) {
                foreach my $message (@{$ref->{_MESSAGES}}) {
                    print LOG "    $message";
                }
            }

            if (defined $ref->{_ERRORS}) {
                my @error_list = @{$ref->{_ERRORS}};
                $message_body .= "$ref->{HASH} $ref->{CA_NAME}:\n";
                $message_body .= join '', @error_list;
                $message_body .= "\n";
                foreach my $error (@error_list) {
                    print LOG "    >>> ERROR: $error";
                }
            }
        }
    }

    print LOG "\n";
    close LOG;

    if ($User_Opt->{email} and $error_count > 0) {
        my $subject = "$Program_Name: $error_count error(s), " .
                      "$error_ca_count/$total_ca_count CA(s)";

        my $recipient = $Gridmap_Utils::Config{ADMIN_EMAIL};
        my $mail_program = undef;
        if (-x '/bin/mailx') {
            $mail_program = '/bin/mailx';
        }
        elsif (-x '/bin/mail') {
            $mail_program = '/bin/mail';
        }

        if (defined $mail_program) {
            open PIPE, "| $mail_program -s '$subject' $recipient";
            print PIPE $message_body;
            close PIPE;
        }
    }
} # Notify

# ----------------------------------------------------------------------

#
# Print a message if "-verbose" option was given
#
sub Vprint(@) {
    print @_ if $User_Opt->{verbose};
} # Vprint

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug
