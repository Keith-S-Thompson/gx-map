#!%PERL% -w
# To do: Add '-T'

# $Id: gx-ca-update.in,v 1.18 2004-09-27 15:42:19-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-ca-update.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2004 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use Getopt::Long ();
use Time::Local ();

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

sub Match_CA_Name($$);
sub String_To_Seconds($);
sub Seconds_To_String($);
sub Time_Image($);
sub Signing_Policy($);
sub Date_To_Seconds($);
sub CRL_Info($$);
sub Certificate_Expiration($);
sub Update_Certificate($);
sub Update_Signing_Policy($);
sub Update_CRL($);
sub Usage(@);
sub Log($$);
sub Error($$);
sub Vprint(@);
sub Notify();
sub Debug(@);

my $Program_Name = File::Basename::basename $0;
my $now = time;

my $User_Opt = {};
my @Opts = ( $User_Opt,
             qw( help!
                 version!
                 ca=s@
                 list-cas!
                 target-dir=s
                 expire-crl=s
                 force!
                 verbose!
                 debugging! ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;

if ($User_Opt->{version}) {
    print "gx-ca-update, part of gx-map version $Gridmap_Utils::VERSION\n";
    exit 0;
}

my $ca_conf_dir = "$Install_Dir/var/ca.conf";
my @ca_list_all;

opendir CONF_DIR, $ca_conf_dir or die "$ca_conf_dir: $!\n";
@ca_list_all = sort grep /\.cadesc$/, readdir CONF_DIR;
closedir CONF_DIR;

if ($User_Opt->{'list-cas'}) {
    foreach my $ca (@ca_list_all) {
        $ca =~ s/\.cadesc$//;
        $ca =~ s/\./ /g;
        print "$ca\n";
    }
    exit 0;
}

if (not defined $User_Opt->{ca}) {
    Usage "No CA specified\n"
}
if (not defined $User_Opt->{'target-dir'}) {
    Usage "No target directory specified\n"
}

my $CRL_Expiration = undef;
if (defined $User_Opt->{'expire-crl'}) {
    if ($User_Opt->{'expire-crl'} =~ /^(\d+)([smhd])$/) {
        $CRL_Expiration = $1;
        if    ($2 eq 'm') { $CRL_Expiration *= 60 }
        elsif ($2 eq 'h') { $CRL_Expiration *= 3600 }
        elsif ($2 eq 'd') { $CRL_Expiration *= 86400 }
    }
    else {
        Usage "Invalid argument to -expire-url option\n";
    }
}

if ($User_Opt->{debugging}) {
    foreach my $opt (sort keys %$User_Opt) {
        print "$opt => ";
        if (defined $User_Opt->{$opt}) {
            if (ref $User_Opt->{$opt} eq 'ARRAY') {
                print "[\n";
                foreach my $item (@{$User_Opt->{$opt}}) {
                    print "    $item\n";
                }
                print "]\n";
            }
            else {
                print "\"$User_Opt->{$opt}\"\n";
            }
        }
        else {
            print "undef\n";
        }
    }
}

if (scalar @ca_list_all == 0) {
    die "No *.cadesc files in $ca_conf_dir\n";
}

my %selected = ();

my @requested_ca_list = ();
foreach my $arg (@{$User_Opt->{ca}}) {
    push @requested_ca_list, split /[ ,]/, $arg;
}

foreach my $requested_ca (@requested_ca_list) {
    if ($requested_ca eq 'ALL') {
        %selected = map { $_ => 1 } @ca_list_all;
    }
    else {
        foreach my $ca (@ca_list_all) {
            if (Match_CA_Name $requested_ca, $ca) {
                $selected{$ca} = 1;
            }
        }
    }
}

my @ca_list = grep $selected{$_}, @ca_list_all;

if (scalar @ca_list == 0) {
    die "No CAs selected\n";
}

my @ca_info = ();

foreach my $ca_desc_file (@ca_list) {
    #
    # To do: Verify that the cadesc file has all the required
    # fields; if not, issue a warning and ignore the file.
    #
    my $ref = Gridmap_Utils::Read_Records
                  '-single', "$ca_conf_dir/$ca_desc_file";
    if (defined $ref->{CRL_WARNING}) {
        my $seconds = String_To_Seconds $ref->{CRL_WARNING};
        $ref->{CRL_WARNING_SECONDS} = $seconds if defined $seconds;
    }
    push @ca_info, $ref;
}

Debug "Got ", scalar @ca_info, " ca record(s):\n";
if ($User_Opt->{debugging}) {
    Gridmap_Utils::Write_Records '-multiple', '-', @ca_info;
}

Gridmap_Utils::Use_Commands 'cp', 'openssl';

Gridmap_Utils::Init_Cache_Info;

foreach my $ref (@ca_info) {
    Vprint "Processing $ref->{HASH} $ref->{CA_NAME}\n";

    my $prefix = "$User_Opt->{'target-dir'}/$ref->{HASH}";
    $ref->{_CERT_FILE}           = "$prefix.0";
    $ref->{_SIGNING_POLICY_FILE} = "$prefix.signing_policy";
    $ref->{_CRL_FILE}            = "$prefix.r0";

    Update_Certificate    $ref;
    Update_Signing_Policy $ref;
    Update_CRL            $ref;

    if (defined $ref->{_ERRORS}) {
        foreach my $error (@{$ref->{_ERRORS}}) {
            Vprint ">>> $error\n";
        }
    }

    Vprint "\n";
}

Notify;

########################################################################

#
# Given an argument to the "-ca" option and the name of a *.cadesc
# file, return true iff the requested CA name matches a subfield of the
# file name.
#
sub Match_CA_Name($$) {
    my($requested_ca, $cadesc_filename) = @_;
    my @fields = split /\./, $cadesc_filename;
    pop @fields; # drop ".cadesc" suffix
    foreach my $field (@fields) {
        return 1 if lc $requested_ca eq lc $field;
    }
    return 0;
} # Match_CA_Name

# ----------------------------------------------------------------------

#
# Given a string such as "1 hour" or "10 minutes", returns the number
# of seconds.  The numeric portion must be an integer, and exactly
# one unit may be specified, either seconds, minutes, hours, or days
# (trailing 's' optional).  If you want 1.5 hours, specify "90 minutes").
#
sub String_To_Seconds($) {
    my($timestamp) = lc $_[0];
    if ($timestamp =~ /^(\d+)\s+seconds?$/) {
        return $1;
    }
    elsif ($timestamp =~ /^(\d+)\s+minutes?$/) {
        return $1 * 60;
    }
    elsif ($timestamp =~ /^(\d+)\s+hours?$/) {
        return $1 * 3600;
    }
    elsif ($timestamp =~ /^(\d+)\s+days?$/) {
        return $1 * 86400;
    }
    else {
        return undef;
    }
} # String_To_Seconds

# ----------------------------------------------------------------------

#
# Given a non-negative number of seconds, returns a string such as
# "1m12s" or "32d 12h00m00s" for display.
#
# This function is not an exact inverse of String_To_Seconds();
# the formatting is different.
#
sub Seconds_To_String($) {
    use integer;
    my($total) = @_;
    die "Internal error: Seconds_To_String($total)" if $total < 0;
    my $seconds = $total % 60;
    $total = $total / 60;
    my $minutes = $total % 60;
    $total = $total / 60;
    my $hours = $total % 24;
    my $days = $total / 24;

    if ($days > 0) {
        return sprintf "%dd %02dh %02dm %02ds",
                       $days, $hours, $minutes, $seconds;
    }
    elsif ($hours > 0) {
        return sprintf "%dh %02dm %02ds",
                       $hours, $minutes, $seconds;
    }
    else {
        return sprintf "%dm %02ds",
                       $minutes, $seconds;
    }
} # Seconds_To_String

# ----------------------------------------------------------------------

#
# Given a timestamp, return a string of the form
# "Ddd YYYY-MM-DD HH:MM::SS UTC"
#
sub Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime $time;
    
    return sprintf "%s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec; 
} # Time_Image 

# ----------------------------------------------------------------------

#
# Given a reference to a CA description record, returns a multi-line
# string suitable for use as a signing_policy, compatible with both GT2
# and GT3.
#
sub Signing_Policy($) {
    my($ref) = @_;

    my $cond_subjects;
    if (ref $ref->{MAY_SIGN} eq 'ARRAY') {
        my @list = map { $_ = "\"$_\"" } @{$ref->{MAY_SIGN}};
        $cond_subjects = "'@list'";
    }
    else {
        $cond_subjects = "'$ref->{MAY_SIGN}'";
    }

    my $result = "# $ref->{CA_NAME} Signing Policy\n\n";

    my $body   = "access_id_CA   X509    '$ref->{SUBJECT}'\n" .
                 "pos_rights     globus  CA:sign\n" .
                 "cond_subjects  globus  $cond_subjects\n";

    my $gt2_body = $body;
    $gt2_body =~ s(/0\.9\.2342\.19200300\.100\.1\.1=)(/USERID=)g;
    $gt2_body =~ s(/UID=)(/USERID=)g;
    $gt2_body =~ s(/emailAddress=)(/Email=)g;

    my $gt3_body = $body;
    $gt3_body =~ s(/0\.9\.2342\.19200300\.100\.1\.1=)(/UID=)g;
    $gt3_body =~ s(/USERID=)(/UID=)g;
    $gt3_body =~ s(/Email=)(/emailAddress=)g;

    $result .= $gt2_body;
    if ($gt3_body ne $gt2_body) {
        $result .= "\n";
        $result .= $gt3_body;
    }
    return $result;
} # Signing_Policy;

# ----------------------------------------------------------------------

#
# Given a date string, returns a raw timestamp (seconds since the epoch).
# The input string is assumed to be in the format printed by OpenSSL.
#
sub Date_To_Seconds($) {
    my($timestamp) = @_;
    my %month_num =
        ( Jan => 0, Feb => 1, Mar =>  2, Apr =>  3,
          May => 4, Jun => 5, Jul =>  6, Aug =>  7,
          Sep => 8, Oct => 9, Nov => 10, Dec => 11 );
    if ($timestamp =~
            /^([a-z][a-z][a-z]) \s+
              (\d+)\s+
              (\d+\d+):(\d+\d+):(\d+\d+) \s+
              (\d+) \s+
              (\w+) $/ix )
    {
        my $month_name = $1;
        my $mday = $2;
        my($hour, $minute, $second) = ($3, $4, $5);
        my($year) = $6;
        my($TZ) = uc $7;
        if (defined $month_num{$month_name} and
            ($TZ eq 'GMT' or $TZ eq 'UTC'))
        {
            return Time::Local::timegm
                      $second, $minute, $hour,
                      $mday, $month_num{$month_name}, $year;
        }
    }
    return undef;
} # Date_To_Seconds

# ----------------------------------------------------------------------

#
# Give a reference to a CRL description record, returns a reference to
# information about the CRL:
#     hash
#     issuer
#     last_update
#     next_update
#     verified
#
sub CRL_Info($$) {
    my($CRL_file, $cert_file) = @_;
    my $result = {};

    return undef if not defined $CRL_file or not -r $CRL_file;

    #
    # Get attributes of CRL
    #
    open PIPE, "openssl crl -in $CRL_file -noout " .
               "-hash -issuer -lastupdate -nextupdate |" or return undef;
    while (<PIPE>) {
        chomp;
        if (/^[\0-9a-f]{8}$/) {
            $result->{hash} = $_;
        }
        elsif (/^issuer=\s*(.*)$/) {
            $result->{issuer} = $1;
        }
        elsif (/^lastUpdate=\s*(.*)$/) {
            $result->{last_update} = Date_To_Seconds $1;
        }
        elsif (/^nextUpdate=\s*(.*)$/) {
            $result->{next_update} = Date_To_Seconds $1;
        }
    }
    close PIPE;
    
    #
    # Verify CRL against certificate.
    # (If it's ok, openssl prints "verify OK" to stderr.)
    #
    if (defined $cert_file and -r $cert_file) {
        open PIPE, "openssl crl -in $CRL_file -noout " .
                   "-CAfile $cert_file 2>&1 |";
        while (<PIPE>) {
            if (/verify ok/i) {
                $result->{verified} = 1;
            }
        }
        close PIPE;
    }

    return $result;
} # CRL_Info

# ----------------------------------------------------------------------

#
# Given the name of a certificate file, return its expiration date.
#
sub Certificate_Expiration($) {
    my($cert_file) = @_;
    my $result = undef;
    return undef if not -r $cert_file;
    open PIPE, "openssl x509 -in $cert_file -noout -enddate |" or return undef;
    while (<PIPE>) {
        if (/^notAfter=\s*(.*)$/) {
            $result = Date_To_Seconds $1;
        }
    }
    return $result;
} # Certificate_Expiration

# ----------------------------------------------------------------------

#
# Update CA certificate if necessary.
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# Refuse to install an expired certificate, but leave it alone if
# it's already installed.
#
sub Update_Certificate($) {
    my($ref) = @_;

    if (not $User_Opt->{force} and -e $ref->{_CERT_FILE}) {
        Vprint "Skipping existing $ref->{_CERT_FILE}\n";
    }
    elsif ($ref->{CERTIFICATE_URL} =~ m<(http|ftp)://>) {
        my $cache_file;
        eval { $cache_file = Gridmap_Utils::Cache_File $ref->{CERTIFICATE_URL} };
        if (defined $@ and $@ ne '') {
            #
            # Error in Cache_File function
            #
            Error $ref, $@;
        }
        elsif (defined $cache_file and -r $cache_file) {
            my $expire = Certificate_Expiration $cache_file;
            if (defined $expire) {
                if ($expire < $now) {
                    Error $ref, "Certificate expired " .
                                Seconds_To_String($now - $expire) .
                                " ago\n";
                }
                else {
                    Vprint    "Installing $ref->{_CERT_FILE}\n";
                    Log $ref, "Installing $ref->{_CERT_FILE}\n";
                    system 'cp', '-p', '-f', $cache_file,
                                             "$ref->{_CERT_FILE}.$$";
                    rename "$ref->{_CERT_FILE}.$$", $ref->{_CERT_FILE};
                }
            }
            else {
                Error $ref, "Unable to determine certificate expiration date\n";
            }
        }
    }
    else {
        Vprint "No URL given for certificate\n";
    }
} # Update_Certificate

# ----------------------------------------------------------------------

#
# Update signing_policy file if necessary.
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# For now, we ignore the SIGNING_POLICY_URL; the signing_policy is
# generated from the MAY_SIGN attributes.
#
sub Update_Signing_Policy($) {
    my($ref) = @_;
    if (not $User_Opt->{force} and -e $ref->{_SIGNING_POLICY_FILE}) {
        Vprint "Skipping existing $ref->{_SIGNING_POLICY_FILE}\n";
    }
    else {
        Vprint    "Creating $ref->{_SIGNING_POLICY_FILE}\n";
        Log $ref, "Creating $ref->{_SIGNING_POLICY_FILE}\n";
        open POLICY, ">$ref->{_SIGNING_POLICY_FILE}"
            or die "$ref->{_SIGNING_POLICY_FILE}: $!\n";
        print POLICY Signing_Policy $ref;
        close POLICY;
    }
} # Update_Signing_Policy

# ----------------------------------------------------------------------

#
# Update CRL if necessary
#
sub Update_CRL($) {
    my($ref) = @_;
    my $old_crl_info = CRL_Info $ref->{_CRL_FILE}, $ref->{_CERT_FILE};
    my $install_new_crl = 0;

    my $have_crl_url = $ref->{CRL_URL} =~ m<(http|ftp)://>;
    my $new_crl_file = undef;
    if ($have_crl_url) {
        #
        # Attempt to download a new CRL (or use a cached copy)
        #
        eval { $new_crl_file = Gridmap_Utils::Cache_File $ref->{CRL_URL} };
        if (defined $@ and $@ ne '') {
            #
            # Error in Cache_File function
            #
            Error $ref, $@;
        }
    }
    my $new_crl_info = CRL_Info $new_crl_file, $ref->{_CERT_FILE};

    if (defined $new_crl_info) {
        #
        # We have a new CRL; decide whether to install it.
        #
        my $remaining = $new_crl_info->{next_update} - $now;
        if ($remaining <= 0) {
            Error $ref, "Newly downloaded CRL has expired\n";
        }
        elsif (defined $CRL_Expiration and $remaining < $CRL_Expiration) {
            Error $ref, "Newly downloaded CRL expires in " .
                          Seconds_To_String($remaining) .
                          ", not installing\n";
        }
        elsif (not $new_crl_info->{verified}) {
            Error $ref, "Can't verify new CRL\n";
        }
        elsif (defined $old_crl_info) {
            #
            # We have an old CRL and a new CRL; decide whether to
            # replace the old one with the new one.
            #
            if ($new_crl_info->{last_update} == $old_crl_info->{last_update} and
                $new_crl_info->{next_update} == $old_crl_info->{next_update})
            {
                Vprint "CRL update not needed\n";
            }
            elsif ($new_crl_info->{next_update} <
                   $old_crl_info->{next_update})
            {
                Error $ref, "Newly downloaded CRL expires sooner " .
                            "than old CRL, not installing\n";
            }
            else {
                $install_new_crl = 1;
            }
        }
        else {
            $install_new_crl = 1;
        }
    }
    else {
        #
        # We don't have a new CRL
        #
        if (not $have_crl_url) {
            Vprint "No URL given for CRL\n";
        }
        else {
            Error $ref, "Unable to get information for CRL\n";
        }
    }

    if ($install_new_crl) {
        Vprint    "Installing $ref->{_CRL_FILE}\n";
        Log $ref, "Installing $ref->{_CRL_FILE}\n";
        system 'cp', '-p', $new_crl_file, "$ref->{_CRL_FILE}.$$";
        rename "$ref->{_CRL_FILE}.$$", $ref->{_CRL_FILE};
    }

    #
    # Just to be sure, re-fetch CRL info from the target CRL file
    # (which may or may not have just been updated).
    #
    if (-r $ref->{_CRL_FILE}) {
        my $crl_info = CRL_Info $ref->{_CRL_FILE}, $ref->{_CERT_FILE};
        my $remaining = $crl_info->{next_update} - $now;
        my $remove_crl = 0;
        if (defined $crl_info) {
            if (not $crl_info->{verified}) {
                Error $ref, "Removing unverified CRL\n";
                $remove_crl = 1;
            }
            elsif (defined $CRL_Expiration and
                   $remaining < $CRL_Expiration)
            {
                Error $ref, "CRL will expire in " .
                            Seconds_To_String($remaining) .
                            ", removing it\n";
                $remove_crl = 1;
            }
            if ($remove_crl) {
                unlink $ref->{_CRL_FILE};
            }
            else {
                my $how_long = Seconds_To_String abs $remaining;
                my $notify = 0;
                if (defined $ref->{CRL_WARNING_SECONDS} and
                    $remaining <= $ref->{CRL_WARNING_SECONDS})
                {
                    $notify = 1;
                }
                if ($remaining < 0) {
                    Error $ref, "CRL expired $how_long ago\n";
                }
                elsif ($remaining == 0) {
                    Error $ref, "CRL expires NOW\n";
                }
                else {
                    if ($notify) {
                        Error $ref, "CRL expires in $how_long\n";
                    }
                    else {
                        Vprint "CRL expires in $how_long\n";
                    }
                }
                if (not $crl_info->{verified}) {
                    Error $ref, "CRL is not verified\n";
                }
            }
        }
    }
    else {
        Vprint"No CRL\n";
    }
} # Update_CRL

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name [options]
    -help              Display this message and exit
    -version           Display version information and exit
    -ca name           Name of a CA.  This argument may be given multiple
                       times, or CA names may be delimited by commas or
                       blanks.  The argument is a field of the *.cadesc
                       file name; use the hash value to avoid ambiguity
    -ca ALL            Use all available CAs
    -list-cas          List available CAs and exit
    -target-dir dir    Target directory
    -expire-crl time   Remove a CRL that will expire within
                       "time".  "time" is expressed as a number
                       followed by 's' (seconds), 'm' (minutes),
                       'h' (hours) or 'd' (days); for example
                       "-expire-crl 75m".  By default, expiring CRLs
                       are left in place.
    -force             Force file updates (applies to certificate and
                       signing_policy files)
    -verbose           Print verbose messages
    -debugging         Enable debugging output
EOF
    exit 1;
} # Usage

# ----------------------------------------------------------------------

#
# Log a message.
# Annotate the CA reference (first argument) with the message.
#
sub Log($$) {
    my($ref, $message) = @_;
    push @{$ref->{_MESSAGES}}, $message;
} # Log

# ----------------------------------------------------------------------

#
# Report an error.
# Annotate the CA reference (first argument) with the error message.
#
sub Error($$) {
    my($ref, $message) = @_;
    push @{$ref->{_ERRORS}}, $message;
} # Error

# ----------------------------------------------------------------------

#
# Send an error notification by e-mail.
# Log messages to log file.
#
sub Notify() {
    my $total_ca_count = scalar @ca_info;
    my $error_ca_count = 0;
    my $error_count = 0;
    my $message_body = '';

    my $log_file = "$Install_Dir/var/$Program_Name.log";
    open LOG, ">>$log_file";
    print LOG Time_Image $now, " $Program_Name\n";

    foreach my $ref (@ca_info) {
        if (defined $ref->{_ERRORS}) {
            $error_ca_count ++;
            $error_count += scalar @{$ref->{_ERRORS}};
        }
    }

    foreach my $ref (@ca_info) {
        if (defined $ref->{_MESSAGES} or defined $ref->{_ERRORS}) {
            print LOG "$ref->{HASH} $ref->{CA_NAME}:\n";

            if (defined $ref->{_MESSAGES}) {
                foreach my $message (@{$ref->{_MESSAGES}}) {
                    print LOG "    $message";
                }
            }

            if (defined $ref->{_ERRORS}) {
                my @error_list = @{$ref->{_ERRORS}};
                $message_body .= "$ref->{HASH} $ref->{CA_NAME}:\n";
                $message_body .= join '', @error_list;
                $message_body .= "\n";
                foreach my $error (@error_list) {
                    print LOG "    ERROR: $error";
                }
            }
        }
    }

    print LOG "\n";
    close LOG;

    if ($error_count > 0) {
        my $subject = "$Program_Name: $error_count error(s), " .
                      "$error_ca_count/$total_ca_count CA(s)";

        my $recipient = $Gridmap_Utils::Config{ADMIN_EMAIL};
        my $mail_program = undef;
        if (-x '/bin/mailx') {
            $mail_program = '/bin/mailx';
        }
        elsif (-x '/bin/mail') {
            $mail_program = '/bin/mail';
        }

        if (defined $mail_program) {
            open PIPE, "| $mail_program -s '$subject' $recipient";
            print PIPE $message_body;
            close PIPE;
        }
    }
} # Notify

# ----------------------------------------------------------------------

#
# Print a message if "-verbose" option was given
#
sub Vprint(@) {
    print @_ if $User_Opt->{verbose};
} # Vprint

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug
