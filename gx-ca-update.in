#!%PERL% -wT

# $Id: gx-ca-update.in,v 1.84 2005-12-14 00:52:14-08 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-ca-update.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2005 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use File::Copy ();
use Getopt::Long ();

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

sub Read_CA_List_File($);
sub Match_CA_Name($$);
sub String_To_Seconds($);
sub Seconds_To_String($);
sub Signing_Policy($);
sub Get_CA_Ref($);
sub Disabled($);
sub Allow_Missing_CRL($);
sub CRL_Info($$);
sub Certificate_Info($);
sub Update_Certificate($);
sub Update_CRL($);
sub Install_Certificate($);
sub Update_Signing_Policy($);
sub Check_Dependencies();
sub Log($$);
sub Error($$$$);
sub Vprint(@);
sub Notify();
sub Debug(@);
sub Usage(@);

my $Program_Name = File::Basename::basename $0;
my $now = time;
my $Hostname = Gridmap_Utils::Get_Hostname();

my $User_Opt = { permissions => '444',
                 email => 1 };
my @Opts = ( $User_Opt,
             qw( help!
                 version!
                 unsafe!
                 U! UN! UNS! UNSA! UNSAF!
                 UNSAFE!
                 ca=s@
                 ca-list=s@
                 all-cas!
                 list-cas!
                 target-dir=s
                 permissions=s
                 allow-missing-crl!
                 expire-crl=s
                 warn-crl=s
                 force!
                 ignore-disable!
                 email!
                 verbose!
                 debugging! ) );
$Getopt::Long::ignorecase = 0; # options are case-sensitive
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;

if ($User_Opt->{version}) {
    print "$Program_Name (gx-map) $Gridmap_Utils::VERSION\n";
    exit 0;
}

#
# This program may only be executed by the GX_MAP_OWNER.
#
Gridmap_Utils::Require_Owner $Program_Name;

$Gridmap_Utils::Debugging = 1 if $User_Opt->{debugging};

$| = 1 if $User_Opt->{verbose};

if (defined $User_Opt->{unsafe}) {
    Usage "The \"-UNSAFE\" option is case-sensitive\n";
}
foreach my $opt (qw(U UN UNS UNSA UNSAF)) {
    if (defined $User_Opt->{$opt}) {
        Usage "The \"-UNSAFE\" option must be spelled out in full\n";
    }
}

if (not $User_Opt->{UNSAFE}) {
    my @errors = ();
    foreach my $opt ( qw( all-cas
                          allow-missing-crl
                          expire-crl
                          ignore-disable ) )
    {
        if (defined $User_Opt->{$opt}) {
            push @errors, "The \"$opt\" option is disabled " .
                          "(use \"-UNSAFE\" to enable it).\n";
        }
    }
    Usage @errors if @errors;
}

if ($User_Opt->{'all-cas'}
    and
    (defined $User_Opt->{ca} or defined $User_Opt->{'ca-list'}))
{
    Usage "The \"-all-cas\" options may not be used " .
          "with \"-ca\" or \"-ca-list\"\n";
}

my $Data_Dir = "$Install_Dir/var";
my $lock_file = "$Data_Dir/.gx-ca-update.lock";

my $ca_conf_dir = "$Install_Dir/etc/ca-config";
my @ca_list_all;
my $requested_all = undef; # true if user specified "-all-cas"

Gridmap_Utils::Install_Die_Handler;
Gridmap_Utils::Install_Warn_Handler;

opendir my $Conf_Dir, $ca_conf_dir or die "$ca_conf_dir: $!\n";
@ca_list_all = sort
                   grep { /\.cadesc$/ and not /^00000000\./ }
                       readdir $Conf_Dir;
closedir $Conf_Dir;

if ($User_Opt->{'list-cas'}) {
    foreach my $ca (@ca_list_all) {
        #
        # This clobbers the contents of @ca_list_all, but that's ok
        # since we're going to exit.
        #
        $ca =~ s/\.cadesc$//;
        $ca =~ s/\./ /g;
        print "$ca\n";
    }
    exit 0;
}

if (not $User_Opt->{'all-cas'} and
    not defined $User_Opt->{ca} and
    not defined $User_Opt->{'ca-list'})
{
    Usage "No CA specified\n"
}

if (not defined $User_Opt->{'target-dir'}) {
    Usage "No target directory specified\n"
}
elsif (not -e $User_Opt->{'target-dir'}) {
    Usage "Target directory $User_Opt->{'target-dir'} does not exist\n";
}
elsif (not -d $User_Opt->{'target-dir'}) {
    Usage "Target $User_Opt->{'target-dir'} is not a directory\n";
}
elsif (not -w $User_Opt->{'target-dir'}) {
    Usage "Can't write target directory $User_Opt->{'target-dir'}\n";
}

if ($User_Opt->{permissions} !~ /^[0-7][0-7][0-7]$/) {
    Usage "Permissions must be a 3-digit octal number\n";
}
#
# $Octal_Permissions is a string representing the permissions
# in octal, suitable for display.
#
# $Permissions is the numeric equivalent, suitable for use with the
# chmod call.
#
my $Octal_Permissions = $User_Opt->{permissions};
my $Permissions = oct "0$Octal_Permissions";

my $CRL_Expiration = undef;
foreach my $opt (qw(expire-crl warn-crl)) {
    if (defined $User_Opt->{$opt}) {
        if ($User_Opt->{$opt} =~ /^(\d+)([smhd])$/) {
            $CRL_Expiration = $1;
            if    ($2 eq 'm') { $CRL_Expiration *= 60 }
            elsif ($2 eq 'h') { $CRL_Expiration *= 3600 }
            elsif ($2 eq 'd') { $CRL_Expiration *= 86400 }
        }
        else {
            Usage "Invalid argument to \"-$opt\" option\n";
        }
    }
}

if ($User_Opt->{debugging}) {
    foreach my $opt (sort keys %$User_Opt) {
        print "$opt => ";
        if (defined $User_Opt->{$opt}) {
            if (ref $User_Opt->{$opt} eq 'ARRAY') {
                print "[\n";
                foreach my $item (@{$User_Opt->{$opt}}) {
                    print "    $item\n";
                }
                print "]\n";
            }
            else {
                print "\"$User_Opt->{$opt}\"\n";
            }
        }
        else {
            print "undef\n";
        }
    }
}

if (scalar @ca_list_all == 0) {
    die "No *.cadesc files in $ca_conf_dir\n";
}

my %selected = ();

my @requested_ca_list = ();
if (defined $User_Opt->{ca}) {
    foreach my $arg (@{$User_Opt->{ca}}) {
        push @requested_ca_list, split /[ ,]/, $arg;
    }
}
if (defined $User_Opt->{'ca-list'}) {
    foreach my $arg (@{$User_Opt->{'ca-list'}}) {
        push @requested_ca_list, Read_CA_List_File $arg;
    }
}

Debug "\@ca_list_all = ( @ca_list_all )\n";
Debug "\@requested_ca_list = ( @requested_ca_list )\n";

my @mismatches = ();

if ($User_Opt->{'all-cas'}) {
    %selected = map { $_ => 1 } @ca_list_all;
}
else {
    foreach my $requested_ca (@requested_ca_list) {
        my $match = 0;
        foreach my $ca (@ca_list_all) {
            if (Match_CA_Name $requested_ca, $ca) {
                $selected{$ca} = 1;
                $match = 1;
                last;
            }
        }
        if (not $match) {
            push @mismatches, $requested_ca;
        }
    }
}

my @ca_list = grep $selected{$_}, @ca_list_all;

if (scalar @ca_list == 0 or scalar @mismatches > 0) {
    my @message = ();
    if (scalar @ca_list == 0) {
        push @message, "No CAs selected"
    }
    if (scalar @mismatches == 1) {
        push @message, "No CA matching $mismatches[0]";
    }
    elsif (scalar @mismatches > 1) {
        push @message, "No CA matching any of " . join(', ', @mismatches);
    }
    die join(', ', @message), "\n";
}

my @ca_info = ();

foreach my $ca_desc_file (@ca_list) {
    my $ref = Get_CA_Ref "$ca_conf_dir/$ca_desc_file";
    push @ca_info, $ref if defined $ref;
}

Debug "Got ", scalar @ca_info, " ca record(s):\n";
if ($User_Opt->{debugging}) {
    Gridmap_Utils::Write_Records '-multiple', '-', @ca_info;
}

Gridmap_Utils::Use_Commands 'openssl';

if (-e $lock_file) {
    my $lock_time = Gridmap_Utils::Get_mtime $lock_file;
    die "Locked for ", $now - $lock_time, " seconds\n";
}
open my $Lock, '>', $lock_file;
print $Lock " $Program_Name (gx-map $Gridmap_Utils::VERSION) on $Hostname\n";
close $Lock;

CA:
foreach my $ref (@ca_info) {
    Vprint "Processing $ref->{HASH} $ref->{CA_NAME}\n";
    if (Disabled $ref) {
        if ($requested_all or $User_Opt->{'ignore-disable'}) {
            Vprint "CA is disabled\n";
        }
        else {
            #
            # The user explicitly requested a disabled CA without
            # specifying the "-ignore-disable" option.
            #
            Error $ref, undef, undef, "CA is disabled\n";
        }
        if ($User_Opt->{'ignore-disable'}) {
            Vprint "Overriding \"DISABLE\" attribute\n";
            $ref->{DISABLE} = 'no';
        }
    }
    if (not Disabled $ref) {
        my $prefix = "$User_Opt->{'target-dir'}/$ref->{HASH}";
        Gridmap_Utils::Untaint $prefix;
        $ref->{_CERT_FILE}           = "$prefix.0";
        $ref->{_SIGNING_POLICY_FILE} = "$prefix.signing_policy";
        $ref->{_CRL_FILE}            = "$prefix.r0";

        Update_Certificate    $ref;
        Update_CRL            $ref;
        Install_Certificate   $ref;
        Update_Signing_Policy $ref;

    }
    if (defined $ref->{_ERRORS}) {
        foreach my $error (@{$ref->{_ERRORS}}) {
            Vprint ">>> $error->{message}";
        }
    }

    Vprint "\n";
}

Check_Dependencies;

Notify;

unlink $lock_file;

########################################################################

sub Read_CA_List_File($) {
    my($filename) = @_;
    my @ca_list = ();
    open my $List, '<', $filename or die "${filename}: $!\n";
    while (<$List>) {
        s/#.*$//;
        s/^\s*//;
        s/\s*$//;
        next if /^$/;
        my @fields = split;
        push @ca_list, @fields;
    }
    close $List;
    return @ca_list;
} # Read_CA_List_File

# ----------------------------------------------------------------------

#
# Given an argument to the "-ca" option and the name of a *.cadesc
# file, return true iff the requested CA name matches a subfield of the
# file name.
#
sub Match_CA_Name($$) {
    my($requested_ca, $cadesc_filename) = @_;
    # Debug "Match_CA_Name \"$requested_ca\", \"$cadesc_filename\"";
    my @fields = split /\./, $cadesc_filename;
    pop @fields; # drop ".cadesc" suffix
    foreach my $field (@fields) {
        if (lc $requested_ca eq lc $field) {
            # Debug " => 1\n";
            return 1;
        }
    }
    # Debug " => 0\n";
    return 0;
} # Match_CA_Name

# ----------------------------------------------------------------------

#
# Given a string such as "1 hour" or "10 minutes", returns the number
# of seconds.  The numeric portion must be an integer, and exactly
# one unit may be specified, either seconds, minutes, hours, or days
# (trailing 's' optional).  If you want 1.5 hours, specify "90 minutes").
#
sub String_To_Seconds($) {
    my($timestamp) = lc $_[0];
    if ($timestamp =~ /^(\d+)\s+seconds?$/) {
        return $1;
    }
    elsif ($timestamp =~ /^(\d+)\s+minutes?$/) {
        return $1 * 60;
    }
    elsif ($timestamp =~ /^(\d+)\s+hours?$/) {
        return $1 * 3600;
    }
    elsif ($timestamp =~ /^(\d+)\s+days?$/) {
        return $1 * 86400;
    }
    else {
        return undef;
    }
} # String_To_Seconds

# ----------------------------------------------------------------------

#
# Given a non-negative number of seconds, returns a string such as
# "1m12s" or "32d 12h00m00s" for display.
#
# This function is not an exact inverse of String_To_Seconds();
# the formatting is different.
#
sub Seconds_To_String($) {
    use integer;
    my($total) = @_;
    die "Internal error: Seconds_To_String($total)" if $total < 0;
    my $seconds = $total % 60;
    $total = $total / 60;
    my $minutes = $total % 60;
    $total = $total / 60;
    my $hours = $total % 24;
    my $days = $total / 24;

    if ($days > 0) {
        return sprintf "%dd %02dh %02dm %02ds",
                       $days, $hours, $minutes, $seconds;
    }
    elsif ($hours > 0) {
        return sprintf "%dh %02dm %02ds",
                       $hours, $minutes, $seconds;
    }
    else {
        return sprintf "%dm %02ds",
                       $minutes, $seconds;
    }
} # Seconds_To_String

# ----------------------------------------------------------------------

#
# Given a reference to a CA description record, returns a multi-line
# string suitable for use as a signing_policy, compatible with both GT2
# and GT4 (and GT3).
#
sub Signing_Policy($) {
    my($ref) = @_;

    my $cond_subjects;
    if (ref $ref->{MAY_SIGN} eq 'ARRAY') {
        my @list = map { $_ = "\"$_\"" } @{$ref->{MAY_SIGN}};
        $cond_subjects = "'@list'";
    }
    else {
        $cond_subjects = "'$ref->{MAY_SIGN}'";
    }

    my $result = "# $ref->{CA_NAME} Signing Policy\n";
    $result .= "# generated by $Program_Name (gx-map $Gridmap_Utils::VERSION)\n";
    if ($ref->{SIGNING_POLICY_URL} ne '?') {
        $result .= "# See also <$ref->{SIGNING_POLICY_URL}>\n";
    }
    $result .= "\n";

    my $body   = "access_id_CA   X509    '$ref->{SUBJECT}'\n" .
                 "pos_rights     globus  CA:sign\n" .
                 "cond_subjects  globus  $cond_subjects\n";

    my $gt2_body = Gridmap_Utils::GT2_Subject $body;
    my $gt4_body = Gridmap_Utils::GT4_Subject $body;

    $result .= $gt2_body;
    if ($gt4_body ne $gt2_body) {
        $result .= "\n";
        $result .= $gt4_body;
    }
    return $result;
} # Signing_Policy;

# ----------------------------------------------------------------------

#
# Given the name of a cadesc file, returns a reference to a hash containing
# information about the CA.
#
sub Get_CA_Ref($) {
    my($filename) = @_;
    my $ref = Gridmap_Utils::Read_Records '-single', $filename;
    my @errors = ();

    $ref->{_FILENAME} = $filename;

    if (Disabled $ref) {
        return $ref;
    }

    my %valid = map { $_ => 1 } qw( CA_NAME HOMEPAGE CONTACT HASH
                                    SIGNED_BY SUBJECT MAY_SIGN
                                    CERTIFICATE_MD5 CERTIFICATE_SHA1
                                    CERTIFICATE_URL SIGNING_POLICY_URL
                                    CRL_URL ALLOW_MISSING_CRL
                                    INDEX CERT_EXPIRES DISABLE
                                    _FILENAME );
    my @required = qw( CA_NAME HASH SUBJECT MAY_SIGN
                       CERTIFICATE_MD5 CERTIFICATE_SHA1 CERTIFICATE_URL );
    my %remap = ( SIGNED_BY => 1,
                  SUBJECT   => 1,
                  MAY_SIGN  => 1 );
                       
    foreach my $key (@required) {
        if (not defined $ref->{$key}) {
            push @errors, "Missing key $key\n";
        }
    }

    foreach my $key (sort keys %$ref) {
        if (not $valid{$key}) {
            push @errors, "Unrecognized key $key\n";
        }
        if ($key =~ /_URL$/) {
            if ($ref->{$key} ne '?' and $ref->{$key} !~ m<^(https?|ftp):>) {
                push @errors, "Bad value for $key\n";
            }
        }
        #
        # Map subject names to GT4-compatible (and GT3-compatible) forms.
        #
        if ($remap{$key}) {
            if (ref $ref->{$key} eq 'ARRAY') {
                map { $_ = Gridmap_Utils::GT4_Subject $_ } @{$ref->{$key}};
            }
            else {
                $ref->{$key} = Gridmap_Utils::GT4_Subject $ref->{$key};
            }
        }
    }
    if (defined $ref->{HASH} and $ref->{HASH} !~ /^[\da-f]{8}$/) {
        push @errors, "Invalid HASH\n";
    }
    if (defined $ref->{DISABLE} and lc $ref->{DISABLE} ne 'no') {
        push @errors, "Value for DISABLE must be \"yes\" or \"no\"\n";
    }

    if (@errors) {
        my $s = (scalar @errors != 1);
        Vprint ">>> Error$s in ${filename}:\n";
        Vprint @errors;
        return undef;
    }
    else {
        return $ref;
    }
} # Get_CA_Ref

# ----------------------------------------------------------------------

#
# Returns true if the DISABLE field in the *.cadesc file exists and is
# set to "yes", false otherwise.
#
sub Disabled($) {
    my($ref) = @_;
    return (defined $ref->{DISABLE} and lc $ref->{DISABLE} eq 'yes');
} # Disabled

# ----------------------------------------------------------------------

#
# Returns true if the ALLOW_MISSING_CRL field in the *.cadesc file exists
# and is set to "yes", false otherwise.
#
sub Allow_Missing_CRL($) {
    my($ref) = @_;
    return (defined $ref->{ALLOW_MISSING_CRL} and
           lc $ref->{ALLOW_MISSING_CRL} eq 'yes');
} # Allow_Missing_CRL

# ----------------------------------------------------------------------

#
# Give a reference to a CRL description record, returns a reference to
# information about the CRL:
#     hash
#     issuer
#     last_update (raw timestamp)
#     next_update (raw timestamp)
#     lifetime    (in seconds)
#     used        (proportion of lifetime already used, e.g.
#                 0.0 if it was just issued,
#                 1.0 if it's just now expiring)
#     verified
#
# Returns undef if the hash, issuer, last_update, and next_update values
# cannot be determined.
#
sub CRL_Info($$) {
    my($CRL_file, $cert_file) = @_;
    my $result = {};

    Debug "%%% CRL_Info(",
          (defined $CRL_file ? $CRL_file : 'undef'),
          ", ",
          (defined $cert_file ? $cert_file : 'undef'),
          ")\n";
    if ($User_Opt->{debugging}) {
        my @files = ();
        push @files, $CRL_file if defined $CRL_file;
        push @files, $cert_file if defined $cert_file;
        print "%%% % ls -lsF @files\n";
        system 'ls', '-lsF', @files;
    }

    return undef if not defined $CRL_file or not -r $CRL_file;

    #
    # Get attributes of CRL
    #
    open my $Pipe, '-|',
         "openssl crl -in $CRL_file -noout " .
         "-hash -issuer -lastupdate -nextupdate 2>&1"
        or return undef;
    while (<$Pipe>) {
        chomp;
        if (/^[\da-f]{8}$/) {
            $result->{hash} = $_;
        }
        elsif (/^issuer=\s*(.*)$/) {
            $result->{issuer} = Gridmap_Utils::GT4_Subject $1;
        }
        elsif (/^lastUpdate=\s*(.*)$/) {
            $result->{last_update} = Gridmap_Utils::Time_Value $1;
        }
        elsif (/^nextUpdate=\s*(.*)$/) {
            $result->{next_update} = Gridmap_Utils::Time_Value $1;
        }
    }
    close $Pipe;
    
    #
    # If we didn't get everything we need, don't return any information.
    #
    foreach my $key (qw(hash issuer last_update next_update)) {
        return undef if not defined $result->{$key};
    }

    $result->{lifetime} = $result->{next_update} - $result->{last_update};
    $result->{used} = ($now - $result->{last_update}) / $result->{lifetime};

    #
    # Verify CRL against certificate.
    # (If it's ok, openssl prints "verify OK" to stderr.)
    #
    if (defined $cert_file and -r $cert_file) {
        open my $Pipe, '-|',
             "openssl crl -in '$CRL_file' -noout -CAfile $cert_file 2>&1";
        while (<$Pipe>) {
            if (/verify ok/i) {
                $result->{verified} = 1;
            }
        }
        close $Pipe;
    }

    return $result;
} # CRL_Info

# ----------------------------------------------------------------------

#
# Given the name of a certificate file, returns a reference to information
# about the certificate:
#     hash
#     issuer
#     subject
#     md5sum
#     sha1sum
#     startdate (raw timestamp)
#     enddate   (raw timestamp)
#
# Returns undef if any of these fields cannot be determined.
#
sub Certificate_Info($) {
    my($cert_file) = @_;
    return undef if not -r $cert_file;
    my $result = {};
    open my $Pipe1, '-|',
         "openssl x509 -in '$cert_file' -noout -hash -issuer -subject " .
         "-md5 -fingerprint -startdate -enddate";
    while (<$Pipe1>) {
        chomp;
        if (/^[\da-f]{8}$/) {
            $result->{hash} = $_;
        }
        elsif (/^issuer=\s*(.*)$/) {
            $result->{issuer} = Gridmap_Utils::GT4_Subject $1;
        }
        elsif (/^subject=\s*(.*)$/) {
            $result->{subject} = Gridmap_Utils::GT4_Subject $1;
        }
        elsif (/^md5.*=\s*(.*)$/i) {
            $result->{md5sum} = $1;
        }
        elsif (/^notBefore=\s*(.*)$/) {
            $result->{startdate} = Gridmap_Utils::Time_Value $1;
        }
        elsif (/^notAfter=\s*(.*)$/) {
            $result->{enddate} = Gridmap_Utils::Time_Value $1;
        }
    }
    close $Pipe1;

    #
    # openssl won't display both md5 and sha1 fingerprints in a single
    # command (unless it reads commands from stdin).
    #
    open my $Pipe2, '-|',
         "openssl x509 -in '$cert_file' -noout -sha1 -fingerprint";
    while (<$Pipe2>) {
        if (/^sha1.*=\s*(.*)$/i) {
            $result->{sha1sum} = $1;
        }
    }
    close $Pipe2;

    foreach my $key (qw(hash issuer subject
                        md5sum sha1sum
                        startdate enddate))
    {
        return undef if not defined $result->{$key};
    }

    return $result;
} # Certificate_Info

# ----------------------------------------------------------------------

#
# Update CA certificate if necessary.
# Don't install it yet; wait until after we've checked the CRL.
# (We need the certificate to validate the CRL, but we don't to
# see whether we have a CRL before installing the certificate.)
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# Refuse to install an expired certificate, but leave it alone if
# it's already installed.
#
sub Update_Certificate($) {
    my($ref) = @_;

    Debug "Update_Certificate, CA_NAME = ",
          (defined $ref->{CA_NAME} ? $ref->{CA_NAME} : '???'),
          "\n";
    if (not $User_Opt->{force} and -e $ref->{_CERT_FILE}) {
        Vprint "Skipping existing $ref->{_CERT_FILE}\n";
    }
    elsif ($ref->{CERTIFICATE_URL} =~ m<(https?|ftp)://>) {
        my($cache_file, $error)
            = Gridmap_Utils::Cache_File $ref->{CERTIFICATE_URL};
        if (defined $error) {
            #
            # TODO: Think of a better way to generate a timestamp for
            # this error message.
            #
            my $timestamp;
            if (not defined $cache_file) {
                $timestamp = 0;
            }
            else {
                $timestamp = Gridmap_Utils::Get_mtime $cache_file;
                $timestamp = 0 if not defined $timestamp;
            }
            Error $ref,
                  'cert_download_failed',
                  $timestamp,
                  "$error for $ref->{CERTIFICATE_URL}\n";
        }
        elsif (defined $cache_file and -r $cache_file) {
            $ref->{_CACHED_CERT_FILE} = $cache_file;
            # Debug "_CACHED_CERT_FILE = \"$cache_file\"\n";
            my $cert_info = Certificate_Info $cache_file;
            if (defined $cert_info->{enddate}) {
                if ($cert_info->{enddate} < $now) {
                    Error $ref, 'cert_expired',
                                $cert_info->{enddate},
                                "Certificate expired " .
                                 Seconds_To_String
                                     ($now - $cert_info->{enddate}) .
                                 " ago\n";
                }
            }
            else {
                Error $ref, undef, undef,
                      "Unable to determine certificate expiration date\n";
            }
            if ($cert_info->{hash} ne $ref->{HASH}) {
                Error $ref, undef, undef,
                            "Mismatched hash, expected $ref->{HASH}, " .
                            "got $cert_info->{hash}\n";
            }
            if ($cert_info->{subject} ne $ref->{SUBJECT}) {
                Error $ref, undef, undef,
                            "Mismatched subject, expected " .
                            "\"$ref->{SUBJECT}\", got " .
                            "\"$cert_info->{subject}\"\n";
            }
            if (defined $ref->{SIGNED_BY} and
                $ref->{SIGNED_BY} ne '?')
            {
                if ($cert_info->{issuer} ne $ref->{SIGNED_BY}) {
                    Error $ref, undef, undef,
                                "Mismatched issuer, expected " .
                                "\"$ref->{SIGNED_BY}\", got " .
                                "\"$cert_info->{issuer}\"\n";
                }
            }
            else {
                if ($cert_info->{issuer} ne $cert_info->{subject}) {
                    Error $ref, undef, undef,
                                "Certificate is not self-signed, " .
                                "but no SIGNED_BY attribute was " .
                                "specified in $ref->{_FILENAME}\n";
                }
            }
            if ($cert_info->{md5sum} ne $ref->{CERTIFICATE_MD5}) {
                Error $ref, undef, undef,
                            "Mismatched md5 fingerprint, expected " .
                            "\"$ref->{CERTIFICATE_MD5}\", got " .
                            "\"$cert_info->{md5sum}\"\n";
            }
            if ($cert_info->{sha1sum} ne $ref->{CERTIFICATE_SHA1}) {
                Error $ref, undef, undef,
                            "Mismatched sha1 fingerprint, expected " .
                            "\"$ref->{CERTIFICATE_SHA1}\", got " .
                            "\"$cert_info->{sha1sum}\"\n";
            }
        }
    }
    else {
        Vprint "No URL given for certificate\n";
    }
} # Update_Certificate

# ----------------------------------------------------------------------

#
# Update CRL if necessary
#
sub Update_CRL($) {
    my($ref) = @_;
    my $cert_file;

    return if defined $ref->{_ERRORS};

    Debug "Update_CRL, CA_NAME = ",
          (defined $ref->{CA_NAME} ? $ref->{CA_NAME} : '???'),
          "\n";

    #
    # _CACHED_CERT_FILE, if set, is the newly downloaded or cached
    # certificate.  Otherwise, _CERT_FILE is the installed certificate.
    #
    if (defined $ref->{_CACHED_CERT_FILE} and -e $ref->{_CACHED_CERT_FILE}) {
        $cert_file = $ref->{_CACHED_CERT_FILE};
    }
    elsif (-e $ref->{_CERT_FILE}) {
        $cert_file = $ref->{_CERT_FILE};
    }
    else {
        #
        # We don't have a certificate, so we can't check the CRL (and
        # there's no point in installing it).  We should have already
        # flagged an error in Update_Certificate, so we should never
        # get here, but check it anyway.
        #
        Error $ref, undef, undef, "No certificate, can't check CRL\n";
        return;
    }

    # Debug "Checking $ref->{_CRL_FILE} against $cert_file\n";

    Debug "%%% Calling CRL_Info for existing CRL\n";
    my $old_crl_info = CRL_Info $ref->{_CRL_FILE}, $cert_file;
    Debug "%%% After CRL_Info\n";

    # if ($User_Opt->{debugging}) {
    #     if (defined $old_crl_info) {
    #         Debug "old_crl_info:\n";
    #         my @arr = ( $old_crl_info );
    #         Gridmap_Utils::Write_Records '-multiple', '-', @arr;
    #     }
    #     else {
    #         Debug "old_crl_info = undef\n";
    #     }
    # }

    my $install_new_crl = 0;

    my $have_crl_url = $ref->{CRL_URL} =~ m<(https?|ftp)://>;
    my $new_crl_file = undef;
    if ($have_crl_url) {
        #
        # Attempt to download a new CRL (or use a cached copy)
        #
        my $error;
        ($new_crl_file, $error) = Gridmap_Utils::Cache_File $ref->{CRL_URL};
        if (defined $new_crl_file) {
            Debug "%%%  \$new_crl_file = \"$new_crl_file\"\n";
        }
        else {
            Debug "%%%  \$new_crl_file = undef\n";
        }
        Debug "%%%  \$error = ", (defined $error ? $error : 'undef'), "\n";
        if (defined $error) {
            my $timestamp = 0;
            if (defined $new_crl_file) {
                $timestamp = Gridmap_Utils::Get_mtime $new_crl_file;
            }
            $timestamp = 0 if not defined $timestamp;
            Error $ref,
                  'crl_download_failed',
                  $timestamp,
                  "$error for $ref->{CRL_URL}\n";
        }
    }
    else {
        #
        # If no CRL is specified, it's considered an error unless either
        # the "-allow-missing-crl" (with "-UNSAFE") option is specified
        # on the command line *or* the ALLOW_MISSING_CRL attribute is
        # set to "yes" in the cadesc file.
        #
        if (not $User_Opt->{'allow-missing-crl'} and
            not Allow_Missing_CRL $ref)
        {
            Error $ref, undef, undef, "No CRL specified\n";
        }
    }
    #
    # Verify signature against certificate.
    #

    # Debug "Checking " .
    #       (defined $new_crl_file ? $new_crl_file : 'undef') .
    #       " against " .
    #       (defined $cert_file ? $cert_file : 'undef') .
    #       "\n";

    Debug "%%% Calling CRL_Info for new CRL file, \$new_crl_file=",
          (defined $new_crl_file ? $new_crl_file : 'undef'),
          "\n";
    my $new_crl_info = CRL_Info $new_crl_file, $cert_file;
    Debug "%%% After CRL_Info\n";
    if (defined $new_crl_info) {
        Debug "%%% \$new_crl_info = $new_crl_info\n";
        foreach my $key (sort keys %$new_crl_info) {
            Debug "        $key => $new_crl_info->{$key}\n";
        }
    }
    else {
        Debug "%%% \$new_crl_info = undef\n";
    }

    # if ($User_Opt->{debugging}) {
    #     if (defined $new_crl_info) {
    #         Debug "new_crl_info:\n";
    #         my @arr = ( $new_crl_info );
    #         Gridmap_Utils::Write_Records '-multiple', '-', @arr;
    #     }
    #     else {
    #         Debug "new_crl_info = undef\n";
    #     }
    # }

    if (defined $new_crl_info) {
        #
        # We have a new CRL; decide whether to install it.
        #
        my $remaining = $new_crl_info->{next_update} - $now;
        # Debug "remaining = $remaining\n";
        if ($remaining <= 0) {
            if ($User_Opt->{'allow-missing-crl'} or
                 Allow_Missing_CRL $ref)
            {
                Vprint "CRL has expired\n";
            }
            else {
                Error $ref, 'crl_has_expired',
                            $new_crl_info->{next_update},
                            "CRL has expired\n";
            }
        }
        elsif (defined $CRL_Expiration and $remaining < $CRL_Expiration) {
            Error $ref, 'crl_will_expire',
                        $new_crl_info->{next_update},
                        "CRL expires in " .
                        Seconds_To_String($remaining) .
                        ", not installing\n";
        }
        elsif (not $new_crl_info->{verified}) {
            Error $ref, undef, undef, "Can't verify new CRL\n";
        }
        elsif (defined $old_crl_info) {
            #
            # We have an old CRL and a new CRL; decide whether to
            # replace the old one with the new one.
            #
            if ($new_crl_info->{last_update} == $old_crl_info->{last_update} and
                $new_crl_info->{next_update} == $old_crl_info->{next_update})
            {
                Vprint "CRL update not needed\n";
            }
            elsif ($new_crl_info->{last_update} <
                   $old_crl_info->{last_update})
            {
                Error $ref, undef, undef,
                            "Newly downloaded CRL seems to be older " .
                            "than old CRL, not installing\n";
            }
            else {
                $install_new_crl = 1;
            }
        }
        else {
            $install_new_crl = 1;
        }
    }
    else {
        #
        # We don't have a new CRL
        #
        if (not $have_crl_url) {
            Vprint "No URL given for CRL\n";
        }
        else {
            Error $ref, undef, undef, "Unable to get information for CRL\n";
        }
    }

    # Debug "install_new_crl = $install_new_crl\n";

    if ($install_new_crl) {
        Vprint    "Installing $ref->{_CRL_FILE}\n";
        Log $ref, "Installing $ref->{_CRL_FILE}\n";
        my $temp_file = "$ref->{_CRL_FILE}.$$";
        File::Copy::copy $new_crl_file, $temp_file
            or Error $ref, undef, undef, "Failed to copy CRL: $!\n";
        chmod $Permissions, $temp_file
            or Error $ref, undef, undef,
                     "chmod $Octal_Permissions, $temp_file: $!\n";
        rename $temp_file, $ref->{_CRL_FILE}
            or Error $ref, undef, undef, "Failed to rename CRL: $!\n";
    }

    if (defined $ref->{_CRL_FILE}) {
        Debug "%%% \$ref->{_CRL_FILE} = \"$ref->{_CRL_FILE}\"\n";
        if (-r $ref->{_CRL_FILE}) {
            Debug "%%% File is readable\n";
        }
        elsif (-e $ref->{_CRL_FILE}) {
            Debug "%%% File exists but is not readable\n";
        }
        else {
            Debug "%%% File does not exist\n";
        }
    }
    else {
        Debug "%%% \$ref->{_CRL_FILE} = undef\n";
    }

    #
    # Just to be sure, re-fetch CRL info from the target CRL file
    # (which may or may not have just been updated).
    #
    if (-r $ref->{_CRL_FILE}) {
        Debug "%%% Re-fetching CRL info for $ref->{_CRL_FILE}\n";
        my $crl_info = CRL_Info $ref->{_CRL_FILE}, $cert_file;
        Debug "%%% After CRL_Info\n";
        my $remaining = $crl_info->{next_update} - $now;
        my $remove_crl = 0;
        if (defined $crl_info) {
            if (not $crl_info->{verified}) {
                Error $ref, undef, undef, "Removing unverified CRL\n";
                $remove_crl = 1;
            }
            elsif (defined $CRL_Expiration and
                   $remaining < $CRL_Expiration)
            {
                Error $ref, 'crl_will_expire',
                            $crl_info->{next_update},
                            "CRL will expire in " .
                            Seconds_To_String($remaining) .
                            ", removing it\n";
                $remove_crl = 1;
            }
            if ($remove_crl) {
                unlink $ref->{_CRL_FILE};
            }
            else {
                my $expiration_string
                    = Gridmap_Utils::Time_Image $crl_info->{next_update};
                my $how_long = Seconds_To_String abs $remaining;
                my $notify = 0;
                if ($crl_info->{used} > 0.9) {
                    $notify = 1;
                }
                elsif (defined $User_Opt->{'warn-crl'}) {
                    if ($remaining < $User_Opt->{'warn-crl'}) {
                        $notify = 1;
                    }
                }
                if ($remaining < 0) {
                    Error $ref, 'crl_has_expired',
                                $crl_info->{next_update},
                                "CRL expired at $expiration_string " .
                                "($how_long ago)\n";
                }
                elsif ($remaining == 0) {
                    Error $ref, 'crl_will_expire',
                                $crl_info->{next_update},
                                "CRL expires at $expiration_string\n";
                }
                else {
                    if ($notify) {
                        Error $ref, 'crl_will_expire',
                                    $crl_info->{next_update},
                                    "CRL will expire at $expiration_string " .
                                    "($how_long from now)\n";
                    }
                    else {
                        Vprint "CRL will expire at $expiration_string " .
                               "($how_long from now)\n";
                    }
                }
                if (not $crl_info->{verified}) {
                    Error $ref, undef, undef, "CRL is not verified\n";
                }
            }
        }
    }
    else {
        Vprint"No CRL\n";
    }
} # Update_CRL

# ----------------------------------------------------------------------

sub Install_Certificate($) {
    my($ref) = @_;

    #
    # Don't install the certificate file if there are any errors.
    # This includes a missing CRL if the "-allow-missing-crl" option
    # was not specified and the ALLOW_MISSING_CRL attribute is not set.
    #
    return if defined $ref->{_ERRORS};

    if (not $User_Opt->{force} and -e $ref->{_CERT_FILE}) {
        Vprint "Certificate $ref->{HASH}.0 is already installed\n";
        return;
    }
    Vprint    "Installing $ref->{_CERT_FILE}\n";
    Log $ref, "Installing $ref->{_CERT_FILE}\n";
    my $temp_file = "$ref->{_CERT_FILE}.$$";
    File::Copy::copy $ref->{_CACHED_CERT_FILE}, $temp_file
        or Error $ref, undef, undef, "Failed to copy certificate: $!\n";
    chmod $Permissions, $temp_file
        or Error $ref, undef, undef,
                 "chmod $Octal_Permissions, $temp_file: $!\n";
    rename $temp_file, $ref->{_CERT_FILE}
        or Error $ref, undef, undef, "Failed to rename certificate: $!\n";
} # Install_Certificate

# ----------------------------------------------------------------------

#
# Update signing_policy file if necessary.
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# For now, we ignore the SIGNING_POLICY_URL; the signing_policy is
# generated from the MAY_SIGN attributes.
# Don't bother to install if there have been any errors.
#
sub Update_Signing_Policy($) {
    my($ref) = @_;

    return if defined $ref->{_ERRORS};

    if (not $User_Opt->{force} and -e $ref->{_SIGNING_POLICY_FILE}) {
        Vprint "Skipping existing $ref->{_SIGNING_POLICY_FILE}\n";
    }
    else {
        Vprint    "Creating $ref->{_SIGNING_POLICY_FILE}\n";
        Log $ref, "Creating $ref->{_SIGNING_POLICY_FILE}\n";
        my $temp_file = "$ref->{_SIGNING_POLICY_FILE}.$$";
        open my $Policy, '>', $temp_file or die "$temp_file: $!\n";
        print $Policy Signing_Policy $ref;
        close $Policy;
        chmod $Permissions, $temp_file
            or Error $ref, undef, undef,
                     "chmod $Octal_Permissions, " .
                     "$ref->{_SIGNING_POLICY_FILE}: $!\n";
        rename $temp_file, $ref->{_SIGNING_POLICY_FILE}
            or Error $ref, undef, undef, "Failed to rename signing_policy: $!\n";
        $ref->{_INSTALLED_SIGNING_POLICY} = 1;
    }
} # Update_Signing_Policy

# ----------------------------------------------------------------------

sub Check_Dependencies() {
    Vprint "Dependency checking not yet implemented\n";
} # Check_Dependencies

# ----------------------------------------------------------------------

#
# Log a message.
# Annotate the CA reference (first argument) with the message.
#
sub Log($$) {
    my($ref, $message) = @_;
    push @{$ref->{_MESSAGES}}, $message;
} # Log

# ----------------------------------------------------------------------

sub Error_File($) {
    my($error_ref) = @_;
    if (defined $error_ref->{desc}) {
        my $name = join('.', $error_ref->{timestamp},
                             $error_ref->{ca_hash},
                             $error_ref->{desc});
        return "$Data_Dir/reported-errors/$name";
    }
    else {
        return undef;
    }
} # Error_File

# ----------------------------------------------------------------------

#
# Report an error.
# The arguments are:
#      $ref
#          A reference to the CA record.
#      $desc
#          A brief description, used to distinguish different kinds of errors,
#          suitable for inclusion in a filename.
#          If this is defined, an error file may be created.
#          May be undef.
#      $timestamp
#          A timestamp, typically the expiration time of the CRL
#          May be undef.
#      $message
#          A human-readable error message, terminated with a newline.
# Annotate the CA reference (first argument) with an error record.
#
sub Error($$$$) {
    my($ref, $desc, $timestamp, $message) = @_;
    my $error_ref = {};
    $error_ref->{message}   = $message;
    $error_ref->{ca_hash}   = $ref->{HASH};
    $error_ref->{desc}      = $desc      if defined $desc;
    $error_ref->{timestamp} = $timestamp if defined $timestamp;

    my $error_file = Error_File $error_ref;
    if (defined $error_file) {
        $error_ref->{filename} = $error_file;
        if (-e $error_file) {
            $error_ref->{reported} = 1;
        }
        else {
            open my $Error_File, '>', $error_file;
            print $Error_File $message;
            close $Error_File;
        }
    }

    push @{$ref->{_ERRORS}}, $error_ref;
} # Error

# ----------------------------------------------------------------------

#
# Send an error notification by e-mail.
# Log messages to log file.
# Error files in the var/reported-errors directory are used to track
# which errors have already been reported by e-mail; all errors are
# logged regardless.  Some classes of errors are not currently recorded
# in error files; these are treated as new errors and can potentially
# be reported by e-mail repeatedly.
#
sub Notify() {
    my $total_ca_count = scalar @ca_info;
    my $error_ca_count = 0;       # CAs with errors
    my $new_error_ca_count = 0;   # CAs with new errors
    my $error_count = 0;          # Number of errors
    my $new_error_count = 0;      # Number of new errors
    my $log_message_body = '';
    my $mail_message_body = '';

    $log_message_body
        .= Gridmap_Utils::Time_Image($now) .
           " $Program_Name (gx-map $Gridmap_Utils::VERSION) on $Hostname\n";

    #
    # _NEW_ERRORS is a subset of _ERRORS, specifically the errors
    # that need to be reported by e-mail.
    #
    foreach my $ref (@ca_info) {
        if (defined $ref->{_ERRORS}) {
            $error_ca_count ++;
            $error_count += scalar @{$ref->{_ERRORS}};
            foreach my $error (@{$ref->{_ERRORS}}) {
                if (not $error->{reported}) {
                    push @{$ref->{_NEW_ERRORS}}, $error;
                    $new_error_count ++;
                    if (defined $error->{filename}) {
                        open my $File, '>', $error->{filename};
                        print $File $error->{message}, "\n";
                        close $File;
                    }
                }
            }
            if (defined $ref->{_NEW_ERRORS}) {
                $new_error_ca_count ++;
            }
        }
    }

    foreach my $ref (@ca_info) {
        if (defined $ref->{_MESSAGES} or defined $ref->{_ERRORS}) {
            $log_message_body .= "$ref->{HASH} $ref->{CA_NAME}:\n";

            if (defined $ref->{_MESSAGES}) {
                foreach my $message (@{$ref->{_MESSAGES}}) {
                    $log_message_body .= "    $message";
                }
            }

            if (defined $ref->{_ERRORS}) {
                my @error_list = @{$ref->{_ERRORS}};
                foreach my $error (@error_list) {
                    $log_message_body .= "    >>> ERROR: $error->{message}";
                }
            }

            if (defined $ref->{_NEW_ERRORS}) {
                my @error_list = @{$ref->{_NEW_ERRORS}};
                $mail_message_body .= "$ref->{HASH} $ref->{CA_NAME}:\n";
                foreach my $error (@error_list) {
                    $mail_message_body .= $error->{message};
                }
                $mail_message_body .= "\n";
            }
        }
    }

    $log_message_body .= "\n";

    my $log_file = "$Install_Dir/var/$Program_Name.log";
    Gridmap_Utils::Untaint $log_file;
    open my $Log, '>>', $log_file;
    print $Log $log_message_body;
    close $Log;

    if ($User_Opt->{email} and $new_error_count > 0) {
        my $subject = "$Program_Name: $new_error_count error(s), " .
                      "$new_error_ca_count/$total_ca_count CA(s)";

        my $recipient = $Gridmap_Utils::Config{ADMIN_EMAIL};
        $mail_message_body
            .= "\n$Program_Name (gx-map $Gridmap_Utils::VERSION) on " .
               "$Hostname\n";
        Gridmap_Utils::Send_Email $Gridmap_Utils::Config{ADMIN_EMAIL},
                                  $subject,
                                  $mail_message_body;
    }
} # Notify

# ----------------------------------------------------------------------

#
# Print a message if "-verbose" option was given
#
sub Vprint(@) {
    print @_ if $User_Opt->{verbose};
} # Vprint

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Usage(@) {
    if (@_) {
        print @_;
        print "Run \"$Program_Name -help\" for more information\n";
    }
    else {
        print <<"EOF";
Usage: $Program_Name [options]
    -help              Display this message and exit.
    -version           Display version information and exit.
    -UNSAFE            By default, options that can create security
                       problems are disabled.  You can use the
                       "-UNSAFE" option (case-sensitive) to enable
                       them.  The "unsafe" options are:
                            -all-cas
                            -allow-missing-crl
                            -expire-crl time
                            -ignore-disable
    -ca name           Name of a CA.  This option may be given multiple
                       times, or CA names may be delimited by commas or
                       blanks.  The argument is a field of the *.cadesc
                       file name; use the hash value to avoid ambiguity.
    -ca-list file      Name of a text file containing a list of CAs.
                       Comments are introduced by '#'.
                       Leading and trailing whitespace and blank lines
                       are ignored.
                       CAs are specified the same way as arguments to the
                       "-ca" option.
                       Multiple "-ca-list" options may be given.
                       The "-ca" and "-ca-list" options may be combined.
    -all-cas           Use all available CAs.
                       Requires "-UNSAFE".
    -list-cas          List available CAs and exit.
    -target-dir dir    Target directory.
    -permissions perm  Specify permissions for installed files (in octal);
                       default is 444
    -allow-missing-crl Allow a CA with no CRL to be installed.
                       Requires "-UNSAFE".
    -expire-crl time   Remove a CRL that will expire within
                       "time".  "time" is expressed as a number
                       followed by 's' (seconds), 'm' (minutes),
                       'h' (hours) or 'd' (days); for example
                       "-expire-crl 75m".  By default, expiring CRLs
                       are left in place.
                       Requires "-UNSAFE".
    -warn-crl time     Issue a warning message if the CRL will expire
                       within the specified time.  Regardless of this
                       option, a warning will also be issued if the CRL
                       has used more than 90% of its lifetime.
    -force             Force file updates (applies to certificate and
                       signing_policy files).
    -ignore-disable    Ignore "DISABLE" attribute in cadesc files.
                       Requires "-UNSAFE".
    -email             Send e-mail to configured ADMIN_EMAIL address on errors.
                       Default is "-email"; use "-noemail" to disable.
    -verbose           Print verbose messages.
    -debugging         Enable debugging output.
EOF
    }
    exit 1;
} # Usage
