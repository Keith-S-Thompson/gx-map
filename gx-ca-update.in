#!%PERL% -T

# $Id: gx-ca-update.in,v 1.149 2007-05-09 03:18:13-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-ca-update.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2007 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Advanced Cyberinfrastructure
# Laboratory at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;
use warnings;

use File::Basename ();
use File::Copy ();
use Getopt::Long ();

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

my $Install_Dir;
BEGIN { $Install_Dir = '%INSTALL_DIR%'; }
use lib "$Install_Dir/lib";
use GX ();

sub Read_CA_List_File($);
sub String_To_Seconds($);
sub Seconds_To_String($);
sub Signing_Policy($);
sub CA_Config_Dir_List();
sub Get_CA_Info(@);
sub Disabled($);
sub Allow_Missing_CRL($);
sub CRL_Info($$$);
sub Update_And_Install_Certificate($);
sub Update_And_Install_CRL($);
sub Finalize_Certificate($);
sub Update_And_Install_Signing_Policy($);
sub Check_Dependencies();
sub Log($$);
sub Error($$$$;$);
sub Vprint(@);
sub Notify();
sub Debug(@);
sub Usage(@);

my $Program_Name = File::Basename::basename $0;
my $now = time;
my $Hostname = GX::Get_Hostname();

#
# We want to call Check_Dependencies only if a certificate
# has been installed; otherwise the check is redundant.
#
my $Certificate_Installed = 0;

my $User_Opt = { permissions => '444',
                 download => 1,
                 email => 1 };
my @Opts = ( $User_Opt,
             qw( help!
                 version!
                 ca=s@
                 ca-list=s@
                 list-cas!
                 list-all-cas!
                 target-dir=s
                 download!
                 permissions=s
                 gt3-compatible!
                 force!
                 email!
                 ignore-bad-cadesc!
                 verbose!
                 debugging! ) );
$Getopt::Long::ignorecase = 0; # options are case-sensitive
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};
Usage if @ARGV;

if ($User_Opt->{version}) {
    print "$Program_Name (gx-map) $GX::VERSION\n";
    exit 0;
}

GX::Set_Config;

GX::Check_Data_Dir;

#
# This program may only be executed by the GX_MAP_OWNER.
#
GX::Require_Owner $Program_Name;

$GX::Debugging = 1 if $User_Opt->{debugging};

$| = 1 if $User_Opt->{verbose};

if ($User_Opt->{'list-cas'} and $User_Opt->{'list-all-cas'}) {
    Usage "The \"-list-cas\" and \"-list-all-cas\" options " .
          "may not be used together\n";
}

my $Data_Dir = "$Install_Dir/gx-map-data";

my $ca_conf_dir = "$Install_Dir/etc/gx-map/ca-config";

GX::Install_Die_Handler;
GX::Install_Warn_Handler;

my $CA_Info = Get_CA_Info CA_Config_Dir_List;
if (not defined $CA_Info) {
    die "Error reading CA information\n"
}

if ($User_Opt->{'list-cas'} or $User_Opt->{'list-all-cas'}) {
    foreach my $hash (sort keys %$CA_Info) {
        next if $User_Opt->{'list-cas'} and Disabled $CA_Info->{$hash};
        my $short_ca_name = $CA_Info->{$hash}->{_SHORT_CA_NAME};
        my $ca_name = $CA_Info->{$hash}->{CA_NAME};
        print "$hash # $ca_name ($short_ca_name)\n";
    }
    exit 0;
}

my $CA_Info_By_Name = {};
foreach my $hash (sort keys %$CA_Info) {
    my $name = $CA_Info->{$hash}->{_SHORT_CA_NAME};
    $CA_Info_By_Name->{$name} = $CA_Info->{$hash};
}

# if (not defined $User_Opt->{ca} and
#     not defined $User_Opt->{'ca-list'})
# {
#     Usage "No CA specified\n";
# }

if (not defined $User_Opt->{'target-dir'}) {
    Usage "No target directory specified\n";
}
elsif (not -e $User_Opt->{'target-dir'}) {
    Usage "Target directory $User_Opt->{'target-dir'} does not exist\n";
}
elsif (not -d $User_Opt->{'target-dir'}) {
    Usage "Target $User_Opt->{'target-dir'} is not a directory\n";
}
elsif (not -w $User_Opt->{'target-dir'}) {
    Usage "Can't write target directory $User_Opt->{'target-dir'}\n";
}

if ($User_Opt->{permissions} !~ /^[0-7][0-7][0-7]$/) {
    Usage "Permissions must be a 3-digit octal number\n";
}
GX::Untaint $User_Opt->{permissions};
#
# $Octal_Permissions is a string representing the permissions
# in octal, suitable for display.
#
# $Permissions is the numeric equivalent, suitable for use with the
# chmod call.
#
my $Octal_Permissions = $User_Opt->{permissions};
my $Permissions = oct "0$Octal_Permissions";

if ($User_Opt->{debugging}) {
    foreach my $opt (sort keys %$User_Opt) {
        print "$opt => ";
        if (defined $User_Opt->{$opt}) {
            if (ref $User_Opt->{$opt} eq 'ARRAY') {
                print "[\n";
                foreach my $item (@{$User_Opt->{$opt}}) {
                    print "    $item\n";
                }
                print "]\n";
            }
            else {
                print "\"$User_Opt->{$opt}\"\n";
            }
        }
        else {
            print "undef\n";
        }
    }
}

my %selected = ();

my @requested_ca_list = ();
if (defined $User_Opt->{ca}) {
    foreach my $arg (@{$User_Opt->{ca}}) {
        push @requested_ca_list, split /[ ,]/, $arg;
    }
}
if (defined $User_Opt->{'ca-list'}) {
    foreach my $arg (@{$User_Opt->{'ca-list'}}) {
        push @requested_ca_list, Read_CA_List_File $arg;
    }
}
if (not defined $User_Opt->{ca} and
    not defined $User_Opt->{'ca-list'})
{
    my $list_file = "$User_Opt->{'target-dir'}/.ca-list";
    if (-e $list_file) {
        push @requested_ca_list, Read_CA_List_File $list_file;
    }
    else {
        Usage "No CA specified\n" .
              qq(Use "-ca" or "-ca-list", or create a ".ca-list" file in\n) .
              " the target directory\n";
    }
}

my @ca_list = ();
my @mismatches = ();

#
# Elements of @requested_ca_list may be either hash values
# or short CA names.  Elements of @ca_list will be CA references.
#

Debug "\@requested_ca_list = ( @requested_ca_list )\n";

foreach my $requested_ca (@requested_ca_list) {
    my $match = 0;
    if ($requested_ca =~ /^[0-9a-f]{8}$/) {
        if (defined $CA_Info->{$requested_ca}) {
            push @ca_list, $CA_Info->{$requested_ca};
        }
        else {
            push @mismatches, $requested_ca;
        }
    }
    else {
        if (defined $CA_Info_By_Name->{$requested_ca}) {
            push @ca_list, $CA_Info_By_Name->{$requested_ca};
        }
        else {
            push @mismatches, $requested_ca;
        }
    }
}

if (scalar @ca_list == 0 or scalar @mismatches > 0) {
    my @message = ();
    if (scalar @ca_list == 0) {
        push @message, "No CAs selected"
    }
    if (scalar @mismatches == 1) {
        push @message, "No CA matching $mismatches[0]";
    }
    elsif (scalar @mismatches > 1) {
        push @message, "No CA matching any of " . join(', ', @mismatches);
    }
    die join(', ', @message), "\n";
}

Debug "Got ", scalar @ca_list, " ca record(s):\n";
if ($User_Opt->{debugging}) {
    GX::Write_Records '-multiple', '-', @ca_list;
}

GX::Use_Commands 'openssl';

if ($User_Opt->{download}) {
    GX::Get_Lock $Program_Name;
}

CA:
foreach my $ref (@ca_list) {
    Vprint "Processing $ref->{HASH} $ref->{CA_NAME}\n";
    if (Disabled $ref) {
        if ($User_Opt->{'ignore-disable'}) {
            Vprint "CA is disabled\n";
        }
        else {
            #
            # The user explicitly requested a disabled CA without
            # specifying the "-ignore-disable" option.
            #
            Error $ref, undef, undef, "CA is disabled";
        }
        if ($User_Opt->{'ignore-disable'}) {
            Vprint "Overriding \"DISABLE\" attribute\n";
            $ref->{DISABLE} = 'no';
        }
    }
    if (not Disabled $ref) {
        my $prefix = "$User_Opt->{'target-dir'}/$ref->{HASH}";
        GX::Untaint $prefix;
        $ref->{_CERT_FILE}           = "$prefix.0";
        $ref->{_SIGNING_POLICY_FILE} = "$prefix.signing_policy";
        $ref->{_CRL_FILE}            = "$prefix.r0";

        Update_And_Install_Certificate    $ref;
        Update_And_Install_CRL            $ref;
        Finalize_Certificate              $ref;
        Update_And_Install_Signing_Policy $ref;

    }
    if (defined $ref->{_ERRORS}) {
        foreach my $error (@{$ref->{_ERRORS}}) {
            Vprint ">>> $error->{message}\n";
        }
    }

    Vprint "\n";
}

#
# Check that all non-self-signed certificates have their signing
# certificates available.
#
Check_Dependencies if $Certificate_Installed;

Notify;

if ($User_Opt->{download}) {
    GX::Release_Lock $Program_Name;
}

########################################################################

sub Read_CA_List_File($) {
    my($filename) = @_;
    my @ca_list = ();
    open my $List, '<', $filename or die "${filename}: $!\n";
    while (<$List>) {
        s/#.*$//;
        s/^\s*//;
        s/\s*$//;
        next if /^$/;
        my @fields = split;
        push @ca_list, @fields;
    }
    close $List;
    return @ca_list;
} # Read_CA_List_File

# ----------------------------------------------------------------------

#
# Given a string such as "1 hour" or "10 minutes", returns the number
# of seconds.  The numeric portion must be an integer, and exactly
# one unit may be specified, either seconds, minutes, hours, or days
# (trailing 's' optional).  If you want 1.5 hours, specify "90 minutes").
#
sub String_To_Seconds($) {
    my($timestamp) = lc $_[0];
    if ($timestamp =~ /^(\d+)\s+seconds?$/) {
        return $1;
    }
    elsif ($timestamp =~ /^(\d+)\s+minutes?$/) {
        return $1 * 60;
    }
    elsif ($timestamp =~ /^(\d+)\s+hours?$/) {
        return $1 * 3600;
    }
    elsif ($timestamp =~ /^(\d+)\s+days?$/) {
        return $1 * 86400;
    }
    else {
        return undef;
    }
} # String_To_Seconds

# ----------------------------------------------------------------------

#
# Given a non-negative number of seconds, returns a string such as
# "1m12s" or "32d 12h00m00s" for display.
#
# This function is not an exact inverse of String_To_Seconds();
# the formatting is different.
#
sub Seconds_To_String($) {
    use integer;
    my($total) = @_;
    die "Internal error: Seconds_To_String($total)" if $total < 0;
    my $seconds = $total % 60;
    $total = $total / 60;
    my $minutes = $total % 60;
    $total = $total / 60;
    my $hours = $total % 24;
    my $days = $total / 24;

    if ($days > 0) {
        return sprintf "%dd %02dh %02dm %02ds",
                       $days, $hours, $minutes, $seconds;
    }
    elsif ($hours > 0) {
        return sprintf "%dh %02dm %02ds",
                       $hours, $minutes, $seconds;
    }
    else {
        return sprintf "%dm %02ds",
                       $minutes, $seconds;
    }
} # Seconds_To_String

# ----------------------------------------------------------------------

#
# Given a reference to a CA description record, returns a multi-line
# string suitable for use as a signing_policy, compatible with both GT2
# and GT4 (and GT3 pre-WS).  If the "-gt3-compatible" command-line option
# was specified, the generated signing_policy will also be compatible
# with GT3 WS.
#
# On error (i.e., MAY_SIGN is '?'), a warning message is included as
# a comment.
#
sub Signing_Policy($) {
    my($ref) = @_;

    my $unknown_policy = 0;

    my $cond_subjects;
    if (ref $ref->{MAY_SIGN} eq 'ARRAY') {
        my @list = ();
        foreach my $may_sign (@{$ref->{MAY_SIGN}}) {
            $unknown_policy = 1 if $may_sign eq '?';
            push @list, qq("$may_sign");
        }
        $cond_subjects = "'@list'";
    }
    else {
        $unknown_policy = 1 if $ref->{MAY_SIGN} eq '?';
        $cond_subjects = qq('$ref->{MAY_SIGN}');
    }

    my $result = "# $ref->{CA_NAME} Signing Policy\n";
    $result .= "# generated by $Program_Name (gx-map $GX::VERSION)\n";
    if ($ref->{SIGNING_POLICY_URL} ne '?') {
        $result .= "# See also <$ref->{SIGNING_POLICY_URL}>\n";
    }

    my $body = "access_id_CA   X509    '$ref->{SUBJECT}'\n" .
               "pos_rights     globus  CA:sign\n" .
               "cond_subjects  globus  $cond_subjects\n";

    my @bodies = ();
    my %seen = ();

    push @bodies, GX::GT2_Subject $body;
    if ($User_Opt->{'gt3-compatible'}) {
        push @bodies, GX::GT3_Subject $body
    }
    push @bodies, GX::GT4_Subject $body;

    foreach my $body (@bodies) {
        if (not $seen{$body}) {
            $result .= "\n";
            $result .= $body;
            $seen{$body} = 1;
        }
    }

    if ($unknown_policy) {
        $result .= "\n" .
                   "# WARNING: There is not enough information to generate " .
                   "a valid signing_policy.\n" .
                   "# See $ref->{_FILENAME}\n";
        Error $ref, undef, undef, "No valid signing_policy";
    }

    return $result;
} # Signing_Policy;

# ----------------------------------------------------------------------

#
# Returns the list of CA config directories in the installation.
# Directories are under the etc/gx-map subdirectory, and are either named
# "ca-config" or have names ending in ".ca-config".  The "ca-config"
# directory always appears first, followed by the others in sorted order.
#
sub CA_Config_Dir_List() {
    my @result = ();
    my $etc_dir = "$Install_Dir/etc/gx-map";
    opendir my $DIR, "$Install_Dir/etc/gx-map"
        or die "$Install_Dir/etc/gx-map: $!\n";
    my @list = grep /\.ca-config$/, sort readdir $DIR;
    closedir $DIR;
    foreach my $dir ('ca-config', @list) {
        push @result, "$etc_dir/$dir" if -d "$etc_dir/$dir";
    }
    return @result;
} # CA_Config_Dir_List

# ----------------------------------------------------------------------

#
# Given a list of directory names, reads all *.cadesc files in those
# directories, excluding any whose names begin with "00000000.".
# If there are any errors, prints a message and dies (unless the
# "-ignore-bad-cadesc" option is set).  Otherwise, returns
# a reference to a hash: keys are hashes (8 hex digits), values are CA
# references as returned by GX::Get_CA_Ref().
#
sub Get_CA_Info(@) {
    my(@dir_list) = @_;
    my @cadesc_files = ();
    my %basename = ();
    foreach my $dir (@dir_list) {
        opendir my $DIR, $dir or die "${dir}: $!\n";
        foreach my $file (sort readdir $DIR) {
            next if $file !~ /\.cadesc$/;
            next if $file =~ /^00000000\./;
            push @cadesc_files, "$dir/$file";
            $basename{"$dir/$file"} = $file;
        }
        closedir $DIR;
    }

    if (scalar @cadesc_files == 0) {
        die "No *.cadesc files found\n";
    }

    my $result = ();
    my @errors = ();

    FILE:
    foreach my $file (@cadesc_files) {
        my $basename = $basename{$file};
        my($hash, $short_name);
        if ($basename =~ /^([0-9a-f]{8})\.(.*)\.cadesc$/) {
            ($hash, $short_name) = ($1, $2);
        }
        else {
            push @errors, "Bad file name: $file\n";
            next FILE;
        }
        my $ref = GX::Get_CA_Ref $file;
        if (ref $ref eq 'ARRAY') {
            #
            # The returned value is an error message, not a hash reference.
            #
            my $s = (scalar @$ref == 1 ? '' : 's');
            push @errors, "Error$s in ${file}:\n";
            foreach my $error (@$ref) {
                push @errors, "    $error\n";
            }
        }
        elsif (ref $ref eq 'HASH') {
            #
            # Point of possible confusion:
            # The value 'HASH' returned by "ref $ref" indicates a Perl
            # hash (associative array).
            # The key value 'HASH', as in "$ref->{HASH}", is the 8-digit
            # hexadecimal hash value for the CA certificate.
            #
            if ($ref->{HASH} ne $hash) {
                push @errors,
                     "Inconsistent hash value $ref->{HASH} for file $file\n";
                next FILE;
            }
            #
            # Previously, having two cadesc files with the same hash
            # was considered an error.  With the added ability to use
            # multiple ca-config directories, we instead let later cadesc
            # files quietly override earlier ones.
            #
            # if (defined $result->{$hash}) {
            #     my $orig_name = $result->{$hash}->{_FILE_BASENAME};
            #     push @errors, "Conflicting file names in ${dir}:\n",
            #                   "$orig_name vs. $file\n";
            #     next FILE;
            # }
            $result->{$hash} = $ref;
        }
        else {
            die "Internal error, bad result from " .
                "GX::Get_CA_Ref: $ref\n";
        }
    }
    if (@errors and not $User_Opt->{'ignore-bad-cadesc'}) {
        die @errors, "Fix or use \"-ignore-bad-cadesc\"\n";
    }
    else {
        return $result;
    }
} # Get_CA_Info

# ----------------------------------------------------------------------

#
# Returns true if the DISABLE field in the *.cadesc file exists and is
# set to "yes", false otherwise.
#
sub Disabled($) {
    my($ref) = @_;
    return (defined $ref->{DISABLE} and lc $ref->{DISABLE} eq 'yes');
} # Disabled

# ----------------------------------------------------------------------

#
# Returns true if the ALLOW_MISSING_CRL field in the *.cadesc file exists
# and is set to "yes", false otherwise.
#
sub Allow_Missing_CRL($) {
    my($ref) = @_;
    return (defined $ref->{ALLOW_MISSING_CRL} and
           lc $ref->{ALLOW_MISSING_CRL} eq 'yes');
} # Allow_Missing_CRL

# ----------------------------------------------------------------------

#
# Give the names of a CRL file and a certificate file, returns a reference
# to information about the CRL:
#     hash
#     issuer
#     last_update (raw timestamp)
#     next_update (raw timestamp)
#     lifetime    (in seconds)
#     used        (proportion of lifetime already used, e.g.
#                 0.0 if it was just issued,
#                 1.0 if it's just now expiring)
#     verified
#
# The third argument specifies the form of the certificate, either 'PEM'
# or 'DER'.  (OpenSSL does not support 'NET' form CRLs.)
#
# Returns undef if the hash, issuer, last_update, and next_update values
# cannot be determined.
#
sub CRL_Info($$$) {
    my($CRL_file, $cert_file, $CRL_form ) = @_;
    my $result = {};

    Debug "%%% CRL_Info(",
          (defined $CRL_file ? $CRL_file : 'undef'),
          ", ",
          (defined $cert_file ? $cert_file : 'undef'),
          ", $CRL_form)\n";
    if ($User_Opt->{debugging}) {
        my @files = ();
        push @files, $CRL_file if defined $CRL_file;
        push @files, $cert_file if defined $cert_file;
        print "%%% % ls -lsF @files\n";
        system 'ls', '-lsF', @files;
    }

    return undef if not defined $CRL_file or not -r $CRL_file;

    #
    # Get attributes of CRL
    #
    open my $Pipe, '-|',
         "openssl crl -in '$CRL_file' -inform $CRL_form -noout " .
         "-hash -issuer -lastupdate -nextupdate 2>/dev/null"
        or return undef;
    while (<$Pipe>) {
        chomp;
        if (/^[\da-f]{8}$/) {
            $result->{hash} = $_;
        }
        elsif (/^issuer=\s*(.*)$/) {
            $result->{issuer} = GX::GT4_Subject $1;
        }
        elsif (/^lastUpdate=\s*(.*)$/) {
            $result->{last_update} = GX::Time_Value $1;
        }
        elsif (/^nextUpdate=\s*(.*)$/) {
            $result->{next_update} = GX::Time_Value $1;
        }
    }
    close $Pipe;
    
    #
    # If we didn't get everything we need, don't return any information.
    #
    foreach my $key (qw(hash issuer last_update next_update)) {
        return undef if not defined $result->{$key};
    }

    $result->{lifetime} = $result->{next_update} - $result->{last_update};
    $result->{used} = ($now - $result->{last_update}) / $result->{lifetime};

    #
    # Verify CRL against certificate.
    # (If it's ok, openssl prints "verify OK" to stderr.)
    #
    if (defined $cert_file and -r $cert_file) {
        open my $Pipe, '-|',
             "openssl crl -in '$CRL_file' -inform $CRL_form -noout " .
             "-CAfile '$cert_file' 2>&1";
        while (<$Pipe>) {
            if (/verify ok/i) {
                $result->{verified} = 1;
            }
        }
        close $Pipe;
    }

    return $result;
} # CRL_Info

# ----------------------------------------------------------------------

#
# Update CA certificate if necessary.
# Don't install it to its final location yet; wait until after we've
# checked the CRL.  Instead, install it with a ".$$" suffix.
# (We need the certificate to validate the CRL, but we want to see whether
# we have a CRL before installing the certificate, since installing a
# certificate without a CRL causes all revocations to be ignored.)
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# Refuse to install an expired certificate, but leave it alone if
# it's already installed.
#
sub Update_And_Install_Certificate($) {
    my($ref) = @_;

    Debug "Update_And_Install_Certificate, CA_NAME = ",
          (defined $ref->{CA_NAME} ? $ref->{CA_NAME} : '???'),
          "\n";
    if (not $User_Opt->{force} and -e $ref->{_CERT_FILE}) {
        Vprint "Skipping existing $ref->{_CERT_FILE}\n";
        return;
    }
    elsif ($ref->{CERTIFICATE_URL} =~ m<(https?|ftp)://>) {
        my $download_arg = $User_Opt->{download}
                               ? '-download'
                               : '-nodownload';
        my $cache_result = GX::Cache_File
                               $download_arg, $ref->{CERTIFICATE_URL};
        if ($cache_result->{status} eq 'failed') {
            Error $ref,
                  'cert_download_failed',
                  $cache_result->{timestamp},
                  "$cache_result->{error} for $ref->{CERTIFICATE_URL}";
        }
        elsif ($cache_result->{status} eq 'old') {
            Error $ref,
                  'cert_download_failed',
                  $cache_result->{timestamp},
                  "$cache_result->{error} for $ref->{CERTIFICATE_URL}, " .
                      "using cached copy",
                  'warning';
        }

        if ($cache_result->{status} ne 'failed') {
            $ref->{_CACHED_CERT_FILE} = $cache_result->{filename};
            # Debug "_CACHED_CERT_FILE = \"$cache_file\"\n";
            my $cert_info = GX::Certificate_Info
                                $cache_result->{filename},
                                $ref->{CERTIFICATE_FORM};
            if (not defined $cert_info) {
                Error $ref, 'no_cert_info',
                            GX::Get_mtime $cache_result->{filename},
                            "Can't get certificate information";
                GX::Release_Cache_File $cache_result->{filename};
                delete $ref->{_CACHED_CERT_FILE};
                return;
            }
            if (defined $cert_info->{enddate}) {
                if ($cert_info->{enddate} < $now) {
                    my $when = GX::Time_Image $cert_info->{enddate};
                    my $how_long
                        = Seconds_To_String($now - $cert_info->{enddate});
                    Error $ref, 'cert_expired',
                                $cert_info->{enddate},
                                "Certificate expired at $when ($how_long ago)";
                }
            }
            else {
                Error $ref, undef, undef,
                      "Unable to determine certificate expiration date";
            }
            if ($cert_info->{hash} ne $ref->{HASH}) {
                Error $ref, undef, undef,
                            "Mismatched hash, expected $ref->{HASH}, " .
                            "got $cert_info->{hash}";
            }
            if ($cert_info->{subject} ne $ref->{SUBJECT}) {
                Error $ref, undef, undef,
                            "Mismatched subject, expected " .
                            "\"$ref->{SUBJECT}\", got " .
                            "\"$cert_info->{subject}\"";
            }
            if (not defined $ref->{SIGNED_BY} or
                $ref->{SIGNED_BY} eq 'self')
            {
                if ($cert_info->{issuer} ne $cert_info->{subject}) {
                    my $message = "Certificate is not self-signed, but ";
                    if (defined $cert_info->{SIGNED_BY}) {
                        $message
                            .= "the SIGNED_BY attribute was set to \"self\"";
                    }
                    else {
                        $message .= "no SIGNED_BY attribute was specified";
                    }
                    $message .= " in $ref->{_FILENAME}";
                    Error $ref, undef, undef, $message;
                }
            }
            else {
                if ($cert_info->{issuer} ne $ref->{SIGNED_BY}) {
                    Error $ref, undef, undef,
                                "Mismatched issuer, expected " .
                                "\"$ref->{SIGNED_BY}\", got " .
                                "\"$cert_info->{issuer}\"";
                }
            }
            if ($cert_info->{md5sum} ne $ref->{CERTIFICATE_MD5}) {
                Error $ref, undef, undef,
                            "Mismatched md5 fingerprint, expected " .
                            "\"$ref->{CERTIFICATE_MD5}\", got " .
                            "\"$cert_info->{md5sum}\"";
            }
            if ($cert_info->{sha1sum} ne $ref->{CERTIFICATE_SHA1}) {
                Error $ref, undef, undef,
                            "Mismatched sha1 fingerprint, expected " .
                            "\"$ref->{CERTIFICATE_SHA1}\", got " .
                            "\"$cert_info->{sha1sum}\"";
            }
        }
    }
    else {
        Vprint "No URL given for certificate\n";
        return;
    }

    #
    # Don't install the certificate file if there are any errors.
    #
    if ($ref->{_FATAL_ERROR}) {
        return;
    }
    $ref->{_TEMP_CERT_FILE} = "$ref->{_CERT_FILE}.$$";
    Vprint    "Installing $ref->{_TEMP_CERT_FILE}\n";
    Log $ref, "Installing $ref->{_TEMP_CERT_FILE}\n";
    if ($ref->{CERTIFICATE_FORM} eq 'PEM') {
        File::Copy::copy $ref->{_CACHED_CERT_FILE},
                         $ref->{_TEMP_CERT_FILE}
            or Error $ref, undef, undef, "Failed to copy certificate: $!";
    }
    else {
        my $result = system "openssl x509 " .
                            "-inform $ref->{CRL_FORM} " .
                            "-in '$ref->{_CACHED_CERT_FILE}' " .
                            "-outform PEM " .
                            "-out '$ref->{_TEMP_CERT_FILE}' " .
                            "2>/dev/null";
        if ($result != 0) {
            Error $ref, undef, undef,
                  "Failed to translate certificate, " .
                  "system() returned $result";
        }
    }
    chmod $Permissions, $ref->{_TEMP_CERT_FILE}
        or Error $ref, undef, undef,
                 "chmod $Octal_Permissions, $ref->{_TEMP_CERT_FILE}: $!";
    $Certificate_Installed = 1;
    GX::Release_Cache_File $ref->{_CACHED_CERT_FILE};
    delete $ref->{_CACHED_CERT_FILE};
} # Update_And_Install_Certificate

# ----------------------------------------------------------------------

#
# Update and install CRL if necessary
#
sub Update_And_Install_CRL($) {
    my($ref) = @_;
    my $cert_file;

    return if $ref->{_FATAL_ERROR};

    Debug "Update_And_Install_CRL, CA_NAME = ",
          (defined $ref->{CA_NAME} ? $ref->{CA_NAME} : '???'),
          "\n";

    #
    # _TEMP_CERT_FILE, if set, is the newly installed temporary
    # certificate.  Otherwise, _CERT_FILE is the installed certificate.
    #
    if (defined $ref->{_TEMP_CERT_FILE} and -e $ref->{_TEMP_CERT_FILE}) {
        $cert_file = $ref->{_TEMP_CERT_FILE};
    }
    elsif (-e $ref->{_CERT_FILE}) {
        $cert_file = $ref->{_CERT_FILE};
    }
    else {
        #
        # We don't have a certificate, so we can't check the CRL (and
        # there's no point in installing it).  We should have already
        # flagged an error in Update_Certificate, so we should never
        # get here, but check it anyway.
        #
        Error $ref, undef, undef, "No certificate, can't check CRL";
        return;
    }

    # Debug "Checking $ref->{_CRL_FILE} against $cert_file\n";

    Debug "%%% Calling CRL_Info for existing CRL\n";
    my $old_crl_info
        = CRL_Info $ref->{_CRL_FILE}, $cert_file, $ref->{CRL_FORM};
    Debug "%%% After CRL_Info\n";

    # if ($User_Opt->{debugging}) {
    #     if (defined $old_crl_info) {
    #         Debug "old_crl_info:\n";
    #         my @arr = ( $old_crl_info );
    #         GX::Write_Records '-multiple', '-', @arr;
    #     }
    #     else {
    #         Debug "old_crl_info = undef\n";
    #     }
    # }

    my $install_new_crl = $User_Opt->{force};

    my $have_crl_url = $ref->{CRL_URL} =~ m<(https?|ftp)://>;
    if (not $have_crl_url) {
        #
        # If no CRL is specified, it's considered an error unless the
        # ALLOW_MISSING_CRL attribute is set to "yes" in the cadesc file.
        #
        if (not Allow_Missing_CRL $ref) {
            Error $ref, undef, undef, "No CRL specified";
        }
        return;
    }

    #
    # Attempt to download a new CRL (or use a cached copy)
    #
    my $error;
    my $download_arg = $User_Opt->{download}
                           ? '-download'
                           : '-nodownload';
    my $cache_result = GX::Cache_File
                           $download_arg, $ref->{CRL_URL};
    if ($User_Opt->{debugging}) {
        foreach my $key (sort keys %$cache_result) {
            if (defined $cache_result->{$key}) {
                Debug "%%% \$cache_result->{$key} = $cache_result->{$key}\n";
            }
            else {
                Debug "%%% \$cache_result->{$key} = undef\n";
            }
        }
    }
    if ($cache_result->{status} eq 'failed') {
        Error $ref,
              'crl_download_failed',
              $cache_result->{timestamp},
              "$cache_result->{error} for $ref->{CRL_URL}";
        return;
    }
    elsif ($cache_result->{status} eq 'old') {
        Error $ref,
              'crl_download_failed',
              $cache_result->{timestamp},
              "$cache_result->{error} for $ref->{CRL_URL}, " .
                  "using cached copy",
              'warning';
    }

    #
    # Verify signature against certificate.
    #

    # Debug "Checking " .
    #       (defined $new_crl_file ? $new_crl_file : 'undef') .
    #       " against " .
    #       (defined $cert_file ? $cert_file : 'undef') .
    #       "\n";

    Debug "%%% Calling CRL_Info for new CRL file $cache_result->{filename}\n";
    my $new_crl_info
        = CRL_Info $cache_result->{filename}, $cert_file, $ref->{CRL_FORM};
    Debug "%%% After CRL_Info\n";
    if (defined $new_crl_info) {
        Debug "%%% \$new_crl_info = $new_crl_info\n";
        foreach my $key (sort keys %$new_crl_info) {
            Debug "        $key => $new_crl_info->{$key}\n";
        }
    }
    else {
        Debug "%%% \$new_crl_info = undef\n";
    }

    # if ($User_Opt->{debugging}) {
    #     if (defined $new_crl_info) {
    #         Debug "new_crl_info:\n";
    #         my @arr = ( $new_crl_info );
    #         GX::Write_Records '-multiple', '-', @arr;
    #     }
    #     else {
    #         Debug "new_crl_info = undef\n";
    #     }
    # }

    if (defined $new_crl_info) {
        #
        # We have a new CRL; decide whether to install it.
        #
        my $remaining = $new_crl_info->{next_update} - $now;
        # Debug "remaining = $remaining\n";
        if ($remaining <= 0) {
            if (Allow_Missing_CRL $ref) {
                Vprint "CRL has expired\n";
            }
            else {
                Error $ref, 'crl_has_expired',
                            $new_crl_info->{next_update},
                            "CRL has expired";
            }
        }
        elsif (not $new_crl_info->{verified}) {
            Error $ref, undef, undef, "Can't verify new CRL";
        }
        elsif (defined $old_crl_info) {
            #
            # We have an old CRL and a new CRL; decide whether to
            # replace the old one with the new one.
            #
            if ($new_crl_info->{last_update} == $old_crl_info->{last_update} and
                $new_crl_info->{next_update} == $old_crl_info->{next_update})
            {
                if ($install_new_crl) {
                    Vprint "CRL update not needed, updating anyway (-force)\n";
                }
                else {
                    Vprint "CRL update not needed\n";
                }
            }
            elsif ($new_crl_info->{last_update} <
                   $old_crl_info->{last_update})
            {
                Error $ref, undef, undef,
                            "Newly downloaded CRL seems to be older " .
                            "than old CRL, not installing";
            }
            else {
                $install_new_crl = 1;
            }
        }
        else {
            $install_new_crl = 1;
        }
    }
    else {
        #
        # We don't have a new CRL
        #
        Error $ref, undef, undef, "Unable to get information for CRL";
    }

    # Debug "install_new_crl = $install_new_crl\n";

    if ($install_new_crl) {
        Vprint    "Installing $ref->{_CRL_FILE}\n";
        Log $ref, "Installing $ref->{_CRL_FILE}\n";
        my $temp_file = "$ref->{_CRL_FILE}.$$";
        if (not defined $ref->{CRL_FORM} or $ref->{CRL_FORM} eq 'PEM') {
            File::Copy::copy $cache_result->{filename}, $temp_file
                or Error $ref, undef, undef, "Failed to copy CRL: $!";
        }
        else {
            my $result = system "openssl crl " .
                                "-inform $ref->{CRL_FORM} " .
                                "-in '$cache_result->{filename}' " .
                                "-outform PEM " .
                                "-out '$temp_file' " .
                                "2>/dev/null";
            if ($result != 0) {
                Error $ref, undef, undef,
                      "Failed to translate CRL, system() returned $result";
            }
        }
        chmod $Permissions, $temp_file
            or Error $ref, undef, undef,
                     "chmod $Octal_Permissions, $temp_file: $!";
        rename $temp_file, $ref->{_CRL_FILE}
            or Error $ref, undef, undef, "Failed to rename CRL: $!";
    }

    if (defined $ref->{_CRL_FILE}) {
        Debug "%%% \$ref->{_CRL_FILE} = \"$ref->{_CRL_FILE}\"\n";
        if (-r $ref->{_CRL_FILE}) {
            Debug "%%% File is readable\n";
        }
        elsif (-e $ref->{_CRL_FILE}) {
            Debug "%%% File exists but is not readable\n";
        }
        else {
            Debug "%%% File does not exist\n";
        }
    }
    else {
        Debug "%%% \$ref->{_CRL_FILE} = undef\n";
    }

    #
    # Just to be sure, re-fetch CRL info from the target CRL file
    # (which may or may not have just been updated).  This is the
    # installed CRL, so it's in PEM format.
    #
    if (-r $ref->{_CRL_FILE}) {
        Debug "%%% Re-fetching CRL info for $ref->{_CRL_FILE}\n";
        my $crl_info
            = CRL_Info $ref->{_CRL_FILE}, $cert_file, 'PEM';
        Debug "%%% After CRL_Info\n";
        my $remaining = $crl_info->{next_update} - $now;
        my $remove_crl = 0;
        if (defined $crl_info) {
            if (not $crl_info->{verified}) {
                Error $ref, undef, undef, "Removing unverified CRL";
                $remove_crl = 1;
            }
            if ($remove_crl) {
                unlink $ref->{_CRL_FILE};
            }
            else {
                my $expiration_string
                    = GX::Time_Image $crl_info->{next_update};
                my $how_long = Seconds_To_String abs $remaining;
                my $notify = 0;
                if ($crl_info->{used} > 0.9) {
                    $notify = 1;
                }
                if ($remaining < 0) {
                    Error $ref, 'crl_has_expired',
                                $crl_info->{next_update},
                                "CRL expired at $expiration_string " .
                                "($how_long ago)";
                }
                elsif ($remaining == 0) {
                    Error $ref, 'crl_will_expire',
                                $crl_info->{next_update},
                                "CRL expires at $expiration_string";
                }
                else {
                    if ($notify) {
                        Error $ref, 'crl_will_expire',
                                    $crl_info->{next_update},
                                    "CRL will expire at $expiration_string " .
                                    "($how_long from now)",
                                    'warning';
                    }
                    else {
                        Vprint "CRL will expire at $expiration_string " .
                               "($how_long from now)\n";
                    }
                }
                if (not $crl_info->{verified}) {
                    Error $ref, undef, undef, "CRL is not verified";
                }
            }
        }
    }
    else {
        Vprint"No CRL\n";
    }
    if (defined $cache_result->{filename}) {
        GX::Release_Cache_File $cache_result->{filename};
    }
} # Update_And_Install_CRL

# ----------------------------------------------------------------------

#
# If the certificate has been installed with a temporary name,
# rename it to its final name if there have been no errors.
# If there have been any errors, delete the temporary certificate.
#
sub Finalize_Certificate($) {
    my($ref) = @_;

    if ($ref->{_FATAL_ERROR}) {
        if (defined $ref->{_TEMP_CERT_FILE}) {
            unlink $ref->{_TEMP_CERT_FILE};
            delete $ref->{_TEMP_CERT_FILE};
        }
    }

    elsif (not $User_Opt->{force} and -e $ref->{_CERT_FILE}) {
        Vprint "Certificate $ref->{HASH}.0 is already installed\n";
    }

    else {
        Vprint    "Installing $ref->{_CERT_FILE}\n";
        Log $ref, "Installing $ref->{_CERT_FILE}\n";
        chmod $Permissions, $ref->{_TEMP_CERT_FILE}
            or Error $ref, undef, undef,
                     "chmod $Octal_Permissions, $ref->{_TEMP_CERT_FILE}: $!";
        rename $ref->{_TEMP_CERT_FILE}, $ref->{_CERT_FILE}
            or Error $ref, undef, undef, "Failed to rename certificate: $!";
        $Certificate_Installed = 1;
    }
} # Finalize_Certificate

# ----------------------------------------------------------------------

#
# Update signing_policy file if necessary.
# If the file exists, we assume it doesn't need to be updated unless the
# "-force" option was specified.
# For now, we ignore the SIGNING_POLICY_URL; the signing_policy is
# generated from the MAY_SIGN attributes.
# Don't bother to install if there have been any errors.
#
sub Update_And_Install_Signing_Policy($) {
    my($ref) = @_;

    return if $ref->{_FATAL_ERROR};

    if (not $User_Opt->{force} and -e $ref->{_SIGNING_POLICY_FILE}) {
        Vprint "Skipping existing $ref->{_SIGNING_POLICY_FILE}\n";
    }
    else {
        Vprint    "Creating $ref->{_SIGNING_POLICY_FILE}\n";
        Log $ref, "Creating $ref->{_SIGNING_POLICY_FILE}\n";
        my $temp_file = "$ref->{_SIGNING_POLICY_FILE}.$$";
        my $signing_policy = Signing_Policy $ref;
        if (not defined $signing_policy) {
            Error $ref, undef, undef, "Can't determine valid signing_policy";
            return;
        }
        open my $Policy, '>', $temp_file or die "$temp_file: $!\n";
        print $Policy $signing_policy;
        close $Policy;
        if (not chmod $Permissions, $temp_file) {
            Error $ref, undef, undef,
                  "chmod $Octal_Permissions, " .
                  "$ref->{_SIGNING_POLICY_FILE}: $!";
            return;
        }
        if (not rename $temp_file, $ref->{_SIGNING_POLICY_FILE}) {
            Error $ref, undef, undef, "Failed to rename signing_policy: $!";
            return;
        }
        $ref->{_INSTALLED_SIGNING_POLICY} = 1;
    }
} # Update_And_Install_Signing_Policy

# ----------------------------------------------------------------------

#
# Confirm that all installed certificates have their signers available
# (if not self-signed).
#
sub Check_Dependencies() {
    my @errors = ();
    REF:
    foreach my $ref (@ca_list) {
        #
        # We could specifically check each non-self-signed CA certificate
        # against its signer, but it's easier to check against the
        # directory using "-CApath".
        #
        next if not defined $ref->{SIGNED_BY};
        my $target_dir = $User_Opt->{'target-dir'};
        my $certificate_file = "$target_dir/$ref->{HASH}.0";
        if (not -e $certificate_file) {
            Error $ref, undef, undef, "$certificate_file is missing";
            next REF;
        }
        GX::Untaint $target_dir;
        GX::Untaint $certificate_file;
        my $Pipe = undef;
        if (not open $Pipe, '-|',
                     "openssl verify -CApath $target_dir " .
                     "'$certificate_file' 2>/dev/null")
        {
            Error $ref, undef, undef,
                  "Check_Dependencies failed to invoke openssl";
            next REF;
        }
        my $ok = 0;
        while (<$Pipe>) {
            if (/: OK$/) {
                $ok = 1;
            }
        }
        close $Pipe;
        if (not $ok) {
            my $mtime = GX::Get_mtime $certificate_file;
            Error $ref,
                  'dependency_check_failed',
                  $mtime,
                  "Dependency check failed";
        }
    }
} # Check_Dependencies

# ----------------------------------------------------------------------

#
# Log a message.
# Annotate the CA reference (first argument) with the message.
#
sub Log($$) {
    my($ref, $message) = @_;
    push @{$ref->{_MESSAGES}}, $message;
} # Log

# ----------------------------------------------------------------------

sub Error_File($) {
    my($error_ref) = @_;
    if (defined $error_ref->{desc}) {
        my $name = sprintf "%010s.%s.%s",
                           $error_ref->{timestamp},
                           $error_ref->{ca_hash},
                           $error_ref->{desc};
        return "$Data_Dir/reported-errors/$name";
    }
    else {
        return undef;
    }
} # Error_File

# ----------------------------------------------------------------------

#
# Report an error.
# The arguments are:
#      $ref
#          A reference to the CA record.
#      $desc
#          A brief description, used to distinguish different kinds of errors,
#          suitable for inclusion in a filename.
#          If this is defined, an error file may be created.
#          May be undef.
#      $timestamp
#          A timestamp, typically the expiration time of the CRL
#          May be undef.
#      $message
#          A human-readable error message, terminated with a newline.
# Optional:
#      $severity
#          An optional argument, set to 'warning' for a non-fatal warning,
#          'error' for a fatal error.  If this argument does not exist,
#          assume a fatal error.
# Annotate the CA reference (first argument) with an error record.
#
sub Error($$$$;$) {
    my($ref, $desc, $timestamp, $message, $severity) = @_;
    my $warning_only = 0;
    if (defined $severity) {
        if ($severity eq 'warning') {
            $warning_only = 1;
        }
        elsif ($severity eq 'error') {
            $warning_only = 0;
        }
        else {
            die "Internal error, bad severity argument to Error()\n";
        }
    }
    my $error_ref = {};
    $error_ref->{message}   = $message;
    $error_ref->{ca_hash}   = $ref->{HASH};
    $error_ref->{desc}      = $desc      if defined $desc;
    $error_ref->{timestamp} = $timestamp if defined $timestamp;

    my $error_file = Error_File $error_ref;
    if (defined $error_file) {
        $error_ref->{filename} = $error_file;
        if (-e $error_file) {
            $error_ref->{reported} = 1;
        }
        #
        # If the error file doens't exist, it will be created by Notify().
        #
    }

    push @{$ref->{_ERRORS}}, $error_ref;
    if (not $warning_only) {
        $ref->{_FATAL_ERROR} = 1;
    }
} # Error

# ----------------------------------------------------------------------

sub Append_To_Log($$) {
    my($log_file, $message) = @_;
    GX::Untaint $log_file;

    my $Log;

    if (not open $Log, '>>', $log_file) {
        warn "Error appending to log $log_file: $!\n" .
             "Message was:\n" .
             $message;
    }
    elsif (not print $Log $message) {
        warn "Error printing to log $log_file: $!\n" .
             "Message was:\n" .
             $message;
    }
    elsif (not close $Log) {
        warn "Error closing log $log_file: $!\n" .
             "Message was:\n" .
             $message;
    }
} # Append_To_Log

# ----------------------------------------------------------------------

#
# Send an error notification by e-mail.
# Log messages to log file.
# Error files in the gx-map-data/reported-errors directory are used to
# track which errors have already been reported by e-mail; all errors are
# logged regardless.  Some classes of errors are not currently recorded
# in error files; these are treated as new errors and can potentially
# be reported by e-mail repeatedly.
#
sub Notify() {
    my $total_ca_count = scalar @ca_list;
    my $error_ca_count = 0;       # CAs with errors
    my $new_error_ca_count = 0;   # CAs with new errors
    my $error_count = 0;          # Number of errors
    my $new_error_count = 0;      # Number of new errors
    my $log_message_body = '';
    my $mail_message_body = '';

    $log_message_body
        .= GX::Time_Image($now) .
           " $Program_Name (gx-map $GX::VERSION) on $Hostname\n";

    #
    # _NEW_ERRORS is a subset of _ERRORS, specifically the errors
    # that need to be reported by e-mail.
    #
    foreach my $ref (@ca_list) {
        if (defined $ref->{_ERRORS}) {
            $error_ca_count ++;
            $error_count += scalar @{$ref->{_ERRORS}};
            foreach my $error (@{$ref->{_ERRORS}}) {
                if (not $error->{reported}) {
                    push @{$ref->{_NEW_ERRORS}}, $error;
                    $new_error_count ++;
                    if (defined $error->{filename}) {
                        open my $File, '>', $error->{filename};
                        print $File "$error->{message}\n";
                        close $File;
                    }
                }
            }
            if (defined $ref->{_NEW_ERRORS}) {
                $new_error_ca_count ++;
            }
        }
    }

    foreach my $ref (@ca_list) {
        if (defined $ref->{_MESSAGES} or defined $ref->{_ERRORS}) {
            $log_message_body .= "$ref->{HASH} $ref->{CA_NAME}:\n";

            if (defined $ref->{_MESSAGES}) {
                foreach my $message (@{$ref->{_MESSAGES}}) {
                    $log_message_body .= "    $message";
                }
            }

            if (defined $ref->{_ERRORS}) {
                my @error_list = @{$ref->{_ERRORS}};
                foreach my $error (@error_list) {
                    $log_message_body .= "    >>> ERROR: $error->{message}\n";
                }
            }

            if (defined $ref->{_NEW_ERRORS}) {
                my @error_list = @{$ref->{_NEW_ERRORS}};
                $mail_message_body .= "$ref->{HASH} $ref->{CA_NAME}:\n";
                foreach my $error (@error_list) {
                    $mail_message_body .= "$error->{message}\n";
                }
                $mail_message_body .= "\n";
            }
        }
    }

    $log_message_body .= "\n";

    my $log_file = "$Install_Dir/gx-map-data/$Program_Name.log";
    Append_To_Log $log_file, $log_message_body;

    if ($User_Opt->{email} and $new_error_count > 0) {
        my $subject = "$Program_Name: $new_error_count error(s), " .
                      "$new_error_ca_count/$total_ca_count CA(s)";

        my $recipient = $GX::Config->{ADMIN_EMAIL};
        $mail_message_body
            .= "\n$Program_Name (gx-map $GX::VERSION) on " .
               "$Hostname\n";
        GX::Send_Email $Program_Name,
                       $GX::Config->{ADMIN_EMAIL},
                       $subject,
                       $mail_message_body;
    }
} # Notify

# ----------------------------------------------------------------------

#
# Print a message if "-verbose" option was given
#
sub Vprint(@) {
    print @_ if $User_Opt->{verbose};
} # Vprint

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Usage(@) {
    if (@_) {
        print @_;
        print "Run \"$Program_Name -help\" for more information\n";
    }
    else {
        print <<"EOF";
Usage: $Program_Name [options]
    -help              Display this message and exit.
    -version           Display version information and exit.
    -ca name           Name of a CA.  This option may be given multiple
                       times, or CA names may be delimited by commas or
                       blanks.  The argument is a field of the *.cadesc
                       file name; use the hash value to avoid ambiguity.
    -ca-list file      Name of a text file containing a list of CAs.
                       Comments are introduced by '#'.
                       Leading and trailing whitespace and blank lines
                       are ignored.
                       CAs are specified the same way as arguments to the
                       "-ca" option.
                       Multiple "-ca-list" options may be given.
                       The "-ca" and "-ca-list" options may be combined.
                       If no "-ca" or "-ca-list" option is specified, try
                       to use a ".ca-list" file in the target directory.
    -list-cas          List available CAs and exit.
    -list-all-cas      Like "-list-cas", but include disabled CAs.
    -target-dir dir    Target directory.
    -[no]download      By default, gx-ca-update attempts to download
                       files as needed.  With "-nodownload", use only
                       existing files in the cache directory.
    -permissions perm  Specify permissions for installed files (in octal);
                       default is 444
    -gt3-compatible    Generate *.signing_policy files compatible with
                       GT3 web services tools.  This should rarely
                       be necessary or useful.  By default, generated
                       *.signing_policy files are compatible with both
                       GT2 and GT4, and with GT3 pre-WS.
    -force             Force file updates.
    -email             Send e-mail to configured ADMIN_EMAIL address on errors.
                       Default is "-email"; use "-noemail" to disable.
    -ignore-bad-cadesc By default, a syntax error in a cadesc file causes
                       gx-ca-update to die with an error message.  With
                       this option, cadesc files with errors are ignored.
    -verbose           Print verbose messages.
    -debugging         Enable debugging output.
EOF
    }
    exit 1;
} # Usage
