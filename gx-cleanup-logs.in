#!%PERL% -wT

# $Id: gx-cleanup-logs.in,v 1.11 2005-06-29 00:27:40-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-cleanup-logs.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2005 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use File::Copy ();
use Getopt::Long ();

sub Usage(@);
sub Is_Secondary($);
sub Debug(@);
sub Debugf(@);

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

$ENV{PATH} = '/bin:/usr/bin';

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();

my $Program_Name = File::Basename::basename $0;

my $User_Opt = {};
my @Opts = ( $User_Opt,
             qw( help
                 version
                 merge-only!
                 delete!
                 index!
                 debugging! ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};

if ($User_Opt->{version}) {
    print "$Program_Name (gx-map) $Gridmap_Utils::VERSION\n";
    exit 0;
}

Gridmap_Utils::Install_Die_Handler;
Gridmap_Utils::Install_Warn_Handler;

if ($User_Opt->{debugging}) {
    $Gridmap_Utils::Debugging = 1;
}

my @input_logs = ( @ARGV ? @ARGV : '-' );

my @requests;
foreach my $log (@input_logs) {
    push @requests,
         Gridmap_Utils::Read_Records '-multiple', '-keep-comments', $log;
}

#
# Index each record so we can do a stable sort.
# Perl 5.6 and earlier uses an unstable quicksort.
# Later Perls use a stable mergesort by default.
#
# This field will be deleted before writing unless
# the "-index" option has been specified.
#
for (my $i = 0; $i <= $#requests; $i ++) {
    $requests[$i]->{__INDEX__} = $i;
}

if ($User_Opt->{debugging}) {
    Debug "Before sorting:\n";
    foreach my $request (@requests) {
        Debugf "%6d  %s %s %s\n", $request->{__INDEX__},
                                  $request,
                                  $request->{timestamp},
                                  $request->{operation};
    }
}

#
# Sort by timestamp and index
#
@requests = sort { $a->{timestamp} cmp $b->{timestamp} ||
                   $a->{__INDEX__} <=> $b->{__INDEX__}
                 } @requests;

if ($User_Opt->{debugging}) { 
    Debug "After sorting:\n";
    foreach my $request (@requests) {
        Debugf "%6d  %s %s %s\n", $request->{__INDEX__},
                                  $request,
                                  $request->{timestamp},
                                  $request->{operation};
    }
}

#
# Create indexing hashes to allow quick searches for a given DN or
# user name.  For %by_dn, keys are DNs and values are references to
# arrays of request records.  Similarly, for %by_name, keys are user
# names and values are references to arrays of request records.
#
my %by_dn = ();
my %by_name = ();
foreach my $request (@requests) {
    if (defined $request->{dn}) {
      push @{$by_dn{$request->{dn}}}, $request;
    }
    if (defined $request->{map_to_name}) {
      push @{$by_name{$request->{map_to_name}}}, $request;
    }
}

if (not $User_Opt->{'merge-only'}) {
    #
    # Delete redundant records:
    #
    # Start at the most recent and go backwards in time.
    #
    # For a remove, delete it and all previous adds and removes for the same
    # user/DN pair.
    #
    # For a remove-user, delete it and all previous adds, removes, and
    # remove-users for the same user.
    # 
    # For a remove-dn, delete it and all previous adds and removes for the same
    # DN.
    #
    # For an add, leave it in place but delete all previous adds and removes
    # for the same user/DN pair -- *unless* it's marked secondary, then leave
    # it alone.
    #
    # This won't delete all redundant requests, but it should catch most
    # of them.
    #
    NEW:
    foreach my $new (reverse @requests) {
        next NEW if $new->{operation} eq 'comment';
        my $new_op = $new->{operation};
        my $new_index = $new->{__INDEX__};
        Debug "Outer loop, $new_index, $new_op\n";
        if ($new_op =~ /^remove/) {
            $new->{__DELETED__} = 1;
        }

        #
        # Collect references for all records older than $new that refer
        # to the same DN and/or user name.
        #
        my %match = ();
        if (defined $new->{dn}) {
            foreach my $ref (@{$by_dn{$new->{dn}}}) {
                next if $ref->{__INDEX__} >= $new_index;
                $match{$ref->{__INDEX__}} = 1;
            }
        }
        if (defined $new->{map_to_name}) {
            foreach my $ref (@{$by_name{$new->{map_to_name}}}) {
                next if $ref->{__INDEX__} >= $new_index;
                $match{$ref->{__INDEX__}} = 1;
            }
        }
        my @old = ();
        foreach my $index ( sort { $a <=> $b } keys %match ) {
            push @old, $requests[$index];
        }

        OLD:
        foreach my $old (@old) {
            my $old_op = $old->{operation};
            next OLD if $old_op eq 'comment';
            next OLD if exists $old->{__DELETED__};
            Debug "Inner loop, $old->{__INDEX__}, $old_op\n";
            next if $new->{NAMESPACE} ne $old->{NAMESPACE};

            if ( $new_op eq 'remove' and
                 ( $old_op eq 'add' or $old_op eq 'remove' ) and
                 $old->{map_to_name} eq $new->{map_to_name} and
                 $old->{dn} eq $new->{dn} )
            {
                Debug "Deleting $old->{__INDEX__}, $old_op\n";
                $old->{__DELETED__} = 1;
                if ($User_Opt->{index}) {
                    $old->{INDEX} .= " ($new->{INDEX})";
                }
            }

            elsif ( $new_op eq 'remove-user' and
                    ( $old_op eq 'add' or
                      $old_op eq 'remove' or
                      $old_op eq 'remove-user' ) and
                    $old->{map_to_name} eq $new->{map_to_name} )
            {
                Debug "Deleting $old->{__INDEX__}, $old_op\n";
                $old->{__DELETED__} = 1;
                if ($User_Opt->{index}) {
                    $old->{INDEX} .= " ($new->{INDEX})";
                }
            }

            elsif ( $new_op eq 'remove-dn' and
                    ( $old_op eq 'add' or
                      $old_op eq 'remove' or
                      $old_op eq 'remove-dn' ) and
                    $old->{dn} eq $new->{dn} )
            {
                Debug "Deleting $old->{__INDEX__}, $old_op\n";
                $old->{__DELETED__} = 1;
                if ($User_Opt->{index}) {
                    $old->{INDEX} .= " ($new->{INDEX})";
                }
            }

            elsif ( $new_op eq 'add' and
                    not Is_Secondary $old and
                    ( $old_op eq 'add' or $old_op eq 'remove' ) and
                    $old->{map_to_name} eq $new->{map_to_name} and
                    $old->{dn} eq $new->{dn} )
            {
                Debug "Deleting $old->{__INDEX__}, $old_op\n";
                $old->{__DELETED__} = 1;
                if ($User_Opt->{index}) {
                    $old->{INDEX} .= " ($new->{INDEX})";
                }
            }
        }
    }
}

if ($User_Opt->{debugging}) {
    Debug "After filtering:\n";
    foreach my $request (@requests) {
        Debugf "%6d  %s %s %s\n", $request->{__INDEX__},
                                  $request,
                                  $request->{timestamp},
                                  $request->{operation};
    }
}

if (not $User_Opt->{index}) {
    foreach my $request (@requests) {
        delete $request->{__INDEX__};
    }
}

if ($User_Opt->{delete}) {
    @requests = grep { not exists $_->{__DELETED__} } @requests;
}

Gridmap_Utils::Write_Records '-multiple', '-', @requests;

########################################################################

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name [options] [files]
Option names may be abbreviated.
    -help        Display this message and exit.
    -version     Display version information and exit.
    -merge-only  Merge and sort input records; don't delete anything.
    -delete      Delete redundant requests (default is to comment them out).
    -index       Add an __INDEX__ field to each record (for debugging only).
    -debugging   Enable debugging output.

Read gx-map requests log(s) from specified files or from stdin.
Write to stdout a requests log, sorted by timestamp, with redundant
requests commented out or deleted.
EOF
    exit 1;
} # Usage

# ----------------------------------------------------------------------

sub Is_Secondary($) {
    my($ref) = @_;
    return ( defined $ref->{secondary} and $ref->{secondary} eq 'yes' );
} # Is_Secondary

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $User_Opt->{debugging};
} # Debugf
