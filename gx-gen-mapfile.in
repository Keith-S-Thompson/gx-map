#!%PERL% -wT

# $Id: gx-gen-mapfile.in,v 1.42 2004-11-16 00:53:42-08 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-gen-mapfile.in,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2004 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

#
# TO DO:
#
# Check the new grid-mapfile into an RCS directory.
# Add a "-norcs" option to disable this.
# Obviously don't do an RCS checkin if writing to stdout.
# If multiple output files are specified, check the last one into RCS
# (or provide some way to specify it?).
#
# If multiple output files are specified, keep going if one of the writes
# fails (but collect the errors and print a warning).  Motivation: On Blue
# Horizon we (probably) want to write the grid-mapfile both to a local
# filesystem and to /projects/globus.  If /projects/globus is dismounted,
# we still want to update the local grid-mapfile.  (Workaround for now:
# specify /projects/globus last.)
#

use strict;

use File::Basename ();
use File::Copy ();
use Getopt::Long ();

sub Update_List(@);
sub Identical_Files($$);
sub User_Real_Name($);
sub Image($);
sub Die_Handler($);
sub Usage(@);
sub Debug(@);
sub Debugf(@);

# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

$ENV{PATH} = '/bin:/usr/bin';

my $Install_Dir;
BEGIN {
    $Install_Dir = '%INSTALL_DIR%';
    unshift @INC, "$Install_Dir/lib";
}
use Gridmap_Utils ();
use Gridmap_Valid_Mappings ();

my $Data_Dir             = "$Install_Dir/var";
my $Default_Requests_Log = "$Data_Dir/requests.log";
my $Dot_Update           = "$Data_Dir/new-requests/.update";

my $Prog_Name = File::Basename::basename $0;

my $User_Opt = { 'requests-log' => [],
                 'permissions'  => '444' };
my @Opts = ( $User_Opt,
             qw( help
                 version
                 debugging!
                 requests-log=s@
                 permissions=s
                 all!
                 dump!
                 real-name! ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};

if ($User_Opt->{version}) {
    print "gx-map version $Gridmap_Utils::VERSION\n";
    exit 0;
}

#
# If the requests-log array is empty (i.e., the user didn't give the
# '-requests-log' option), set it to a single element consisting of the
# name of the default log.  If it's non-empty, replace any occurrence of
# 'default' with the name of the default log.
#
if (@{$User_Opt->{'requests-log'}}) {
    foreach my $log (@{$User_Opt->{'requests-log'}}) {
        #
        # $log is an alias for each element of the array, and can be
        # used to modify it.
        #
        if ($log eq 'default') {
            $log = $Default_Requests_Log;
            Debug "Setting \$log = \"$log\"\n";
        }
        elsif ($log =~ m<^(https?|ftp)://>) {
            #
            # Untaint the log file name so the Cache_File function can
            # use system() to pass it to wget.
            #
            Gridmap_Utils::Untaint $log;
            $log = Gridmap_Utils::Cache_File $log;
        }
    }
}
else {
    $User_Opt->{'requests-log'} = [ $Default_Requests_Log ];
}

if ($User_Opt->{debugging}) {
    $Gridmap_Utils::Debugging = 1;
    $Gridmap_Valid_Mappings::Debugging = 1;
}

my @Output_Files = @ARGV;
my $Write_To_Stdout = (scalar @Output_Files == 0);
my %Force_Update = ();

#
# Untaint the output file names
#
foreach my $file (@Output_Files) {  
    Gridmap_Utils::Untaint $file;
}

if ($User_Opt->{permissions} !~ /^[0-7][0-7][0-7]$/) {
    Usage "Permissions must be a 3-digit octal number\n";
}
$User_Opt->{permissions} = oct "0$User_Opt->{permissions}";

if (not $Write_To_Stdout) {
    Debug "\@Output_Files = (@Output_Files)\n";
    @Output_Files = Update_List @Output_Files;
    Debug "\@Output_Files = (@Output_Files)\n";
    if (scalar @Output_Files == 0) {
        exit 0;
    }
}

my @requests;
foreach my $log (@{$User_Opt->{'requests-log'}}) {
    push @requests, Gridmap_Utils::Read_Records '-multiple', $log;
}

#
# Sort by timestamp
#
@requests = sort { $a->{timestamp} cmp $b->{timestamp} } @requests;

#
# Process removals
#
my %Mappings = (); # key = DN, value = hash ref
my @dump_lines = ();

REQUEST:
foreach my $request (map Gridmap_Utils::Dup_Ref $_, @requests) {
    #
    # By calling Valid_Mappings, we eliminate any requests for accounts
    # that don't exist on this system (unless the "-all" option was
    # specified).  This should also eliminate any unauthorized requests
    # (which theoretically, could be created only by something like a
    # hacked copy of gx-map).  The Valid_Mappings function can also be
    # modified for site-specific requirements, such as rejecting mappings
    # for certain accounts or for certificates issued by certain CAs.
    #
    # The Valid_Mappings function may return multiple mappings for a
    # single request.
    #
    # Note that each mapping contains only the "dn" and/or "map_to_name"
    # fields; other information, such as the operation and the timestamp,
    # come from the original request, and thus may not be modified by
    # the Valid_Mappings function.
    #
    my @options = ();
    push @options, '-all' if $User_Opt->{all};
    my @request_mappings
        = Gridmap_Valid_Mappings::Valid_Mappings @options, $request;
    my $operation = $request->{operation};
    foreach my $mapping (@request_mappings) {
        if ($User_Opt->{dump}) {
            my $timestamp = Image $request->{timestamp};
            $timestamp =~ s/ .*$//;
            my $source    = Image $request->{SOURCE};
            my $namespace = Image $request->{NAMESPACE};
            my $op        = Image $request->{operation};
            my $user      = Image $mapping->{map_to_name};
            my $dn        = Image $mapping->{dn};
            my $priority;
            if ($op eq 'add') {
                if (defined $request->{secondary} and
                    $request->{secondary} eq 'yes')
                {
                    $priority = 'S';
                }
                else {
                    $priority = 'P';
                }
            }
            else {
                $priority = '?';
            }
            push @dump_lines,
                 sprintf "%-10s %-8s %-8s %-11s %-8s %s %s\n",
                         $timestamp,
                         $source,
                         $namespace,
                         $op,
                         $user,
                         $priority,
                         $dn;
            next REQUEST;
        }
        #
        # $mapping is a reference to a hash with keys "dn" and
        # "map_to_name", both optional.
        #
        my $dn          = exists $mapping->{dn}
                          ? $mapping->{dn}
                          : undef;
        my $map_to_name = exists $mapping->{map_to_name}
                          ? $mapping->{map_to_name}
                          : undef;
        my $timestamp = $request->{timestamp};
        $timestamp =~ s/ .*$//;
        my $is_primary = ( not defined $request->{secondary} or
                           $request->{secondary} ne 'yes' );

        Debug ">>> Processing mapping, operation = $operation, dn = ",
              (defined $dn ? $dn : "undef"),
              ", map_to_name = ",
              (defined $map_to_name ? "\"$map_to_name\"" : "undef"),
              "\n";
        if ($operation eq 'add') {
            #
            # Add a mapping; we have a DN and a user name.
            #
            # If it's primary, set the primary mapping (overriding any
            # previous primary mapping; There Can Be Only One).
            #
            # If it's secondary, set a secondary mapping (which may coexist
            # with other secondary mappings).
            #
            if ($is_primary) {
                Debug ">>> Add $dn --> $map_to_name (primary)\n";
                $Mappings{$dn}->{primary} = $map_to_name;
            }
            else {
                Debug ">>> Add $dn --> $map_to_name (secondary)\n";
                $Mappings{$dn}->{secondary}->{$map_to_name} = $timestamp;
            }
        }
        elsif ($operation eq 'remove') {
            if (exists $Mappings{$dn}) {
                if ($Mappings{$dn}->{primary} eq $map_to_name) {
                    Debug ">>> Delete $dn --> $map_to_name (primary)\n";
                    delete $Mappings{$dn}->{primary};
                }
                if (exists $Mappings{$dn}->{secondary} and
                    exists $Mappings{$dn}->{secondary}->{$map_to_name})
                {
                    Debug ">>> Delete $dn --> $Mappings{$dn} (secondary)\n";
                    delete $Mappings{$dn}->{secondary}->{$map_to_name};
                    if (scalar keys %{$Mappings{$dn}->{secondary}} == 0) {
                        delete $Mappings{$dn}->{secondary}; # cleanup
                    }
                }
                if (scalar keys %{$Mappings{$dn}} == 0) {
                    delete $Mappings{$dn}; # cleanup
                }
            }
        }
        elsif ($operation eq 'remove-dn') {
            if (exists $Mappings{$dn}) {
                Debug ">>> Delete $dn\n";
                delete $Mappings{$dn};
            }
        }
        elsif ($operation eq 'remove-user') {
            #
            # Don't waste time sorting the keys.
            #
            foreach my $dn (keys %Mappings) {
                if (exists $Mappings{$dn}->{primary} and
                    $Mappings{$dn}->{primary} eq $map_to_name)
                {
                    Debug ">>> Delete $dn --> $map_to_name (primary)\n";
                    delete $Mappings{$dn}->{primary};
                }
                if (exists $Mappings{$dn}->{secondary} and
                    exists $Mappings{$dn}->{secondary}->{$map_to_name}) {
                    Debug ">>> Delete $dn --> $map_to_name (secondary)\n";
                    delete $Mappings{$dn}->{secondary}->{$map_to_name};
                    if (scalar keys %{$Mappings{$dn}->{secondary}} == 0) {
                        delete $Mappings{$dn}->{secondary}; # cleanup
                    }
                }
                if (scalar keys %{$Mappings{$dn}} == 0) {
                    delete $Mappings{$dn}; # cleanup
                }
            }
        }
        else {
            die "Internal error, operation = \"$operation\"\n";
        }

        if ($User_Opt->{debugging}) {
            Debug ">>> Current grid-mapfile entries:\n";
            foreach my $dn (sort keys %Mappings) {
                Debug "* $dn\n";
                Debug "    Primary: ";
                if (defined $Mappings{$dn}->{primary}) {
                    Debug "$Mappings{$dn}->{primary}\n";
                }
                else {
                    Debug "undef\n";
                }
                Debug "    Secondary: ";
                my @secondaries = ();
                if (exists $Mappings{$dn}->{secondary}) {
                    foreach my $name (keys %{$Mappings{$dn}->{secondary}}) {
                        my $ref = $Mappings{$dn}->{secondary}->{$name};
                        push @secondaries, "$name:$ref->{$name}";
                    }
                }
                Debug "( @secondaries )\n";
            }
            Debug "<<< END\n";

        }
    }
}

my $tmp_file = "/tmp/gx-gen-mapfile-" . time . "-$$";

#
# If we're creating output files, write to a single temp file and
# copy it to the output files later.  Otherwise just write directly
# to stdout.
#
if ($Write_To_Stdout) {
    open OUT, ">&STDOUT";
}
else {
    open OUT, ">$tmp_file" or die "$tmp_file: $!\n";
}

$SIG{__DIE__} = \&Die_Handler;

my $Now = Gridmap_Utils::Time_Image time;
$Now =~ s/^\d+ //;       # We don't need the raw numeric timestamp
my $Hostname = Gridmap_Utils::Get_Hostname;
print OUT <<"EOF";
#
# Automatically generated by gx-gen-mapfile (gx-map $Gridmap_Utils::VERSION)
# at $Now on $Hostname.
# Do not edit this file.
#
EOF

if ($User_Opt->{dump}) {
    print OUT <<'EOF';
# This is a log dump, not a grid-mapfile
# Fields are:
#     timestamp source namespace operation user priority dn
# (priority is 'P' for a primary mapping, 'S' for a secondary mapping)

EOF
    print OUT @dump_lines;
}
else {
    #
    # Now traverse the %Mappings hash, sorted by DN, and generate a mapfile
    #
    foreach my $dn (sort keys %Mappings) {
        my @names = ();

        #
        # First the primary name, if any.
        #
        if (defined $Mappings{$dn}->{primary}) {
            push @names, $Mappings{$dn}->{primary};
        }

        #
        # Then the secondary names, if any, sorted by timestamp.
        #
        if (defined $Mappings{$dn}->{secondary}) {
            my $ref = $Mappings{$dn}->{secondary};
            push @names, sort { $ref->{$a} <=> $ref->{$b} } keys %$ref;
        }

        if (@names) {
            if ($User_Opt->{'real-name'}) {
                my @real_names = ();
                foreach my $name (@names) {
                    my $real_name = User_Real_Name $name;
                    push @real_names, ( defined $real_name ? $real_name : '?' );
                }
                print OUT "$dn ",
                          join(',', @names),
                          " # ",
                          join(',', @real_names),
                          "\n";
            }
            else {
                print OUT "$dn ", join(',', @names), "\n";
            }
        }
    }
}
close OUT;

#
# If we were writing to stdout, we're done.
# Otherwise, copy the temp file to the target files.
#

if ($Write_To_Stdout) {
    exit 0;
}

if (-z $tmp_file) {
    #
    # Something went wrong.
    #
    die "$Prog_Name generated an empty output file\n";
}
OUTPUT_FILE:
foreach my $output_file (@Output_Files) {
    if (not $Force_Update{$output_file} and
        Identical_Files $tmp_file, $output_file)
    {
        #
        # Nothing has changed; don't bother updating.
        #
        next OUTPUT_FILE;
    }
    #
    # Copy temporary file to an intermediate file in the same
    # directory as the target, then rename to the target file.
    # This should make the update an atomic operation (or nearly
    # so?), preventing any processes from seeing a partially updated
    # grid-mapfile.
    #
    # Gridmap_Utils::Check_Tainting '$output_file', $output_file;
    my $intermediate_file = "${output_file}-tmp-$$";
    # Gridmap_Utils::Check_Tainting '$intermediate_file', $intermediate_file;
    # Gridmap_Utils::Check_Tainting '$tmp_file', $tmp_file;
    File::Copy::copy $tmp_file, $intermediate_file
        or die "$Prog_Name: copy to $intermediate_file failed\n";
    # Gridmap_Utils::Check_Tainting '$output_file', $output_file;
    rename $intermediate_file, $output_file
        or die "rename $intermediate_file, $output_file: $!\n";
    if (not chmod $User_Opt->{permissions}, $output_file) {
        my $perm = sprintf "0%03o", $User_Opt->{permissions};
        die "chmod $perm, $output_file: $!\n";
    }
}
unlink $tmp_file;

########################################################################

#
# Given a list of file names, returns a list of names of files that need
# to be updated.
#
# Checks the modification times of the ".update" file and /etc/passwd.
# On systems that don't use YP/NIS or something similar, this detects
# additions and deletions of user accounts.  On other systems (where
# new accounts aren't necessarily reflected in the /etc/passwd file),
# consider running "gx-map -update" periodically.
# 
# Side effect: updates %Force_Update for files that need to be updated
# even if they haven't changed.
#
sub Update_List(@) {
    my @Output_Files = @_;
    Debug "Entering Update_List\n";
    Debug "Output_Files:\n";
    foreach (@Output_Files) {
        Debug "    $_\n";
    }

    my @result = ();

    my $newest_input_mtime = undef;

    my $dot_update_mtime = Gridmap_Utils::Get_mtime $Dot_Update;
    my $etc_passwd_mtime = Gridmap_Utils::Get_mtime '/etc/passwd';

    foreach my $log (@{$User_Opt->{'requests-log'}}) {
        my $mtime = Gridmap_Utils::Get_mtime $log;
        Debug "input mtime ", Gridmap_Utils::Time_Image $mtime, "\n";
        if (not defined $newest_input_mtime or
            $mtime > $newest_input_mtime)
        {
            $newest_input_mtime = $mtime;
        }
    }

    foreach my $output_file (@Output_Files) {
        my $output_mtime = Gridmap_Utils::Get_mtime $output_file;
        Debug "output_file $output_file, output_mtime = " .
              (defined $output_mtime ? Gridmap_Utils::Time_Image $output_mtime : 'undef') .
              "\n";
        if (defined $output_mtime) {
            if (( defined $dot_update_mtime and
                  $output_mtime <= $dot_update_mtime )
                or
                ( defined $etc_passwd_mtime and
                  $output_mtime <= $etc_passwd_mtime ))
            {
                #
                # The output file is older than the .update file
                # and/or the /etc/passwd file.
                # Regenerate the file and update it even if it hasn't changed.
                # (This may involve just updating the file's timestamp.)
                #
                $Force_Update{$output_file} = 1;
                push @result, $output_file;
            }
            elsif ($output_mtime <= $newest_input_mtime) {
                #
                # The output file is older than one or more of the input files.
                # Regenerate the file, but don't update it if it hasn't changed.
                #
                push @result, $output_file;
            }
            else {
                #
                # The output file is newer than any of the input files.
                # It's also newer than the .update file (or the
                # .update file doesn't exist).
                # Do nothing.
                #
            }
        }
        else {
            #
            # stat failed; presumably the output file is missing.
            # It's going to be updated anyay, so don't bother setting
            # $Force_Update{$output_file}
            #
            push @result, $output_file;
        }
    }
    return @result;
} # Update_List

# ----------------------------------------------------------------------

#
# Returns 1 (true) if the two files both exist and are identical,
# 0 otherwise.
#
sub Identical_Files($$) {
    my($filename1, $filename2) = @_;
    my $ok = 1;

    open FILE1, $filename1 or return 0;
    open FILE2, $filename2 or return 0;
    LINE:
    while (1) {
        my $line1 = scalar <FILE1>;
        my $line2 = scalar <FILE2>;
        if (defined $line1 and defined $line2) {
            if ($line1 ne $line2) {
                #
                # The files differ
                #
                $ok = 0;
                last LINE;
            }
        }
        elsif ((defined $line1 and not defined $line2) or
               (not defined $line1 and defined $line2))
        {
            #
            # One file is shorter than the other
            #
            $ok = 0;
            last LINE;
        }
        else {
            #
            # We've reached the end of both files; they're identical.
            #
            last LINE;
        }
    }
    close FILE1;
    close FILE2;
    return $ok;
} # Identical_Files

# ----------------------------------------------------------------------

sub User_Real_Name($) {
    my $pw = Gridmap_Utils::Get_PW $_[0];
    return undef if not $pw;
    my $gcos = $pw->{gcos};
    return undef if $gcos eq '';
    $gcos =~ s/,.*$//;
    return $gcos;
} # User_Real_Name

# ----------------------------------------------------------------------

#
# Returns '?' if the argument is undef, otherwise returns the argument.
#
sub Image($) {
    if (defined $_[0]) {
        return $_[0];
    }
    else {
        return '?';
    }
} # Image

# ----------------------------------------------------------------------

sub Die_Handler($) {
    unlink $tmp_file;
    #
    # Perl will now print the message and terminate.
} # Die_Handler

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Prog_Name [options] [files]
Option names may be abbreviated.
    -help              : Display this message and exit.
    -version           : Display version information and exit.
    -requests-log file : Use specified requests log file.
                         May be given multiple times, e.g.,
                             -req file1 -req file2
                         If not specified, use the default
                         $Default_Requests_Log
                         which may be specified explicitly by the
                         name "default" (which may not be abbreviated.)
    -debugging         : Enable debugging output.
    -permissions perm  : Specify permissions (in octal); default is 444
    -all               : Include entries for nonexistent accounts
                         (not normally recommended)
    -dump              : Instead of generating a grid-mapfile, generate
                         a sorted formatted dump of the requests log file(s).
    -real-name         : Include real names as comments.
One or more output files may be specified on the command line.
If no output files are specified, output is written to stdout.
If output files are specified, they are generated only if necessary, i.e.,
if the input files are newer than the output files.
EOF
    exit 1;
} # Usage

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $User_Opt->{debugging};
} # Debugf
