#!%PERL% -w

# $Id: gx-gen-mapfile.in,v 1.1 2003-05-27 18:46:55-07 kst Exp $
# $Source: /home/kst/gx-map-redacted/gx-gen-mapfile.in,v $

use strict;

use File::Basename ();
use Getopt::Long ();
use Gridmap_Utils ();

sub Get_mtime($);
sub Update_List(@);
sub Identical_Files($$);
sub User_Real_Name($);
sub Usage(@);
sub Debug(@);
sub Debugf(@);


# 
# Make warnings fatal.
# 
$SIG{__WARN__} = sub { die @_ };

my $Install_Dir          = '%INSTALL_DIR%';
my $Data_Dir             = "$Install_Dir/var";
my $Default_Requests_Log = "$Data_Dir/requests.log";
my $Dot_Update           = "$Data_Dir/new-requests/.update";

my $Prog_Name = File::Basename::basename $0;

my $User_Opt = { 'requests-log' => $Default_Requests_Log,
		 'permissions'  => '444' };
my @Opts = ( $User_Opt,
	     qw( help
		 debugging!
		 requests-log=s
		 permissions=s
		 real-name! ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};

$Gridmap_Utils::Debugging = 1 if $User_Opt->{debugging};

my @Output_Files = @ARGV;
my $Write_To_Stdout = (scalar @Output_Files == 0);
my %Force_Update = ();

if ($User_Opt->{permissions} !~ /^[0-7][0-7][0-7]$/) {
    Usage "Permissions must be a 3-digit octal number\n";
}
$User_Opt->{permissions} = oct "0$User_Opt->{permissions}";

if (not $Write_To_Stdout) {
    Debug "\@Output_Files = (@Output_Files)\n";
    @Output_Files = Update_List @Output_Files;
    Debug "\@Output_Files = (@Output_Files)\n";
    if (scalar @Output_Files == 0) {
        exit 0;
    }
}

my @requests = Gridmap_Utils::Read_Records($User_Opt->{'requests-log'});

#
# TODO: Validate records
#

#
# Sort by timestamp
#
@requests = sort { $a->{timestamp} cmp $b->{timestamp} } @requests;

#
# Process removals
#
my %Mappings = (); # key = DN, value = user name

foreach my $request (@requests) {
    #
    # By calling Valid_Mappings, we eliminate any requests for accounts
    # that don't exist on this system.  This should also eliminate any
    # unauthorized requests (which theoretically, could be created only
    # by something like a hacked copy of gx-map).  The Valid_Mappings
    # function can also be modified for site-specific requirements.
    #
    # The Valid_Mappings function may return multiple mappings for a
    # single request.
    #
    my @request_mappings = Gridmap_Utils::Valid_Mappings $request;
    my $operation = $request->{operation};
    foreach my $mapping (@request_mappings) {
	#
	# $mapping is a reference to a hash with keys "dn" and
	# "map_to_name", both optional.
	#
	my $dn          = exists $mapping->{dn}
			  ? $mapping->{dn}
			  : undef;
	my $map_to_name = exists $mapping->{map_to_name}
			  ? $mapping->{map_to_name}
			  : undef;
	Debug ">>> Processing mapping, operation = $operation, dn = ",
	      (defined $dn ? $dn : "undef"),
	      ", map_to_name = ",
	      (defined $map_to_name ? "\"$map_to_name\"" : "undef"),
	      "\n";
        if ($operation eq 'add') {
	    Debug ">>> Add $dn --> $map_to_name\n";
            $Mappings{$dn} = $map_to_name;
        }
        elsif ($operation eq 'remove') {
            if (exists $Mappings{$dn} and
                $Mappings{$dn} eq $map_to_name)
            {
		Debug ">>> Delete $dn --> $Mappings{$dn}\n";
                delete $Mappings{$dn};
            }
        }
	elsif ($operation eq 'remove-dn') {
	    if (exists $Mappings{$dn}) {
		Debug ">>> Delete $dn --> $Mappings{$dn}\n";
		delete $Mappings{$dn};
	    }
	}
	elsif ($operation eq 'remove-user') {
	    my @target_dns = grep { $Mappings{$_} eq $map_to_name }
				  keys %Mappings;
	    foreach my $dn (@target_dns) {
		Debug ">>> Delete $dn --> $Mappings{$dn}\n";
		delete $Mappings{$dn};
	    }
	}
        else {
            die "Internal error, operation = \"$operation\"\n";
        }

	if ($User_Opt->{debugging}) {
	    Debug ">>> Current grid-mapfile entries:\n";
	    foreach my $dn (sort keys %Mappings) {
		Debug "* $dn $Mappings{$dn}\n";
	    }
	    Debug "<<< END\n";

	}
    }
}

my $tmp_file = "/tmp/gx-gen-mapfile-$$";

#
# If we're creating output files, write to a single temp file and
# copy it to the output files later.  Otherwise just write directly
# to stdout.
#
if ($Write_To_Stdout) {
    open OUT, ">&STDOUT";
}
else {
    open OUT, ">$tmp_file" or die "$tmp_file: $!\n";
}

my $Now = Gridmap_Utils::Time_Image time;
$Now =~ s/^\d+ //;       # We don't need the raw numeric timestamp
my $Hostname = Gridmap_Utils::Get_Hostname;
print OUT <<"EOF";
#
# Automatically generated by gx-gen-mapfile
# at $Now on $Hostname.
# Do not edit this file.
#
EOF

#
# Now traverse the %Mappings hash, sorted by DN, and generate a mapfile
#
foreach my $dn (sort keys %Mappings) {
    my $username = $Mappings{$dn};
    my $real_name = undef;
    if ($User_Opt->{'real-name'}) {
	$real_name = User_Real_Name $username;
    }
    if (defined $real_name) {
	print OUT "$dn $username # $real_name\n";
    }
    else {
	print OUT "$dn $username\n";
    }
}
close OUT;

#
# If we were writing to stdout, we're done.
# Otherwise, copy the temp file to the target files.
#

if ($Write_To_Stdout) {
    exit 0;
}

if (-z $tmp_file) {
    #
    # Something went wrong.
    #
    die "$Prog_Name generated an empty output file\n";
}
OUTPUT_FILE:
foreach my $output_file (@Output_Files) {
    if (not $Force_Update{$output_file} and
        Identical_Files $tmp_file, $output_file)
    {
        #
        # Nothing has changed; don't bother updating.
        #
        next OUTPUT_FILE;
    }
    #
    # Copy temporary file to an intermediate file in the same
    # directory as the target, then rename to the target file.
    # This should make the update an atomic operation (or nearly
    # so?), preventing any processes from seeing a partially updated
    # grid-mapfile.
    #
    my $intermediate_file = "${output_file}-tmp-$$";
    system 'cp', '-f', $tmp_file, $intermediate_file;
    if (not -e $intermediate_file or
        -s $tmp_file != -s $intermediate_file)
    {
        die "$Prog_Name: copy to $intermediate_file failed\n";
    }
    rename $intermediate_file, $output_file
        or die "rename $intermediate_file, $output_file: $!\n";
    if (not chmod $User_Opt->{permissions}, $output_file) {
        my $perm = sprintf "0%03o", $User_Opt->{permissions};
        die "chmod $perm, $output_file: $!\n";
    }
}
unlink $tmp_file;

########################################################################

#
# If the named file exists, returns its mtime.
# If not, returns undef.
#
sub Get_mtime($) {
    my($filename) = @_;
    my @stat = stat $filename;
    if (@stat) {
        return $stat[9];
    }
    else {
        return undef;
    }
} # Get_mtime

# ----------------------------------------------------------------------

#
# Given a list of file names, returns a list of names of files that need
# to be updated.
#
# Side effect: updates %Force_Update for files that need to be updated
# even if they haven't changed.
#
sub Update_List(@) {
    my @Output_Files = @_;
    Debug "Entering Update_List\n";
    Debug "Output_Files:\n";
    foreach (@Output_Files) {
        Debug "    $_\n";
    }

    my @result = ();

    my $newest_input_mtime = undef;

    my $dot_update_mtime = Get_mtime $Dot_Update;

     my $mtime = Get_mtime $User_Opt->{'requests-log'};
     Debug "input  mtime ", scalar localtime $mtime, "\n";
     if (not defined $newest_input_mtime or
         $mtime > $newest_input_mtime)
    {
        $newest_input_mtime = $mtime;
    }

    foreach my $output_file (@Output_Files) {
        my $output_mtime = Get_mtime $output_file;
        if (defined $output_mtime) {
            if (defined $dot_update_mtime and
                $output_mtime <= $dot_update_mtime)
            {
                #
                # The output file is older than the .update file.
                # Regenerate the file and update it even if it hasn't changed.
                # (This may involve just updating the file's timestamp.)
                #
                $Force_Update{$output_file} = 1;
                push @result, $output_file;
            }
            elsif ($output_mtime <= $newest_input_mtime) {
                #
                # The output file is older than one or more of the input files.
                # Regenerate the file, but don't update it if it hasn't changed.
                #
                push @result, $output_file;
            }
            else {
                #
                # The output file is newer than any of the input files.
                # It's also newer than the .update file (or the
                # .update file doesn't exist).
                # Do nothing.
                #
            }
        }
        else {
            #
            # stat failed; presumably the output file is missing.
            # It's going to be updated anyay, so don't bother setting
            # $Force_Update{$output_file}
            #
            push @result, $output_file;
        }
    }
    return @result;
} # Update_List

# ----------------------------------------------------------------------

#
# Returns 1 (true) if the two files both exist and are identical,
# 0 otherwise.
#
sub Identical_Files($$) {
    my($filename1, $filename2) = @_;
    my $ok = 1;

    open FILE1, $filename1 or return 0;
    open FILE2, $filename2 or return 0;
    LINE:
    while (1) {
        my $line1 = scalar <FILE1>;
        my $line2 = scalar <FILE2>;
        if (defined $line1 and defined $line2) {
            if ($line1 ne $line2) {
                #
                # The files differ
                #
                $ok = 0;
                last LINE;
            }
        }
        elsif ((defined $line1 and not defined $line2) or
               (not defined $line1 and defined $line2))
        {
            #
            # One file is shorter than the other
            #
            $ok = 0;
            last LINE;
        }
        else {
            #
            # We've reached the end of both files; they're identical.
            #
            last LINE;
        }
    }
    close FILE1;
    close FILE2;
    return $ok;
} # Identical_Files

# ----------------------------------------------------------------------

sub User_Real_Name($) {
    my $pw = Gridmap_Utils::Get_PW $_[0];
    return undef if not $pw;
    my $gcos = $pw->{gcos};
    return undef if $gcos eq '';
    $gcos =~ s/,.*$//;
    return $gcos;
} # User_Real_Name

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Prog_Name [options] [files]
Option names may be abbreviated.
    -help              : Display this message and exit
    -requests-log file : Use specified requests log file
    Default is $Default_Requests_Log
    -debugging         : Enable debugging output
    -permissions perm  : Specify permissions (in octal); default is 444
One or more output files may be specified on the command line.
If no output files are specified, output is written to stdout.
If output files are specified, they are generated only if necessary, i.e.,
if the input files are newer than the output files.
EOF
    exit 1;
} # Usage

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Debugf(@) {
    printf @_ if $User_Opt->{debugging};
} # Debugf
